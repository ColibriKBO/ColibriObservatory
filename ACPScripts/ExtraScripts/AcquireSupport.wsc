<?xml version="1.0" ?>
<package>
	<comment>
<![CDATA[
'tabs=4
-----------------------------------------------------------------------------------------

ACP Scripting Support Component
===============================

Script:         AcquireSupport.wsc
Author:         Robert B. Denny <rdenny@dc3.com>
Version:        ==> 8.2.10 <=== CHANGE LIBVERSION!!!!!
Requires:       ACP 8.1 or later
                Windows Script 5.6 or later

Environment:    This is a Windows Script Component. Once registered (with regsvr32) it
                provides scripts with a set of common capabilities needed for image
                acquisition. If you don't have a copy of PrimalScript 2.1, I STRONGLY
                suggest you get it and use it to work with this WSC.
                
                The key to using the methods and properties herein is the Util.Script
                property of ACP.

Usage:          In your script, create an instance of ACP.AcquireSupport and use it to
                call the methods and properties herein. The methods here rely heavily 
                on ACP's built-in preferences and profile objects.
                

Edit History:
    12-Feb-2003 rbd     Initial edit and checkout
    15-Feb-2003 rbd     Add autofocus, majorplanet, many changes
    17-Feb-2003 rbd     Add minorplanet
    18-Feb-2003 rbd     Add initialize, reorganize <public> 
    20-Feb-2003 rbd     Add ZenithDistance, AirMass, HavePinPoint4, move FITS field
                        setting to TakePicture(), set new fields supported by PP4.
    21-Feb-2003 rbd     Add optional compression of acquired images in TakePicture()
    22-Feb-2003 rbd     Add ForPointing flag to TakePicture()
    24-Feb-2003 rbd     Fix pointing update offset to avoid needless offset after
                        the last try. Add hooks for image simulation, correct 
                        TakePicture(), need J2000 RA/Dec of image for FITS headers
                        as well as the image simultor. Add 2 more parameters.
    25-Feb-2003 rbd     Math library, reimplement EquDist with vectors and USR
                        coordinates, additional functions. New MathLibrary script,
                        vector implementations of EquDist, PA, etc. Added image
                        simulator, bug fixing, etc.
    27-Feb-2003 rbd     More changes and enhancements. AutoFocus needs J2000 coord
                        for return.
    03-Mar-2003 rbd     Correct flip/cal logic for guider. Yield in ImageSim for web.
    04-Mar-2003 rbd     Add J2000/LocalTopo switching and property
    06-Mar-2003 rbd     Break out bright star search, add this to autoguider cal process.
                        Change signature of AutoGuice() to include RA/Dec for bright
                        star search.
    08-Mar-2003 rbd     3.0 now... Omit bright stars with another star within 20 arcsec
                        in FindBrightStar().
    11-Mar-2003 rbd     3.0 - Split out guider calibration, expose to clients. No more
                        initial guider calibration in AutoGuide()!!
    12-Mar-2003 rbd     3.0 - Fix subframe calculation, eliminae guider cals on flip,
                        use new GuiderFlipper object to toggle MaxIm's "Reverse X" 
                        checkbox if mount flips. Handle unguided crossings by toggling
                        flip boolean each time it crosses. Monitor guider startup
                        And fail If corrections are "too large" after 5 exposures.
                        RA/Dec no longer needed as parameters to AutoGuide()
    17-Mar-2003 rbd     3.0 - Add SphDist() and Atan4Q(). Break apart UpdatePointing()
                        and pull out common TakePointingImage(). This allows taking of
                        pointing images without actually syncing the scope.
    18-Mar-2003 rbd     3.0 - Add SimPosError, RMS position error in image sim, arcmin.
    23-Mar-2003 rbd     3.0 - Add Comet() using Kepler and MPC comet elements
                        Fail SolvePlate() softly if either no image or no catalog stars.
                        Fix TakePointingImage(0 offsets, now 2 * FOV and stepping 
                        corrected. Enforce slew limits on pointing image retry offsets.
    02-Apr-2003 rbd     3.0 - Many more additions and more restructuring, support for
                        new MaxPoint technology pointing corrector.
    06-Apr-2003 rbd     3.0 - More additions, testing. New Autoguider control using
                        Flipper so we can set the Reverse X checkbox. Junk old lame
                        pier-side logic, now handled by ACP. Complete pointing
                        corrector integration.
    07-Apr-2003 rbd     3.0 - Move exposure and preview variables into properties here.
                        This prevents scripts using AcquireSupport from HAVING to 
                        implement variables in themr source. Much cleaner. Add AFActive.
    10-Apr-2003 rbd     3.0 - Don't clear previewReady at the start of TakeImage. Just
                        clear it at the start of the script in Initialize.
    23-Apr-2003 rbd     3.0 - Fix spiral search to step 3/4 FOV, not use CatalogExp.
    25-Apr-2003 rbd     3.0 - Correct spelling of m_dLastSolvePosErr[or] in spiral.
                        Fix no cat stars exit logic (used 'n' not 'i').
    26-Apr-2003 rbd     3.0 - Major/minor/comet needed to get JD before computing DeltaT.
                        No catalog stars in FindBrightStar is no longer fatal. If no 
                        cat stars found in image simulator, trace and make a blank image.
    30-Apr-2003 rbd     3.0 - No more Gaussian on plate solving. Made too many stars out
                        of hot pixels.
    01-May-2003 rbd     3.0 - ZDFromAirmass(), split out low level airmass calculation
                        and added first derivative of airmass for Newton-Raphson.
                        LSTRise() calculates LST of object rise above given zenith dist.
    03-May-2003 rbd     3.0 - Switch AutoFocus to use FocusMax AcquireStar. Change some
                        console messages to Trace.
    05-May-2003 rbd     3.0 - Add velocities to MajorPlanet(), MinorPlanet, and Comet()
    06-May-2003 rbd     3.0 - Add HaveTrackOffset property, DoingOffsetTracking property, 
                        SetOffsetTracking() method, GetMPCORB() method.
    07-May-2003 rbd     3.0 - Fix MPCORB stuff.
    12-May-2003 rbd     3.0 - Add DateToJulian() for orbital element epochs.
    13-May-2003 rbd     3.0 - Support for adaptive autofocus. Assure that FindBrightStar()
                        does not cause German mount flipping.
    16-May-2003 rbd     3.0 - Preserve guiding state across autofocus operations.
    19-May-2003 rbd     3.0 - Calibrate pointing images too!
    21-May-2003 rbd     3.0 - Add DeepSky function
    29-May-2003 rbd     3.0 - Add NEOEph() function for NEOCP ephemeris targets
    02-Jun-2003 rbd     3.0 - Fix autofocus to save/restore orbital tracking (needed for
                        adaptive autofocus). Bin pointing exposures down to 3 "/pix max
                        instead of 4. the latter was too much! Fix offset calculation in
                        TakePointingImage.
    03-Jun-2003 rbd     3.0 - Rotate images 180 deg if using GEM and west of pier. This
                        allows auto-stacking of images taken on both sides of pier.
    06-Jun-2003 rbd     3.0 - Test HFD <> 0 to assure successful autofocus (Weber)
    10-Jun-2003 rbd     3.0 - Remove subframing logic from TakePointingExposure. Not
                        that great, and fails if auto-cal is turned on anyway. Fix
                        offset loop in TakePointingImage so failure on all 3 tries doesn't
                        yield a True return.
    11-Jun-2003 rbd     3.0 - Disable ACP UI during image downloading in TakePicture().
                        Uses new Util.UserinterfaceLive property.
    18-Jun-2003 rbd     3.0 - Disable ACP UI during critical phases of autoguiding and 
                        autofocus as well.
    19-Jun-2003 rbd     3.0 - MakeFileName() coverts a target name into a legal Windows
                        file name. Use this in UpdatePointing().
    23-Jun-2003 rbd     3.0 - Once again, fix TakePointingImage offset logic. Missed 
                        usage of OFFSET_TRIES parameter in a couple of places.
    24-Jun-2003 rbd     3.0 - report real error on FindCatalogStars
    02-Jul-2003 rbd     3.0 - Don't do adaptive AF if AF itself is disabled. Fix reset
                        of focus averager on focus completion in new AcquireStar code.
    04-Jul-2003 rbd     3.0 - Try autoguiding only at 1x and 2.5x (2 tries)
    23-Jul-2003 rbd     3.0.1 - Minor cosmetic changes, no change in functionality.
    24-Jul-2003 rbd     3.0.2 - Make overlapped slew/download optional, as well as
                        flipping images from GEM west of pier. These are parameters
                        (Const) up top, scheduled for Preferences in future release.
                        Change re-slew tolerance from fixed 2 arcmin to the pointing 
                        updates "max err" tolerance. This tolerance will be used for 
                        re-slew regardless of whether pointing updates are enabled.
    31-Jul-2003 rbd     3.1 - Make above switches tie into new ACP 3.1 properties. 
                        Add smarter guider cycle timing with new CycleTime property.
    06-Aug-2003 rbd     3.1 - Add RangeValue to lib, use it in lib functions. Add code
                        for sync-less pointing updates. Test CanSync to switch. Get
                        starting random RMS simulator position error from PtgErrGen
                        area under UserData in registry. Default to 0.5 arcmin. Re-
                        enable Gaussian convolution for plate solutions.
    26-Aug-2003 rbd     3.1.1 - OOPS! Set Plate.ImageModified = False to prevent convolved
                        image from being written back to file!
    19-Sep-2003 rbd     3.1.2 - Switch MaxIm cal mode from Auto-Optimize to Auto-Scale
    15-Oct-2003 rbd     3.1.2 - Fix DeepSky() to properly detect False return (not raised
                        error) from MiniSAC. Add console-logged messages for all raised
                        errors. This allows "expected" errors to be logged instead of 
                        producing a "generic" failure at the call site in the script.
    16-Oct-2003 rbd     3.1.2 - Clean up error handling in SolvePlate(). Failure to find
                        any image stars exited wrongly.
    27-Oct-2003 rbd     3.1.2 - Do not bicubic interpolate when rotating!
    29-Oct-2003 rbd     3.1.2 - TakePointingImage() now uses the currently selected filter.
    06-Jan-2004 rbd     3.1.3 - Remove bogus tracking control code from UpdatePointing().
    21-Jan-2004 rbd     3.1.3 - TakePicture now returns True only if SlewNext was True
                        AND if the post-slew was actually done (will not be done if target
                        below horizon, etc.)
    03-Mar-2004 rbd     3.1.3 - Add filter focus offset support, new CalcSlewTarget() for
                        offset slewing after pointing update, add delay loop waiting for
                        guider to stop in AutoGuide(False). Many small changes in tracing.
                        Tracing is now commented out to avoid needless o/h.
    04-Mar-2004 rbd     3.1.3 - If no FilterInfo.txt is available, we're back to using 
                        the clear filter for pointing exposured (undo change of
                        29-Oct-2003). Sorted <public> interface area. Custom actions
                        component, new Terminate() method for same. Add HaveFilterInfo
                        and LastFocusPosition properties. Remove old AdaptiveAutoFocus
                        property. It is a r/o pref.
    05-Mar-2004 rbd     3.1.3 - Image simulator now has Light parameter, can produce
                        darkframes.
    07-Mar-2004 rbd     3.1.3 - Start each run with Clear filter selected for imaging
                        Fix Comet(), the epoch calculation was off!
    08-Mar-2004 rbd     3.1.3 - Fix guider start to detect star loss while waiting for
                        new measurement. Check guider before each exposure. Dither 
                        exposures if guiding. New UnifRand() public method. Increase
                        MAX_GUIDING_ERR to 1.5 to allow for dither and atmosphere.
                        Add console output of J2000 coordinates for MP/Comet elements.
    09-Mar-2004 rbd     3.1.3 - Remove offset slewing except for unsync-able scopes.
                        Use new CalySewTartet routine(0 for that instead of the old
                        small-angle approximation that would blow up around the poles.
                        Re-work the guider monitoring and dithering code to ignore
                        occasional large guide errors, and wait for dithered guiding
                        to get back into limits. Fix dithering to move randomly in
                        BOTH directions relative the original guidestar position. 
                        No more drunkard's wander algorithm.
    10-Mar-2004 rbd     3.1.3 - Add Dither parameter to TakePicture, no more fixed
                        dither amount. This makes dithering user-controllable.
    12-Mar-2004 rbd     3.1.3 - Smart autoguider startup. Add XYDist(). Restore post-focus
                        pointing update, but only if FocusMax AcquireStar is turned off.
    16-Mar-2004 rbd     3.1.3 - Fix ImageEnd event. Fix leftover uses of old fixed guider
                        max error. Now always uses c_guideErrMax.
    18-Mar-2004 rbd     3.2 - Increase pointing update platesolve timeout to 45 sec.
    22-Mar-2004 rbd     3.2 - Fix AutoGuide failure mode on SetupGuider returning -1
    23-Mar-2004 rbd     3.2 - Reduce default SNR goal to 3.5, reduce default min guiding 
                        exposure to 0.5
    25-Mar-2004 rbd     3.2 - Limit calc'd guide exposure interval to 2 decimal places
                        Add DecComp variable to GuiderConfig.txt. Always wait at least
                        10 sec. for GuiderNewMeasurement.
    31-Mar-2004 rbd     3.2 - Catch StartSlew error in TakePicture() make limit errors
                        non-fatal.
    07-Apr-2004 rbd     3.2 - Restore previous filter in TakePointingUpdate() even when
                        there is no filter info. Always use Clear filter in that case.
                        Log each loop waiting for guider in TakePicture(). Close simulator
                        images in MaxIm 4 using new Document.Close(). Display for 2 sec.
    20-Apr-2004 rbd     3.2 - Expose FindBrightStar()
    08-Jun-2004 rbd     3.2.4 - Note on SNR calculation. No code changes.
    29-Jul-2004 rbd     3.2.6 - Subpixel guider fixes, see Case #131 in TrackStar
                        Changes from Jim McMillan.
    04-Aug-2004 rbd     3.3.2 - Fix the above sub-pixel guiding, X and Y were reversed.
                        FocusMax 3.2.1 has race condition on async startup. Add 2 sec
                        wait before testing completion.
    06-Aug-2004 rbd     3.3.3 - Add ExternalGuider parameter to GuiderConfig.txt, expose
                        this boolean to client scripts. Used for guider start/stop
                        optimization.
    19-Aug-2004 rbd     3.3.3 - Fix ACP autofocus for focus star mag > 8.
    07-Sep-2004 rbd     4.0 - Add UserActions property, [put] for ExposureActive.
    19-Sep-2004 rbd     4.0 - Support new PinPoint "save stars files" preference.
                        Remove GetGuiderSettings() and read smart-start stuff from
                        new ACP.Prefs.AutoGuider prefs. Always do offset slewing and
                        sync before, and only when allowable. Add restriction to sync
                        only below Abs(dec) of 70 deg. 
    23-Sep-2004 rbd     4.0 - Explicitly need to close JPEG preview and thumbnails
                        for MaxIm 4. Separate auto-cal settings for pointing and final
                        images.
    24-Sep-2004 rbd     4.0 - Write corrected focal length back to ACP, new properties 
                        LastSolveScaleH, LastSolveScaleV
    09-Oct-2004 rbd     4.0.2 - Raise error in Initialize() if Dome is closed. Unpark 
                        scope in Initialize() if Dome is open or no Dome.
    11-Oct-2004 rbd     4.0.3 - Limit focal length write-back to 20% change
    14-Oct-2004 rbd     4.0 3 - Give MaxIm 1 sec to restart guider after image download
    17-Oct-2004 rbd     4.0.4 - Fix bug in UpdatePointing()'s focal length write-back.
    23-Oct-2004 rbd     4.0.5 - Add VBS and JS flavors of Neville interpolation function
    25-Oct-2004 rbd     4.0.5 - Add 0.5 sec delau between closing and disposing of MaxIm
                        Document used for JPEG preview, to prevent MaxIm crash when it is
                        auto-started. This will be fixed in MaxIm 4.07. Change NEOEph()
                        completely. It now takes multiple ephemeris records, and does
                        interpolation for position and velocity.
    06-Nov-2004 rbd     4.0.6 - Voice all over the place. Unguided dithering. New 
                        properties PlateScaleH/V (needed for unguided dithering),
                        and FieldOfViewH/V/Min. Remove redundant Console.PrintLine for
                        Err.Raise calls. This was stupid.
    15-Nov-2004 rbd     4.0.7 - New Shutdown() and CreateFolder() methods. TakePicture()
                        now recognizes interval 0 as a bias frame. 
    18-Nov-2004 rbd     4.0.7 - Jim McMillan :-) Turn off tracking during darkframes.
    02-Dec-2004 rbd     4.0.8 - Simulator random errors scaled to 40 deg instead of 10 deg.
    18-Jan-2005 rbd     4.1.0 - No longer fails for domes with no shutter control
                        (case #153)
    20-Jan-2005 rbd     4.1.0 - Add new LocalTopo to J2000 conversion facility
                        Increase sim FWHM to 5" so bin=2 images will stack in MaxIm (were
                        failing for stars too small - looked like hot pixels).
    21-Jan-2005 rbd     4.1.0 - Add new LastSolveRAJ2000 and LastSolveDecJ2000 props
                        Eliminate need for PinPoint reattach to get just-solved center
                        point coordinates. Use new internal property globals. Add new
                        public method RecenterTarget(), factor out of UpdatePointing().
                        Restore scaling of random sim pos errors to the Prefs.MaximumSlew
                        value instead of a fixed 40 degrees.
    23-Feb-2005 rbd     4.1.1 - UserActions.ScriptStart() now runs before dome test and 
                        right at the beginning of Initialize()
    24-Feb-2005 rbd     4.1.1 - New LastSolveRollAngle property, initialize LastSolvePosErr
                        to 0 to indicate no plate solution yet. Used in new Starry Night
                        plugin for FOV labeling and position angle. Add roll angle to
                        image simulator, controlled in PtgErrGen registry area.
                        LastSolvePosErr = 0.0 now means no solution data available.
    25-Feb-2005 rbd     4.1.1 - Fix image simulator so it is north-up.
    26-Feb-2005 rbd     4.1.1 - Log imager roll angle and true focal length for pointing
                        images (only).
    04-Mar-2005 rbd     4.1.1 - Make RecenterTarget() safe for guiding
    07-Mar-2005 rbd     4.1.1 - Increase autoguiding startup max to 20 cycles.
    22-Mar-2005 rbd     4.1.2 - Expose CalcSimImageCoordinates() and separate from 
                        StartSlewJ2000(). Change to support manually positioned targets
                        which never slew, yet still allow for image simulation.
    06-Apr-2005 rbd     4.1.3 - TakePicture guider settle loop limit 10 -> 20 to match
                        the loop limit in AutoGuide().
    09-Jun-2005 rbd     4.1.4 - Chip border in SetupGuider increased to 16 - for MaxIm 
                        32x32 pixel guiding exposure subframe.
    19-Jul-2005 rbd     4.1.5 - Rework AutoGuide() logic for last-ditch retry at max
                        guider interval.
    28-Jul-2005 rbd     4.1.6 - Rotator support. Report guider errors within limits after
                        waiting for same. Allow cal failure to be non-fatal, save uncal'd
                        image. Catch hole where below horizon with overlap slew/dl OFF
                        causes just-acquired image to NOT be saved. Adopt new roll-angle
                        convention, counterclockwise from North. This affected the image
                        simulator's (non-rotator) registry roll angle setting now uses
                        this convention. Change interface to TakePicture to include
                        RotNext (true to start rotation to next tgt after picture) and
                        NextPA (rotation angle of next target). Exposed new method
                        PlateToPA(). Changed interface to SolvePlate(), TakePointingImage()
                        and UpdatePointing() also to add PA.
     02-Aug-2005 rbd    4.1.6 - More rotator - CalibrateGuider() rotate to 0 deg. PA. Also
                        added code to switch to "pointing" or clear filter for guider cal.
     05-Aug-2005 rbd    4.1.6 - Add property RotatorPositionAngle, which returns the sky PA
     07-Aug-2005 rbd    4.1.6 - Guiding angle control for rotators.
     12-Aug-2005 rbd    4.1.6 - Always recenter after a pointing exposure if using an
                        internal guider.
     23-Aug-2005 rbd    4.1.7 - Split Range() into RangeAngle() and RangeTime(), correct
                        angular ranging for -180 to 180, remove stray debugger; statement
                        in MathLibrary, remove double rotation of guider angle for GEM
                        West. StartRotateToPA() needs RA and must test for GEM west using
                        the given RA and not the current scope RA, as the scope may be
                        slewing (probably will be!).
     24-Aug-2005 rbd    4.1.8 - Use MaxIm "dark" mode for both dark AND bias frames.
                        Add guide angle sign reversal for rotator optics reverse. Fix
                        reporting of re-rotate on PA error. Add reporting of guide star
                        SNR and X-Y in SetupGuider().
     25-Aug-2005 rbd    4.1.8 - Disable write-back of focal length to ACP. Sanity check 
                        plate-solutions, reject focal length > 20% from ACP setting.
                        Report imager PA and true focal length on all plate solutions.
                        Report when plate solution updates pointing corrector.
     01-Sep-2005 rbd    4.1.9 - Fix rotation for case where DisableSlewOverlap is True
     02-Sep-2005 rbd    4.1.9 - Fix fencepost error in image sim for negative PA
                        Fix guide star SNR calculation. Wrong value for B/G flux!!
                        Now uses actual star area instead of aperture. Wow!!
     08-Sep-2005 rbd    4.1.10 - HF5 Fix typo in AutoGuide(), fix HourAngle() for boundary.
     10-Sep-2005 rbd    4.1.11 - HF5a Don't log waiting for slew if not slewing in 1st 
                        place. 
     29-Sep-2005 rbd    4.1.12 - Add software rollover indicator to FITS (ACP_ROLLOVER=Y)
                        When doing guided dithering, require 5 successive good guider
                        error measurements before considering the guider to be started.
                        Add ROTATOR_PA to FITS, raw mechanical rotator PA, then use this
                        in SolvePlate() as a better way to calculate c_LastRotatorPAOffset.
     01-Oct-2005 rbd    4.1.13 - Shorten ACP_ROLLOVER and ROTATOR_PA to be within 8-char
                        FITS field name limit.
     05-Oct-2005 rbd    4.1.14 - Limit FocusMax execution time to 5 min (MXAFTIME const)
                        Add new property MaxAutofocusTime, seconds. Fix spurious message
                        "Internal guider, always re-slew" for external guider that needs 
                        reslew. Report telescope name and driver version, dome name (if
                        dome is enabled), imager name, guider name and internal/external 
                        (if enabled), weather server name (if enabled) in log.
     31-Oct-2005 rbd    4.1.15 - Fix rotator support for "disable slew overlap". Trace
                        AcquireSupport version at init. Remove broken HourAngle() method
                        Should use (correct) Util.HourAngle12() in ACP anyway. Change all
                        calls here to use that.
     14-Nov-2005 rbd    4.1.16 - Limit pointing exposures to 0.5 deg FOV by subframing
     16-Nov-2005 rbd    4.1.16 - SolvePlate() -- Fix calculation of c_lastSolvePA for
                        corner case where scope drifts past westbound flip point after
                        exposure but before calculation. See commends at the bottom of
                        SolvePlate().
     17-Nov-2005 rbd    4.1.16 - AutoFocus will refuse if within 5 deg of ACP slew limits
                        unless using AcquireStar and the Zenith mode is turned on. This
                        prevents problems where focus star ends up below limits or the
                        original target position drifts below limits during the autofocus.
                        UpdatePointing will refuse and return False if within 1 degree 
                        of the slew limits. New master ephemeris calculater, used
                        internally by TakePicture for the post-slew, and simplifying the
                        client scripts who now just call this one function for elements,
                        NEOCP tables, or "MP xxxx" style MPCORB lookup. TakePicture now
                        has yet ANOTHER parameter, the MP source line, allowing recalc
                        of ephemerides before the slew-ahead to the next target.
                        Increase MaxSolveStars on pointing updates to 300.
     29-Nov-2005 rbd    4.1.17 - Reduce interval between Yield() calls in image sim to 
                        improve web response during simulation. This was causing web
                        timeouts with A2.0 catalog and star-rich sky areas.
     01-Dec-2005 rbd    4.1.17 - Fix subframe calculation for pointing exposures.
     27-Dec-2005 rbd    4.2.1 - Add MECH_ERRORS_ALWAYS for simulation with mech errors
                        when not using pointing corr. Always initialize the pointing 
                        error generator.
     03-Jan-2006 rbd    4.2.1 - Clean up guider startup messages. Disable CA for pointing
                        update offsets. Needs 4.2 new property.
     08-Jan-2006 rbd    4.2.1 - New dome pref properties control whether dome slaving is
                        active during imaging. Log the 3 Err.Raise conditions in Initialize()
                        since raised errors can't percolate back into client. 
                        New dome pref allows imaging with dome closed.
     09-Jan-2006 rbd    4.2.1 - Remove UserInterfaceLive toggle from CalibrateGuider - 
                        slewing not legel while active. Disable dome slaving during
                        guider calibration. Change MAXAFTIME to 10 min. Try to plug timing
                        window where Fmx.Halt called wiieh FM not busy. If this happens, 
                        FM will hang forever, never returning from the call! Fix 
                        AutoGuide(False) so c_Guiding is always set False, and also
                        add logged message if guider has already stopped on its own.
     16-Jan-2006 rbd    4.2.2 - AutoFocus() never does a final plate solution, and no
                        longer restores guiding or orbital tracking. Now requires FM
                        3.3.6 or later, fails if too old (3.3.6 has new property to
                        inhibit its final plate solution). No longer freeze ACP UI
                        during AF operations. Too unsettling for users.
     20-Jan-2006 rbd    4.2.3 - Missing Dim of prevCA in TakePointingImage()
     22-Jan-2006 rbd    4.2.4 - Fix rotator bias calc when looking east
     24-Jan-2006 rbd    4.2.4 - Fix bad element reporting in CalcEphemeris(). Fix
                        CalcEphemeris() to handle cometary fragment names such as
                        "0073P-B/..." - now use RegExp to detect cometary elements.
     28-Jan-2006 rbd    4.2.5 - Expose SolveFails counter so may be reset by clients.
                        New FilterExists() method.
     31-Jan-2006 rbd    4.2.5 - Remove error dismissal on unparking. This is now handled
                        in ACP, using a registry setting. This was a kludge for scopes
                        that raise an error if Unpark() called when not parked (contrary
                        to the spec).
     01-Feb-2006 rbd    4.2.6 - Don't change guider angle if simulating. Remove all old 
                        PP3 vs PP4 code, always report True for HavePinPoint4 property. 
                        It's included with ACP! Remove code to fix up IMAGETYP for bias
                        frames. MaxIm 4.10 and later do this properly for 0-interval
                        light frames.
     07-Feb-2006 rbd    4.2.7 - Add GetNextLiveLine() for plan parsing. Detect AO-7 and
                        allow for its 6 dark frames at the beginning of the tracking
                        cycle. Change CalibrateGuider() not to FindBrightStar for internal
                        guiders (they already have a star) and don't rotate to 0, so it
                        can be used to calibrate an AO-7. Also in CalibrateGuider, no
                        longer raise an error if calibrating above 70 deg Dec, just 
                        return False. Fix CalibrateGuider() so it waits for the slew to 
                        the FindBrightStar target (oops).
     09-Feb-2006 rbd    4.2.7 - Only recal AO-7 if rotation changes, but always cal it 
                        when starting the plan (if rotator present, that is!).
     10-Feb-2006 rbd    4.2.7 - Fix SNR logged in SetupGuider(). Move guider exposure
                        limiting to SetupGuider().
     11-Feb-2006 rbd    4.2.7 - Remove check for pointing updates enabled in ACP prefs.
                        This allows UpdatePointing() to be called unconditionally.
     13-Feb-2006 rbd    4.2.7 - Add logging of true sky position in SolvePlate()
     22-May-2006 rbd    4.3.1 - Fix 4 Profile reads which were '.' vs ',' decimal
                        unfriendly.
     26-Jun-2006 rbd    4.3.1 - For Scheduler 2.0, add property SimImageTimeCompress,
                        allowing Scheduler jobs to disable the 10:1 time compression 
                        for simulated images.
     28-Jun-2006 rbd    4.3.1 - Save auto-calibrated final images as 32-bit FP for new
                        PinPoint. Improve cal failure logging (log MaxIm error msg).
                        Simulator can save as FP-32 as well, new parameter. Prevent
                        imager and rotator PA from showing 360.0 (show 0.0). Change 
                        NOVAS placeholder planet number from 100000 to 600000 in support
                        of MP numbers > 100000 now. Remove unneeded code for passing a
                        planet number through NOVAS to Kepler; this was preventing use
                        of new alphanumeric MP numbers. Just pass 0 instead. Assure 
                        minimum 5 sec delay between track off and on for dark frames.
                        Allow up to 20 minutes for imager warmup, report once a minute.
                        Remove Park and Cooler parameters from Shutdown(), add a new
                        Shutdown() user action to Shutdown(). Default values for 
                        LastFocusHFD, LastAverageHFD, and PosErrRMS are now protected 
                        against '.' vs ',' decimal separators.
     06-Jul-2006 rbd    Add new object oriented methods MajorPlanetOb(), MinorPlanetOb(),
                        CometOb(), and NeoEphOb(). Wrappers for new AcquireImages2.
     11-Jul-2006 rbd    FilterExists() can now handle numeric or named filters.
     12-Jul-2006 rbd    Fix interface to StartRotateToPA to include RA parameter. Oops.
                        Prevent guidestar SNR during simulation from being a giant number
     13-Jul-2006 rbd    Add PIERSIDE field to FITS. This is the pier state at the time
                        the image was acquired. Used for rotator PA calculation. See
                        notes at end of SolvePlate(). Move capture of Rotator PA and
                        pier side to location before pre-slew! Correct spurious "PA error 
                        of 360.0 deg. detected. Correcting..."
     14-Jul-2006 rbd    Change Err.Raise 32768 to Err.Raise vbObjectError for compliance.
     17-Jul-2006 rbd    Complete lint check of JScript sections
     18-Jul-2006 rbd    Change some parameters of the image simulator. Reduce FWHM,
                        reduce exposure time to reach limiting mag.
     24-Jul-2006 rbd    Change compression type for JPEG thumbnails and Confirmation images
                        to 1. This is what's really needed (not 0) for 85% JPEG quality.
     25-Jul-2006 rbd    Remove a few remaining reduncant Console.PrintLine(0 calls for 
                        raised errors. Reporting is handled by clients.
     30-Aug-2006 rbd    4.3.2 - Correct object-oriented ephemeris methods, can't use
                        object properties as ref parameters. Don't roll over dark or bias
                        images when GEM is west of pier and rollover in effect. Check to
                        see that shutter is open before taking a picture. This handles
                        the case where the shutter is controlled through some hardware
                        scheme and closes without action by ACP. Abort if taking a light
                        frame and the shutter has been closed by some outside source.
     31-Aug-2006 rbd    4.3.2 - Add [put] to AutofocusActive (for utility focus scripts)
     20-Oct-2006 rbd	5.0.1 - Version change only.
     01-Nov-2006 rbd	5.0.2 - Add RSS Journal file method.
     08-Nov-2006 rbd    5.0.2 - Add RotatorMoving property
     15-Nov-2006 rbd    5.0.3 - Write PA offset to RotatorInfo.txt, read on init(). Catch
                        attempt to use rotator with pointing updates disabled, fail.
     19-Nov-2006 rbd    5.0.3 - Fix CalcEphemeris(), no longer should re-insert leading 
                        blanks on unnumbered comet elements. They come in unmolested.
                        Add ForceCal parameter to TakePicture(). Makes incompatible with
                        old 4.2, but hey...
     28-Nov-2006 rbd    5.0.4 - Speed up quiet-wait image timer by 10%. Inaccurate timing
                        of Util.WaitForMilliseconds was inflating image times by 10%. Fix
                        TakePicture like Initialize() so it will slew with closed shutter
                        if Util.Dome.ScopeClearsClosedDome is true. 
     01-Dec-2006 rbd	5.0.5 - Fix guider retry numbering to start with 1 not 0
     06-Dec-2006 rbd    5.0.5 - No more HFD growth unless AdaptiveAF is turned on. Change
                        time-to-adaptive-limit from 5 to 10 minutes. Disable the slew
                        progress feature, making the thermo stay at 0, till I can figure 
                        out a way to do it right. Switch to using new PinPoint image
                        simulation method Plate.SynthesizeStarfield(). Correct exposure
                        interval in sim images FITS.
     07-Dec-2006 rbd    5.0.6 - Remove old image sim code, correct FITS exposure interval 
                        if simulating, honor SimInageTimeCompress property in that logic.
                        Log focus-offset focus changes when changing filters.
     11-Dec-2006 rbd    5.0.6 - for FocusMax to start when simply changing filter offset.
                        Prevents occasional "Focuser Link Failed" errors from FMX. Save
                        and restore focuser's TempComp setting across offset change. Save
                        and restore Link state across offset change.
     24-Dec-2006 rbd    5.0.7 - Allow rotator drift up to MAX_AO_ROTATOR_DRIFT for the 
                        RCOS rotator, which appears to drift. Change sentinel for initial
                        AO rotated calibration to Null to avoid missing it if the rotator
                        is really at 0.0 deg.
     01-Jan-2007 rbd    5.0.8 - Fix camera download timeout for shortened pre-timer. No
                        longer look at Prefs.CameraPrefs.Timeout, it's out of the UI now.
     11-Jan-2007 rbd    5.0.9 - Auto-dither support
     12-Jan-2007 rbd    5.0.9 - Assure scope disconnected, disconnect camera, on shutdown.
     15-Jan-2007 rbd    5.0.10 - Fix minorPlanet, Comet, and NEOEph to handle CDbl() of 
                        strings (elements, ephs) with '.' separator by switching locale
                        to "en-us" temporarily.
     14-Mar-2007 rbd    5.0.11 - (ACP 5.0a) AutoGuide() ... missing Dim needAOCal
     24-Jun-2007 rbd    5.0.12 - (post 5.0a) Dang, another locale isue, this time for 
                        reading the raw ROT_PA FITS field.
     27-Jun-2007 rbd    5.0.12 - Reduce time to limiting mag in simulator to 60 sec.
     04-Jul-2007 rbd    5.0.12 - Set ExposureStartTime on plate in FindBrightStar as 
                        needed by PinPoint 5.
     19-Jul-2007 rbd    5.0.12 - New rotator guiding polarity properties.
     16-Aug-2007 rbd	5.0.13 - Delete pointing images for successful updates
     11-Sep-2007 rbd	5.0.14 - Allow up to 15 deg angle change before recal AO
     27-Sep-2007 rbd    5.1.1 - No voice on bias frame, gets behind. Remove "0 sec" from
                        bias frame log line. Wait for slew after AcquireStar AF. Total
                        overhaul of adaptive AF, using FWHM. Remove actual adaptive AF
                        from here, it's now the responsibility of the client script. 
                        Add new LastAverageFWHM and LastFocusFWHM properties, remove 
                        old adaptive AF-related properties.
     28-Sep-2007 rbd    5.1.1 - If calibrating, save original as Raw-xxxx
     05-Oct-2007 rbd    5.1.2 - Fix Camera.SaveFile() in the above
     10-Oct-2007 rbd    5.1.3 - Add config var to control saving raw images when doing
                        auto-calibration. Change logic in TakePicture() for slew-ahead
                        safety check, allowing imaging with shutter closed if the scope
                        clears it.
     16-Oct-2007 rbd    5.1.3 - Reduce solution acceptance focal length check from 20%
                        to 10%.
     01-Nov-2007 rbd    5.1.4 - In CalibrateGuider() don't do cal return slew unless
                        actually did a slew out to cal in the first place. New property
                        GuiderRunning, for testing both conventional and AO. Add new
                        logic for AO drive calibration without really calibrating.
     03-Nov-2007 rbd    5.1.4 - Finalize open-loop AO cal, fix CSng() in Autofocus for
                        non-English systems. Adjust PP sigma lower for AOx in SetupGuider.
     05-Nov-2007 rbd    5.1.4 - Add 10 sec filter switch delay for AO. Fix AO polarity for
                        GEM. Allow for 10 AO darks, 5 cycles in WaitForGuider.
     15-Nov-2007 rbd    5.1.5 - (HF2) Oops, fix setting guider angle on non-AO 
                        rotated/internal
     15-Nov-2007 rbd    5.1.5 - (HF2) Extend pointing update binning to 6 for low-scale 
                        imagers
     31-Mar-2008 rbd    5.1.6 - (HF5) Hey! Never used the AO-aware GuiderRunning property
                        from 5.1.4. Thus, an AO could get lost and just stop sending
                        measurements. 
     02-Apr-2008 rbd    5.1.6 - (HF5) Make 2 passes through SetupGuider() to get best
                        exposure estimate.
     03-Apr-2008 rbd    5.1.6 - (HF5) Remove ConvolveGaussian. Much better on noisy chips
                        and doubtful for most imagers. Improved platesolving a lot! Major
                        upgrade of AO control. Now gets base trackbox count before 
                        starting, then uses that as baseline for testing if it is running
                        later. See AutoGuide() and get_guiderRunning. Also do 2 passes thru
                        SetupGuider, to get a better SNR and exposure calculation. Verify
                        that PinPoint usage for SNR measurement is optimum. Don't report 
                        rotator misalignment, let the mech and sky positions speak for 
                        themselves.
     12-Apr-2008 rbd    5.1.6 - (HF5) Fix reading FilterInfo.txt to skip lines containing
                        only 1 or more spaces. Remove the "plate scale too high) message
                        on pointing update plate solutions.
     14-Apr-2008 rbd    5.1.6 - (HF5) Airmass was using current scope coordinates but scope
                        could be pre-slewing. Capture image-time scope coordinates and use 
                        them. Limit binning on pointing exps to 4"/pix instead of 6, now
                        that we don't do the Gaussian blur.
     17-Apr-2008 rbd	5.1.7 - (HF6) Catch -1 exposure interval (failure) on second phase
                        of SetupGuider().
     21-Apr-2008 rbd	5.1.7 - (HF6) Fix camera cooler warming to avoid asymptotic warming.
     05-May-2008 rbd	5.1.7 - (HF6) Restore binning up to 6 for pointing, and target 4"/pix.
     11-Jul-2008 rbd    5.1.8 - (HF7) Increase anti-flip safety margin for autofocus that
                        uses old FindBrightStar from 2.5 to 5 deg.
     29-Sep-2008 rbd    5.1.8 - (HF7) Remove all AO trackbox stuff. This was a loser. Keep 
                        the 2-phase exposure calculation though. Add new HaveAO property.
     03-Oct-2008 rbd    5.1.8 - (HF7) EGAD, must wait for new darkframes after guided
                        dither with AOx. Improve logging for guider startup as well.
                        Remove obsolete MAX_AO_ROTATOR_DRIFT constant.
     05-Oct-2008 rbd    5.1.8 - (HF7) Fix AO startup so that both ex AND ey must be 0 for 
                        it to reject guided dither measurement. I found that either can
                        be 0 during a good startup. Add a message after dither that the
                        exposure is starting.
     17-Oct-2008 rbd    5.1.8 - (HF7) Add error trap if impossibly clean guider image is
                        detected. Fix unguided dithering for unsyncable scopes. Use
                        centering slew destination coordinates not the target coordinates.
     18-Oct-2008 rbd    5.1.8 - (HF7) Refactor filter selection logic. Arose from need to
                        always avoid reselecting existing filter for SBIG bug. 
     23-Oct-2008 rbd    5.1.8 - Major refactoring of filter control. Expose new member
                        SetFilterForTask().
     30-Oct-2008 rbd    5.1.8 - (HF7) Increase auto-dither values for change from Gaussian
                        to Uniform random. This should have been done long ago!
     11-Nov-2008 rbd    5.1.9 - (HF7a) Fix new filter logic for darks/biases. Shorten max
                        cooler warming time to 10 min, add cooling rate test for cold
                        weather, stops at 0.05 deg/sec.
     12-Dec-2008 rbd    5.1.10 - (HF8) Camera warming finishes if rate < 3 deg per minute.
     14-Jan-2009 rbd    5.1.10 - (HF8) "Impossibly clean" check on guider image changed to
                        accommodate 8-bit guiding sensors.
     27-Jan-2009 rbd    5.1.10 - (HF8)Create FocusMax.FocusControl before FocusMax.Focuser so
                        FocusMax will start reliably.
     12-Feb-2009 rbd    5.1.11 - (HF9) Fix JPEG scaling for boundary condition. Increase
                        JPEG quality to 95%.
     13-Mar-2009 rbd    5.1.12 - (HF9)Fix differential camera warming for cameras that start
                        warming slowly. The logic was just plain wrong.
     06-Apr-2009 rbd    5.1.12 - (HF9) Alternative warming fix per John Winfield. Better!
     12-May-2009 rbd    5.1.12 - (HF9) Reduce sigma on PinPoint for AO star detection 
                        to 2 so can see even fainter guide stars. TOTAL OVERHAUL OF AO
                        BUMPING POLARITY HANDLING PER RESEARCH. Now handles OAGs via the
                        Flip switch on the Rotator Controller. No more Mirror for internal
                        guider.
     02-Jun-2009 rbd    5.1.12 - (HF9) Remove filter initialization to "clear". This was
                        bogus.
     10-Jun-2009 rbd    5.1.12 - (HF9) Hack at end of AutoFocus() to prevent the release
                        of a demand-started FocusMax from changing MaxIm's filter selection.
                        Unknown WHY this is happening, but the hack prevents it.
     11-Jun-2009 rbd    5.1.12 - (HF9) Allow starting plan with potentially hazardous 
                        shutter/roof. Refuse slewing with error if closed.
     15-Jun-2009 rbd    5.1.12 - (HF9) Wait for dome slave slewing before starting slew.
     28-Jun-2009 rbd    5.1.13 - (HF9) Bit the bullet and changed the RotatorGuiding
                        interface to supply OAG and OAGAngle, handling the case of an
                        OAG with the guider sensor rotated w.r.t the main sensor. Add
                        logic for a rotated guide sensor in the OAG case.
     08-Jul-2009 rbd    5.1.14 - (HF9) Reporting of internal vs OAG backward in new AO
                        logic.
     02-Aug-2009 rbd    5.1.15 (HF10) - Fix unguided dither for case where no pointing
                        update is done (tgt too close to prev). Was slewing back to prev
                        target!
     24-Aug-2009 rbd    5.1.15 (HF10) - Correct guider angle range to -180 to 180 and
                        range the angle for non-OAG (was missing).
     14-Oct-2009 rbd    5.1.15 (HF10) - GEM:206 - Catch FilterInfo errors, mismatches 
                        between #filters in camera and lines in FilterInfo, both edges.
                        Refactor: Move AF-off focuser selection into its own function.
     23-Oct-2009 rbd    5.1.15 (HF10) - GEM:249 Move PointingExps to MyDocs\ACP\Images
                        to avoid (x86) in path which triggers PinPoint/CFITSIO crazy
                        path munging. 
     25-Oct-2009 rbd    5.1.15 (HF10) - GEM:129 PNG thumbnail and popup. GEM:258 Make
                        cross-hatch scaling an option, add property for AcquireImages
                        to see if this is on or off.
     03-Nov-2009 rbd    5.1.16 (HF10) - GEM:278 SetupFocuser() crashes run. Missing 
                        declaraions and test for filters.
     04-Nov-2009 rbd    5.1.16 (HF10) - GEM:282 Remove test for ImageBackgroundMean < 1 
                        completely. SNR code already has protection against divide by 0.
     19-Nov-2009 rbd    5.1.17 (HF11, Scheduler) GEM:321 Make unguided dithering
                        independent of a previous slew.
     12-Feb-2010 rbd    5.1.17 (HF11) GEM:310, Honor config that turns pointing updates
                        on an off for the dumb autofocus logic.
     16-Feb-2010 rbd    5.1.17 (HF11) GEM:340, Don't shut down cooler if already shut
                        down.
     04-Apr-2010 rbd    5.1.18 (6.0) GEM:404, Kill guider and track offsets in AutoFocus()
                        for any reason, including refusals.
     29-Sep-2010 rbd    5.1.18 (6.0) GEM:426 correct error reporting for autocal failure.
     01-Oct-2010 rbd    5.1.18 (6.0) GEM:406 GEM:50 Readout mode controls, including
                        automatically choosing "fast" (if available) for pointing update
                        exposures. Change to require MaxIm 5 or later during init, 
                        other cosmetics.
     07-Oct-2010 rbd    5.1.18 (6.0) GEM:470 Honor Sensor Angle when guiding with AO/OAG.
     01-Nov-2010 rbd    6.0.1 (6.0) GEM:408 - Defocus option(per target)
     02-Nov-2010 rbd    6.0.1 (6.0) GEM:453 - Catch Pointing/FocusRef filter error, and bad 
                        filter numbers in FilterInfo.txt at startup.
     14-Nov-2010 rbd    6.0.1 (6.0) GEM:211 Replace E/W avoidance code with new code. 
                        GEM:486 Add logic for ExcludedBrightStars.txt
     15-Nov-2010 rbd    6.0.1 (6.0) GEM:97 Addproperty LastSolveFWHM for web. Increase
                        SNR of simulated images. GEM:262 expose guider exposure interval.
     17-Nov-2010 rbd    6.0.1 (6.0) GEM:490 produce guider trackbox and full size preview
                        images. Increase edge avoidance in guidestar select to 16 pix.
                        Assert that TakePicture() is never called with SavePNG = True.
                        This code appears to be unused. SetupGuider() changed signature.
     18-Nov-2010 rbd    6.0.1 (6.0) GEM:406 Set Normal readout mode in Terminate().
     19-Nov-2010 rbd    6.0.1 (6.0) GEM:261 Clean up web exposure progress timing
     27-Nov-2010 rbd    6.0.2 (6.0) GEM:514 Fix AutoGuide() for bad call to SetupGuider().
                        GEM:513 Inhibit guiding pointing exposures for internal/OAG.
                        GEM:516 Don't ignore PinPoint errors in image simulator. Let
                        'em fail and kill the script. 
     28-Nov-2010 rbd    6.0.2 (no GEM) Don't try to return camera readout mode to normal
                        if camera was shut down/disconnected. No GEM, log cat ID of found
                        bright star. GEM:519 Create LastAFTime.txt file for Scheduler.
     21-Dec-2010 rbd    6.0.2 (no GEM) Fix two naked Console.PrintLine() calls in
                        FindBrightStar(). Fix the 28-Nov readout mode change for timing 
                        problem.
     03-Jan-2010 rbd    6.0.3 (6.0) GEM:541 Fix thermometer calc for bias frames.
     05-Jan-2010 rbd    6.0.3 (6.0) GEM:546 Add commented patch for Steve Reilly
     14-Jan-2011 rbd    6.0.4 (6.0) GEM:560 DropBox compatibility.
     31-Jan-2011 rbd    6.0.4 (6.0) GEM:586 Add commented patch for Paul Burke's AO
                        -- 6.0 release --
     12-Mar-2011 rbd    6.0.5 (6.0HF1) GEM:211 again! In FindBrightStar() turn off the
                        catalog expansion and filter out stars that would cause a flip.
     19-Apr-2011 rbd    6.0.5 (6.0HF1) GEM:629 For ST-X guiding, rotate -90 degrees (this
                        is commented out for now, pending final fix).
     25-Apr-2011 rbd    6.0.5 (6.0HF1) GEM:631 Fix CalSlewTarget() for J2000 mode.
     05-May-2011 rbd    6.0.5 (6.0HF1) WaitGuiderMeasurement now both waits and
                        gets the measurement as well. No change to the logic, just a 
                        refactor for convenience.
     09-May-2011 rbd    6.0.5 (6.0HF1) GEM:639 Don't fail image if slew ahead fails.
                        GEM:573 Add support for RoModeInfo.txt, specifying the normal and
                        fast readout modes by name.
     17-May-2011 rbd    6.0.5 (6.0HF1) GEM:624 Autofocus in "fast" r/o mode if avail.
     09-Jun-2011 rbd    6.0.6 (6.0HF2) GEM:647 Fix FocusMax version detection code.
     25-Aug-2011 rbd    6.0.6 (6.0HF2) GEM:314 Move tracking graph support arrays and 
                        interface members here, now shared between AcquireImages and
                        AcquireScheduler (and must be JScript anyway).
     26-Aug-2011 rbd    6.0.6 (6.0HF2) GEM:494 Add construction of XY data for guiding
                        scatter plot.
     31-Aug-2011 rbd    6.0.6 (6.0HF2) If simulating, magnify guiding errors for looks.
     17-Sep-2011 rbd    6.0.6 (6.0HF2) GEM:611 Report true plate scales on solve (next 
                        to true FL) GEM:701 Presence of AoInfo.txt signals AO as well
                        as existing logic that looks for SBIG with AO. For SX AO.
                        GEM:704 change 'potentially hazardous' message. GEM:705 allow
                        input of sensor angle for internal guiders (ST-X).
     27-Oct-2011 rbd    6.0.7 (6.0HF3) GEM:728 Variable values for FindBrightStar, new
                        properties for same
     30-Mar-2012 rbd    7.0.1 (7.0) - GEM:826 No more Prefs.AutoGuiding.CycleTime. Replace 
                        AutoGuiding.ExternalGuider with new SensorType property. Replace
                        AO detection with new AutoGuiding.AdaptiveOptics property. GEM:830
                        No longer "always slew" for internal/OAG. 
     02-Apr-2012 rbd    7.0.1 (7.0) - GEM:826 change over to new ACP-internal Rotator
                        object and Util API additions. No more RotatorInfo file.
     19-Jun-2012 rbd    7.0.1 (7.0) - GEM:700 Remove logic for setting FocusMax exposure
                        and let it do so. 
     26-Jun-2012 rbd    7.0.1 (7.0) - GEM:567 Refactor the ExposureProgress logic to 
                        get rid of the kludgery.
     28-Jun-2012 rbd    7.0.1 (7.0) - GEM:80 FindBrightStar takes a filter parameter, 
                        FilterInfo.txt now has optional bright & faint focus star mags,
                        refactor calls to FBS. SetFilterForTask() now puts the mag range
                        into c_brightStarMinMag and c_brightStarMaxMag and makes them
                        accessible through their public properties.
     29-Jun-2012 rbd    7.0.1 (7.0) - GEM:80 Increase bright star search area to 15
                        deg. so brighter focus stars can reliably be found.
     04-Jul-2012 rbd    7.0.1 (7.0) - GEM:861 integrate all-sky platesolving into 
                        UpdatePointing().
     13-Jul-2012 rbd    7.0.1 (7.0) - GEM:716 Allow slow starting cameras (Apogee) to
                        begin warming before applying temp rate test.
     17-Jul-2012 rbd    7.0.1 (7.0) - GEM:640/90 Expose PointingBinning as property and
                        AllSkySolve() as method. Change interface to AllSkySOlve so it
                        returns ra/dec in c_lastSolve[ra|dec] and move the console out
                        tracing to the TakePointingImage. AllSkySolve now also used for 
                        guider solving.
     30-Jul-2012 rbd    7.0.1 (7.0) - GEM:690 add logic to dither in main imager pixels.
     26-Aug-2012 rbd    7.0.1 (7.0) - GEM:525 - Readouut mode control for flats. GEM:841
                        Test for offset tracking with tracking ON.
     28-Aug-2012 rbd    7.0.1 (7.0) - GEM:898 Add support for MPCCOMET (by J. Hanisch)
     12-Sep-2012 rbd    7.0.1 (7.0) - GEM:857 Config files may  now reside in old or new
                        UAC-friendly locations, via Util.GetConfigFilePath().
     18-Oct-2012 rbd    7.0.1 (7.0) - GEM:843 For manual rotation, pick up PA and send
                        to MaxIm for guiding.
     21-Oct-2012 rbd    7.0.1 (7.0) - In ACP 7 do not set Camera.LinkEnabled = false
                        then Util.CamerConnected = false. The latter disconnects anyway,
                        and it tries to pick up the filter names for caching just before.
     30-Oct-2012 rbd    7.0.1 (7.0) - Multiple small fixes to all-sky solving and re-sync
     26-Dec-2012 rbd    7.0.2 (7.0) - Disconnect rotator during Shutdown() if needed
     29-Dec-2012 rbd    7.0.2 (7.0) - Fix warming routine to restore original setpoint
                        at the right place in the code (Berg).
     03-Jan-2013 rbd    7.0.2 (7.0) - Fix get_PointingBinning() for stray PIXBIN_1 test.
     29-Jan-2013 rbd    7.0.2 (7.0) - Fix new thermometer calcs for bias frames. Catch 
                        bad drive spec when creating folders.
     05-Feb-2013 rbd    7.0.2 (7.0) - Fix dithering with -1 (auto).
     11-Mar-2013 rbd    7.0.3 (7.0) - Allow Initialize() to run with unsafe roof in closed
                        position. This is required for panel flats with the roof closed.
                        Too bad if the user wrecks his scope.
     24-Mar-2013 rbd    7.0.4 (7.0) - Several fixes to error handling in all-sky solving.
     06-May-2013 rbd    7.1.1 (7.1) - GEM:962 Support #readoutmode for darks
     13-Sep-2013 rbd    7.1.1 (7.1) - GEM:998 Beautify confirmation image
     08-Oct-2013 rbd    7.1.1 (7.1) - GEM:998 Add RemoveGradient() as step 3
     21-Oct-2013 rbd    7.1.1 (7.1) - GEM:1024 Fix Comet() function for name only
                        (MPCCOMET lookup). Also allow "D" comets when looking for elements.
                        Make MinorPlanet() and Comet() return False quietly if either the 
                        MPCORB or MPCCOMET component (respectively) are not isntalled, or
                        if the body is not found in its respective datasbase.
     29-Oct-2013 rbd    7.1.1 (7.1) - GEM:675 Persistent save of filter/focus changes 
                        to file, restore from file at initialization. 
     07-Nov-2013 rbd    7.1.1 (7.1) - GEM:1037 Write FOCALLEN to FITS on successful 
                        solve.
     01-Dec-2013 rbd    7.1.1 (7.1) - GEM:992 Switch all sky logic to use PinPoint 6.
                        Also correct all-sky pointing error logging for J2000 scopes.
     24-Jan-2014 rbd    7.1.1 (7.1) - GEM:1004 Use red magnitudes now. This Gemini is not
                        complete, though, due to PP6 filtering in the bogus Visual mags!
                        WIll complete this when GEM:1089 is done and PP6.1 is out.
     10-Feb-2014 rbd    7.1.2 (7.1a) - Fix initial creation of FilterState.txt file. 
     15-Feb-2014 rbd    7.1.3 (7.1c) - Focusers may have ticks over 32K, need CLng()
                        when reading in previous ticks.
     17-Feb-2014 rbd    7.1.4 (7.1d) - GEM:1106 AllSkySolve() always needs ".fts". 
                        GEM:992 Pick up the user's All Sky API Key if it has something 
                        in it and give that to PinPoint.
     19-Jun-2014 rbd    7.2.1 (7.2) - GEM:1138 add PlaneWave PWI Focus support (code
                        supplied by Kevin Ivarson of PW). 
     21-Jun-2014 rbd    7.2.1 (7.2) - GEM:1139 Accept 4-part version string as can come
                        from FocusMax 4.
     01-Jul-2014 rbd    7.2.1 (7.2) - GEM:1143 Remove old MaxIm version detection and 
                        45 degree AO rotation hack. Long gone.
     10-Jul-2014 rbd    7.2.1 (7.2) - GEM:1160 Start up FocusMax if needed during
                        Initialize() and release at Terminate(). 
     11-Jul-2014 rbd    7.2.1 (7.2) - GEM:1116 New InitializeUnsafeWeather() used for
                        panel/screen flats only.
     12-Jul-2014 rbd    7.2.1 (7.2) - GEM:1140 Util.IsGEMDestinationWest() needs Dec.
     23-Jul-2014 rbd    7.2.1 (7.2) - GEM:1119 Move filter/focus state to registry,
                        eliminating FilterState.txt and its problems.
     26-Jul-2014 rbd    7.2.1 (7.2) - GEM:675 Eliminate focus manipulations entirely. 
                        No GEM - Remove test for MaxIm 4.x or earlier. 
     05-Aug-2014 rbd    7.2.1 (7.2) - GEM:805 Refactor SetupGuider() to avoid star 
                        changes after first call, avoid saturated stars at the initial
                        guide interval, and also to avoid brighter neighbors by requiring
                        them to be at least 20 pixels away (more than half the trackbox).
     06-Aug-2014 rbd    7.2.1 (7.2) - GEM:838 Do not count pointing images' FWHM in stats.
                        Change function signature on SolvePlate() adding a UseFWHM param
                        at the end. Change calls for this refactoring.
     11-Aug-2014 rbd    7.2.1 (7.2) - GEM:1145 add JD-OBS (Julian date) to FITS.
     24-Aug-2014 rbd    7.2.1 (7.2) - GEM:1194 No more separate focus selection. All 
                        scripted focus changes go through AF program and AF must be
                        enabled.
     26-Aug-2014 rbd    7.2.2 (7.2) - GEM:1194 Oops, last minute accommodation for 
                        zero filter offsets used uninitialized c_haveAF.
     26-Aug-2014 rbd    7.2.3 (7.2) - GEM:1194 Fix this again damn it!
     27-Aug-2014 rbd    7.2.4 (7.2) - GEM:805 Fix loop termination in SetupGuider().
                        If StarOK ever goes false it will loop through the rest of the
                        stars then fail.
     28-Aug-2014 rbd    7.2.4 (7.2) - GEM:805 Go back to Aperture detection of stars,
                        use fixed apertures, and wait for FindImageStars(). Essential
                        for proper scaling of SNR with exposure. Remove hot pixels from
                        guider image before scanning for stars.
     29-Aug-2014 rbd    7.2.5 (7.2) - GEM:805 Fix trace statements for overflow on very
                        bright stars (CInt -> CLng). Additional guider tracing.
     17-Nov-2014 rbd    7.3.1 (7.3) - GEM:1253 Remove old "cal folder" method for loading
                        up the MaxIm cal wizard. Rely on setup by customer.
     16-Jan-2015 rbd    7.3.1 (7.3) - GEM:1278 Skip GuiderSelectStar call if Multi-Star 
                        guiding is in effect.
     10-Mar-2015 rbd    8.0.1 (8.0) - GEM:1172 Add FITS fields for weather. Requires new
                        ACP 7.3 -> 8.0 API interface.
     14-Mar-2015 rbd    8.0.1 (8.0) - GEM:1172 More FITS fields, fix ST to be for the 
                        exposure start time.
     21-Mar-2015 rbd    8.0.1 (8.0) - GEM:1278 Not so simple for Multi-Star, need to 
                        capture MaxIm-Selected star and let it be used as the selected
                        star for iterative refinement. GEM:1218 Correct logged guider 
                        configuration strings to match new names in UI.
     22-Mar-2015 rbd    8.0.1 (8.0) - GEM:675 (again!) unconditionally set the last used
                        filter in MaxIm during initialization. Do not believe MaxIm's 
                        reported filter selection.
     23-Mar-2015 rbd    8.0.1 (8.0) - GEM:1206 Total overhaul of image acquisition and
                        downloading sync code. Use CameraStatus from MaxIm and simplify 
                        the logic while making it much more accurate (RBI, setup, auto-
                        dark, download not counted for thermometer, etc.).
     31-Mar-2015 rbd    8.0.1 (8.0) - GEM:1325 clarifying comments about making sure
                        leftover rate offsets are killed at initiaization. No changes
                        to logic.
     10-Apr-2015 rbd    8.0.1 (8.0) - GEM:1206 turn tracing off, but leave the Trace
                        statements for this in place, live, for possible beta issues.
     28-Apr-2015 rbd    8.0.2 (8.0) - GEM:1206, oops div by zero for bias frames.
     18-May-2015 rbd    8.0.2 (8.0) - GEM:626 Implement new ReverseYonFlip feature, 
                        smooth out the guiding logic (conventional and AO) GEM:1350
                        Move "looking east" check into CalibrateGuider, force reversal
                        switches false, write resulting guider angle back to ACP using
                        new Property Write SensorAngle. GEM:1346 remove warning about
                        unsafe weather and make InitializeUnsafeWeather() silent about
                        that.
     23-Jun-2015        8.0.3 (8.0) -  GEM:1355 Add logic for dynamic guider trackbox 
                        display ... New properties MaxImDocuments and MultistarGuiding
     09-Jul-2015        8.0.4 (8.0a) - GEM:626 AO flip logic with new switch was quite
                        flawed. Ugh.
     10-Jul-2015        8.0.4 (8.0a) - GEM:626 Correct the above fix for removal of ai/ao
                        variables used in ancient MaxIm bump angle hack.
     21-Aug-2015        8.0.5 (8.0.1) - GEM:1362 Close the work file window after saving
                        GEM:1369 Refactor SetupGuider() to avoid use of Camera.GuiderArray
     24-Aug-2015        8.0.6 (8.0.1) - GEM:1362 Damn, used a PlateStar reference after 
                        releasing the PinPoint Plate. ACP Crashed. Fix this in SetupGuider().
     01-Sep-2015        8.0.7 (8.0.1) - GEM:1373 Program around another MaxIm problem, this 
                        time MaxIm.Document being unstable aftr calling its SaveFile()
                        method. Close/reopen.
     24-Sep-2015        8.0.7 (8.0.1) - GEM:1362 Back out the change of 21-Aug closing work 
                        file window.
     20-Oct-2015        8.0.7 (8.0.1) - GEM:1392 Refactor guide exposure refinement, and make 
                        logging of the process more understandable. Turn tracing off and
                        comment out the Trace statements.
     22-Oct-2015        8.0.7 (8.0.1) - GEM:1394 Avoid calling PinPoint.SolveAllSky on 
                        images with fewer than 4 stars. Avoid ugly A.N error.
     28-Oct-2015        8.0.7 (8.0.1) - GEM:1362 Put close back in for pointing exposures.
     04-Dec-2015        8.0.7 (8.0.1) - GEM:1412 Avoid long lookups in FindBrightStar for
                        unusual horizon shapes (many raised exceptions). 
     02-Feb-2016        8.0.8 (8.0.2) - No GEM. Remove dead SavePNG code from TakePicture,
                        leaving only the warning log message.
     11-Mar-2016        8.0.8 (8.0.2) - GEM:1362 Do not close all windows at Terminate. 
     30-May-2016        8.1.0 (8.1) - GEM:1468 Fix readout modes for case of no filters
     12-Jun-2016        8.1.0 (8.1) - GEM:1473 Correct statement that logs star mag range 
                        for AcquireStar.
     08-Jul-2016        8.1.0 (8.1) - GEM:805 Redux - Use least-flux saturated star if
                        we're left with no other choice, rather than fail guiding.
     14-Jul-2016        8.1.0 (8.1) - GEM:1432 Allow use of local 'ansvr' for all-sky 
                        plate solving. 
     31-Jul-2016        8.1.0 (8.1) - GEM:1439 Increase guiding exclusion zone to 24 pix
                        to avoid dithering + noise driving it off the sensor. 
     06-Aug-2016        8.1.0 (8.1) - GEM:1369 - REVERSE this. Go back to GuiderArray. Was
                        an ugly threading bug in MaxIm that forced the hard way. The hack
                        was causing other weird side effects in MaxIm too. This enables
                        GEM:1355 dynamic trackbox display in the web UI. GEM:1444 new 
                        preferences replaces AUTOCAL_SAVE_RAW.
     07-Aug-2016        8.1.0 (8.1) - GEM:85(!) Add HJD_OBS, BJD_OBS
     09-Aug-2016        8.1.0 (8.1) - GEM:85 expose HJD() function 
     11-Aug-2016        8.1.0 (8.1) - GEM:1189 Don't call SlewEnd action unless really
                        stopped slewing. GEM:1409 Fix object centering above 70 deg
                        dec when sync is skipped.
     12-Aug-2016        8.1.0 (8.1) - GEM:903 put raw/uncalibrated files into RAW subfolder.
     29-Sep-2016        8.1.1 (8.1a) - GEM:1507 Simplify initialization of tracking rates
                        to avoid delay at startup. 
     30-Dec-2016        8.1.2 (8.1b) - GEM:1521 Fix web guiding graph on European systems.
     12-Jul-2017        8.2.1 (8.2) - GEM:1546 Prevent Index Out of Range in MaxIm by skipping
                        unnecessary guider trackbox preview image when multi-star guiding.
     19-Oct-2017        8.2.2 (8.2) - GEM:1559 Fix code which falls back to "least flux
                        saturated star" in SetupGuider. Missing "Set" keyword in assignment.
     05-Jan-2018        8.2.3 (8.2) - GEM:1570 Detect faded star during SetupGuider.
     27-Mar-2018        8.2.4 (8.2) - GEM:1172 (reeopened) fix FITS info for server name
                        and humidity, add one decimal digit to temperatures. GEM:1584 do
                        not divide image download sanity timer by 10 for image simulation.
     05-May-2018        8.2.5 (8.2) - GEM:1592 Fix tilt-up check in FindBrightStar() for
                        ACP Alt/Az mount configuration.
     12-Jun-2018        8.2.6 (8.2) - GEM 1598 Fix calculation of RA/Dec rates in NEOCP 
                        ephemerides. 
     22-Jul-2018        8.2.7 (8.2) - GEM:408 (redux) Optimize defocus to minimize focuser
                        moves. Make defocus a persistent variable here. 
     25-Jul-2018        8.2.7 (8.2) - no GEM Typo in "Solving with" message
     30-Aug-2018        8.2.7 (8.2) - no GEM - Fix MinorPlanetOb and CometOb for name 
                        number or desig of objects (Name parameter).
     30-Sep-2018        8.2.7 (8.2) - GEM:1564 Speed up preview by beautifying after resize
     04-Nov-2018        8.2.8 (8.2) - GEM:1596 - Reject guide stars less than MIN_GUIDE_STAR_AREA
                        (left this a parameter just in case!!).
     04-Nov-2018        8.2.8 (8.2) - GEM:1590 - Remove trailing commas from FilterInfo
     11-Nov-2018        8.2.8 (8.2) - GEM:1589 - Double size of guider trackbox for display
                        on new <canvas> element in the web system status. Now 64 x 64.
     10-Dec-2018        8.2.9 (8.2) - GEM:1655 - Increase AO filter switch time to 30 sec.
     22-Jan-2019        8.2.10 (8.2) - GEM;1596 Oops caught a naked Console.PrintLine()
                        in SetupGuider(). Add shortcut Console to Util.Console then make
                        all calls to Console.
-----------------------------------------------------------------------------------------
]]>
	</comment>
	<component id="AcquireSupport">
		<?component error="false" debug="false" ?>
		<registration progid="ACP.AcquireSupport" classid="{1251EB97-811C-4F6B-8F16-48368FF19763}" description="ACP image acquisition common methods" remotable="no" version="1.00">
		</registration>
		<public>
			<method name="Initialize">
			</method>
			<method name="InitializeUnsafeWeather">
			</method>
			<method name="Terminate">
			</method>
			<property name="AutoflatReadoutMode">
				<get/>
			</property>
			<property name="AutoFocusActive">
				<get/>
				<put/>
			</property>
			<property name="AGErrorListX">
				<get/>
			</property>
			<property name="AGErrorListY">
				<get/>
			</property>
			<property name="AGErrorListXY">
				<get/>
			</property>
			<property name="BrightStarMinMag">
				<get/>
				<put/>
			</property>
			<property name="BrightStarMaxMag">
				<get/>
				<put/>
			</property>
			<property name="BrightStarSearchDeg">
				<get/>
				<put/>
			</property>
			<property name="Calibrating">
				<get/>
			</property>
			<property name="CrosshatchAvoidance">
				<get/>
			</property>
			<property name="DefocusCount">
				<get/>
				<put/>
			</property>
			<property name="DoingOffsetTracking">
				<get/>
			</property>
			<property name="EquOffsetDec">
				<get/>
			</property>
			<property name="EquOffsetRA">
				<get/>
			</property>
			<property name="ExposureActive">
				<get/>
				<put/>
			</property>
			<property name="ExposureInterval">
				<get/>
			</property>
			<property name="ExposureProgress">
				<get/>
			</property>
			<property name="ExternalGuider">
				<get/>
			</property>
			<property name="FieldOfViewH">
				<get/>
			</property>
			<property name="FieldOfViewV">
				<get/>
			</property>
			<property name="FieldOfViewMin">
				<get/>
			</property>
			<property name="GuiderInterval">
				<get/>
			</property>
			<property name="GuiderRunning">
				<get/>
			</property>
			<property name="Guiding">
				<get/>
			</property>
			<property name="HaveAO">
				<get/>
			</property>
			<property name="HaveFilterInfo">
				<get/>
			</property>
			<property name="HaveFilters">
				<get/>
			</property>
			<property name="HavePinPoint4">
				<get/>
			</property>
			<property name="HaveReadoutModes">
				<get/>
			</property>
			<property name="HaveRotator">
				<get/>
			</property>
			<property name="HaveTrackOffset">
				<get/>
			</property>
			<property name="J2000Dec">
				<get/>
			</property>
			<property name="J2000RA">
				<get/>
			</property>
			<property name="LastAverageFWHM">
				<get/>
			</property>
			<property name="LastFocusFWHM">
				<get/>
			</property>
			<property name="LastFocusPosition">
				<get/>
			</property>
			<property name="LastSolveDecJ2000">
				<get/>
			</property>
			<property name="LastSolveFWHM">
				<get/>
			</property>
			<property name="LastSolvePosErr">
				<get/>
			</property>
			<property name="LastSolveRAJ2000">
				<get/>
			</property>
			<property name="LastSolvePA">
				<get/>
			</property>
			<property name="LastSolveScaleH">
				<get/>
			</property>
			<property name="LastSolveScaleV">
				<get/>
			</property>
			<property name="LastSyncDecJ2000">
				<get/>
			</property>
			<property name="LastSyncRAJ2000">
				<get/>
			</property>
			<property name="LocalTopoDec">
				<get/>
			</property>
			<property name="LocalTopoRA">
				<get/>
			</property>
			<property name="MaxAutofocusTime">
				<get/>
			</property>
			<property name="MaxImDocuments">
				<get/>
			</property>
			<property name="MultistarGuiding">
				<get/>
			</property>
			<property name="PlateScaleH">
				<get/>
			</property>
			<property name="PlateScaleV">
				<get/>
			</property>
			<property name="PointingBinning">
				<get/>
			</property>
			<property name="PreviewReady">
				<get/>
			</property>
			<property name="ReadoutMode">
				<get/>
				<put/>
			</property>
			<property name="RotatorMoving">
				<get/>
			</property>
			<property name="RotatorPositionAngle">
				<get/>
			</property>
			<property name="ScopeNeedsLocalTopo">
				<get/>
				<put/>
			</property>
			<property name="SimImageDec">
				<get/>
			</property>
			<property name="SimImageRA">
				<get/>
			</property>
			<property name="SimImageTimeCompress">
				<get/>
				<put/>
			</property>
			<property name="SimPosError">
				<get/>
				<put/>
			</property>
			<property name="SlewDistance">
				<get/>
			</property>
			<property name="SlewProgress">
				<get/>
			</property>
			<property name="SolveFails">
				<get/>
				<put/>
			</property>
			<property name="UserActions">
				<get/>
			</property>
			<method name="AirMass">
				<parameter name="ra"/>
				<parameter name="dec"/>
			</method>
			<method name="AllSkySolve">
				<parameter name="imageFile"/>
			</method>
			<method name="Atan4Q">
				<parameter name="y"/>
				<parameter name="x"/>
			</method>
			<method name="AutoFocus">
				<parameter name="RightAscension"/>
				<parameter name="Declination"/>
			</method>
			<method name="AutoGuide">
				<parameter name="State"/>
			</method>
			<method name="CalcEphemeris">
				<parameter name="Source"/>
				<parameter name="Name"/>
				<parameter name="RightAscension"/>
				<parameter name="Declination"/>
				<parameter name="RightAscensionRate"/>
				<parameter name="DeclinationRate"/>
			</method>
			<method name="CalcSimImageCoordinates">
				<parameter name="RightAscension"/>
				<parameter name="Declination"/>
			</method>
			<method name="CalibrateGuider">
				<parameter name="RightAscension"/>
				<parameter name="Declination"/>
			</method>
			<method name="CaptureAGErrors">
				<parameter name="MaxTrkPoints"/>
			</method>
			<method name="ClearAGHistory">
			</method>
			<method name="Comet">
				<parameter name="Elements"/>
				<parameter name="Name"/>
				<parameter name="RightAscension"/>
				<parameter name="Declination"/>
				<parameter name="RightAscensionRate"/>
				<parameter name="DeclinationRate"/>
			</method>
			<method name="CometOb">
				<parameter name="O"/>
			</method>
			<method name="CreateFolder">
				<parameter name="Path"/>
				<parameter name="Web"/>
			</method>
			<method name="DateToJulian">
				<parameter name="Year"/>
				<parameter name="Month"/>
				<parameter name="Day"/>
			</method>
			<method name="DecodeFilter">
				<parameter name="FilterName"/>
			</method>
			<method name="DecodeReadoutMode">
				<parameter name="ReadoutModeName"/>
			</method>
			<method name="DeepSky">
				<parameter name="Name"/>
				<parameter name="RightAscension"/>
				<parameter name="Declination"/>
			</method>
			<method name="EquDist">
				<parameter name="ra1"/>
				<parameter name="dec1"/>
				<parameter name="ra2"/>
				<parameter name="dec2"/>
			</method>
			<method name="EquDist2">
				<parameter name="ra1"/>
				<parameter name="dec1"/>
				<parameter name="ra2"/>
				<parameter name="dec2"/>
			</method>
			<method name="EquOffset">
				<parameter name="ra"/>
				<parameter name="dec"/>
				<parameter name="ora"/>
				<parameter name="odec"/>
			</method>
			<method name="FilterExists">
				<parameter name="FilterName"/>
			</method>
			<method name="FilterName">
				<parameter name="FilterNumber"/>
			</method>
			<method name="FindBrightStar">
				<parameter name="RightAscension"/>
				<parameter name="Declination"/>
				<parameter name="FilterNumber"/>
				<parameter name="raStar"/>
				<parameter name="decStar"/>
				<parameter name="magStar"/>
			</method>
			<method name="GaussRand">
				<parameter name="sigma"/>
			</method>
			<method name="GetNextLiveLine">
				<parameter name="Strm"/>
				<parameter name="EchoComments"/>
			</method>
			<method name="HJD">
				<parameter name="JulianDate"/>
				<parameter name="RightAscension"/>
				<parameter name="Declination"/>
				<parameter name="Barycentric"/>
			</method>
			<method name="HourAngle0to24">
				<parameter name="ra"/>
			</method>
			<method name="J2000ToLocalTopocentric">
				<parameter name="RightAscension"/>
				<parameter name="Declination"/>
			</method>
			<method name="LocalTopocentricToJ2000">
				<parameter name="RightAscension"/>
				<parameter name="Declination"/>
			</method>
			<method name="JournalForRSS">
				<parameter name="Title"/>
				<parameter name="Message"/>
			</method>
			<method name="LSTRise">
				<parameter name="RA"/>
				<parameter name="Dec"/>
				<parameter name="ZD"/>
			</method>
			<method name="MajorPlanet">
				<parameter name="Name"/>
				<parameter name="RightAscension"/>
				<parameter name="Declination"/>
				<parameter name="RightAscensionRate"/>
				<parameter name="DeclinationRate"/>
			</method>
			<method name="MajorPlanetOb">
				<parameter name="O"/>
			</method>
			<method name="MakeFileName">
				<parameter name="TargetName"/>
			</method>
			<method name="MinorPlanet">
				<parameter name="Elements"/>
				<parameter name="Name"/>
				<parameter name="RightAscension"/>
				<parameter name="Declination"/>
				<parameter name="RightAscensionRate"/>
				<parameter name="DeclinationRate"/>
			</method>
			<method name="MinorPlanetOb">
				<parameter name="O"/>
			</method>
			<method name="NEOEph">
				<parameter name="Ephemeris"/>
				<parameter name="RightAscension"/>
				<parameter name="Declination"/>
				<parameter name="RightAscensionRate"/>
				<parameter name="DeclinationRate"/>
			</method>
			<method name="NeoEphOb">
				<parameter name="O"/>
			</method>
			<method name="NevilleVB">
				<parameter name="xav"/>
				<parameter name="yav"/>
				<parameter name="n"/>
				<parameter name="x"/>
			</method>
			<method name="NevilleJS">
				<parameter name="xa"/>
				<parameter name="ya"/>
				<parameter name="n"/>
				<parameter name="x"/>
			</method>
			<method name="PackedToJulian">
				<parameter name="Packed"/>
			</method>
			<method name="PlaneWaveAutoFocus">
				<parameter name="af"/>
			</method>
			<method name="PlateToPA">
				<parameter name="Plate"/>
			</method>
			<method name="PositionAngle">
				<parameter name="ra1"/>
				<parameter name="dec1"/>
				<parameter name="ra2"/>
				<parameter name="dec2"/>
			</method>
			<method name="ReadoutModeExists">
				<parameter name="ReadoutModeName"/>
			</method>
			<method name="ReadoutModeName">
				<parameter name="ReadoutModeNumber"/>
			</method>
			<method name="RecenterTarget">
				<parameter name="TargetName"/>
				<parameter name="RightAscension"/>
				<parameter name="Declination"/>
			</method>
			<method name="SelectFilter">
				<parameter name="FilterNumber"/>
			</method>
			<method name="SetFilterForTask">
				<parameter name="Task"/>
			</method>
			<method name="SetTrackOffset">
				<parameter name="RightAscensionRate"/>
				<parameter name="DeclinationRate"/>
			</method>
			<method name="SolvePlate">
				<parameter name="File"/>
				<parameter name="RA"/>
				<parameter name="Dec"/>
				<parameter name="PA"/>
				<parameter name="ScaleH"/>
				<parameter name="ScaleV"/>
				<parameter name="MinBrt"/>
				<parameter name="Sigma"/>
				<parameter name="SolveMax"/>
				<parameter name="CatMax"/>
				<parameter name="TimeMax"/>
				<parameter name="UpdCorr"/>
				<parameter name="UpdFWHM"/>
			</method>
			<method name="SphDist">
				<parameter name="lon1"/>
				<parameter name="lat1"/>
				<parameter name="lon2"/>
				<parameter name="lat2"/>
			</method>
			<method name="Shutdown">
			</method>
			<method name="StartRotateToPA">
				<parameter name="PA"/>
				<parameter name="RA"/>
			</method>
			<method name="StartSlewJ2000">
				<parameter name="TargetName"/>
				<parameter name="RightAscension"/>
				<parameter name="Declination"/>
			</method>
			<method name="SyncToJ2000">
				<parameter name="RightAscension"/>
				<parameter name="Declination"/>
			</method>
			<method name="TakePicture">
				<parameter name="Interval"/>
				<parameter name="Binning"/>
				<parameter name="Subframe"/>
				<parameter name="Dither"/>
				<parameter name="FilterNum"/>
				<parameter name="FinalFile"/>
				<parameter name="ConfirmationFile"/>
				<parameter name="ForPointing"/>
				<parameter name="ForceCal"/>
				<parameter name="Compress"/>
				<parameter name="SaveJPEG"/>
				<parameter name="ObserverName"/>
				<parameter name="TargetName"/>
				<parameter name="TargetRA"/>
				<parameter name="TargetDec"/>
				<parameter name="SlewNext"/>
				<parameter name="NextMPSource"/>
				<parameter name="NextName"/>
				<parameter name="NextRA"/>
				<parameter name="NextDec"/>
				<parameter name="RotNext"/>
				<parameter name="NextPA"/>
			</method>
			<method name="TakePointingImage">
				<parameter name="TargetName"/>
				<parameter name="FileName"/>
				<parameter name="RightAscension"/>
				<parameter name="Declination"/>
				<parameter name="PositionAngle"/>
			</method>
			<method name="UpdatePointing">
				<parameter name="TargetName"/>
				<parameter name="RightAscension"/>
				<parameter name="Declination"/>
				<parameter name="PositionAngle"/>
			</method>
			<method name="UnifRand">
				<parameter name="HiLimit"/>
			</method>
			<method name="WaitForRotator">
			</method>
			<method name="WaitForSlew">
			</method>
			<method name="XYDist">
				<parameter name="x1"/>
				<parameter name="y1"/>
				<parameter name="x2"/>
				<parameter name="y2"/>
			</method>
			<method name="ZDFromAirMass">
				<parameter name="Airmass"/>
			</method>
			<method name="ZenithDist">
				<parameter name="ra"/>
				<parameter name="dec"/>
			</method>
			<method name="ZenithDist2">
				<parameter name="ra"/>
				<parameter name="dec"/>
			</method>
		</public>
		<object id="RX" progid="VBScript.RegExp" events="false" reference="false"/>
		<object id="Voice" progid="ACP.Voice" events="false" reference="true"/>
		<object id="GEN" progid="ACP.PointingErrorGenerator" events="false" reference="true"/>
		<object id="ACPApp" progid="ACP.Application" events="false" reference="true"/>
		<object id="FSO" progid="Scripting.FileSystemObject" events="false" reference="true"/>
		<object id="MaxIm" progid="MaxIm.Application" events="false" reference="true"/>
		<object id="Util" progid="ACP.Util" events="false" reference="false"/>
		<script id="AcquireSupport" language="VBScript">
<![CDATA[
'
' WARNING: DO NOT MAKE COPIES OF OBJECT HANDLES SUCH AS Util.Script IN GLOBALS!
'          IF YOU DO, OBJECT UNWINDING WILL LEAVE REFERENCES TO THE PARENT
'          OBJECT, AND YOU WILL END UP WITH A MAJOR OBJECT LEAK AND AN ACP 
'          THAT WON'T SHUT DOWN!

Option Explicit
'
' Set to True if you have a one-shot color camera. If True, will avoid cross-hatching
' when scaling thumbnail and preview PNG images.
'
Const CROSSHATCH_SCALING = False

Const LIBVERSION = "8.2.10"         ' Version tracing
Const TRACE_ENABLE = False          ' BOB ONLY - MOST TRACE COMMENTED OUT WITH ''-
Const MECH_ERRORS_ALWAYS = False    ' BOB ONLY - True for simulated mechanical errors even with corrector off
Const SIDRATE = 0.9972695677        ' UTC/clock seconds per sidereal second
Const MXAFAVG = 3                   ' Last 4 FWHM's used for running FWHM average
Const MXAFTIME = 600                ' Kill FocusMax if it runs longer than 10 min (600 sec)
Const ROMODEINFNAME = "RoModeInfo.txt"          ' Readout mode info file name
Const FILTINFNAME = "FilterInfo.txt"            ' Filter info file name
Const BADSTARSNAME = "BadBrightStars.txt"       ' Bad bright stars file name
Const LASTAFNAME = "LastAFTime.txt"             ' Last successful AF time file name
Const GUIDEPRVTBOXNAME = "guidePreviewTBox.png" ' Guider trackbox preview file name
Const GUIDEPRVNAME = "guidePreviewFull.png"     ' Guider full preview image name
Const GUIDERPRVDIMSNAME = "guidePreviewDims.txt" ' Guider full preview dimensions file

'
' Following tables used for converting to and from packed designations
'
Const PCODE = "123456789ABCDEFGHIJKLMNOPQRSTUV"
Const YCODE = "IJK"
'
' Task codes for SetFilterForTask()
'
Const FO_FORIMAGE = 1
Const FO_FORFOCUS = 2
Const FO_FORPOINTING = 3
'
' Other constant parameters
'
Const OFFSET_TRIES = 2              ' Offset steps while plate solving
Const PIXBIN_6 = 0.67               ' Pix-scale thresholds for pointing update binning levels
Const PIXBIN_5 = 0.8                ' Target is 4"/pix
Const PIXBIN_4 = 1.0
Const PIXBIN_3 = 1.34
Const PIXBIN_2 = 2.0
Const AUTO_GUIDED_DITHER = 1.0      ' Guided dither, +/- 1 guider pixel (uniform random)
Const AUTO_UNGUIDED_DITHER = 5.0    ' Unguided dither, +/- 5 main imager pixels (uniform random)
Const MIN_GUIDE_STAR_AREA = 45      ' Guide star must be >= 45 square pixels

'
' Component internal variables
'
Dim c_solveFails, c_guiding, c_haveFilters, c_haveFilterInfo
Dim c_haveTrackOffset, c_trackOffset
Dim c_filterNames                                               ' Array of filter namers
Dim c_haveReadoutModes	                                        ' True if camera has readout mode control
Dim c_readoutModes                                              ' Array of readout mode names
Dim c_normalReadoutMode                                         ' Normal readout mode (numeric)
Dim c_fastReadoutMode	                                        ' Fast Readout Mode (numeric) or normal if fast not supported
Dim c_flatReadoutMode	                                        ' Autoflat Readout Mode (numeric) or normal if not supported
Dim c_ScaleH, c_ScaleV                                          ' Plate scales, "/pix
Dim c_FovH, c_FovV, c_FovMin                                    ' Field Of View info
Dim c_lastSyncRA, c_lastSyncDec                                 ' Last synced coordinates
Dim c_lastSolveRA, c_lastSolveDec                               ' Last plate-solved center coordinates
Dim c_lastSolvePosErr, c_LastSolveScaleH, c_LastSolveScaleV     ' Last plate-solve error and plate scales
Dim c_lastSolvePA                                               ' Last solve position angle
Dim c_needLocalTopo                                             ' True means convert to local topo for scope
Dim c_domeHazardous                                             ' True means dome/roof and not safe to slew if closed

Dim c_simPosErrRMS                                              ' RMS position error in image simulator
Dim c_simImagePA                                                ' Simulated image POSITION angle (not PinPoint RollAngle!)
Dim c_simImagePAOffset                                          ' Offset/error to crank into simulated image PA
Dim c_simImageRA, c_simImageDec                                 ' Image simulator position with errors
Dim c_simImageTimeCompress                                      ' Compress imaging time 10:1 when simulating

Dim c_localTopoRA, c_localTopoDec                               ' Results of J2000ToLocalTopocentric()
Dim c_J2000RA, c_J2000Dec                                       ' Results of LocalTopocentricToJ2000()

Dim c_searchH, c_searchV                                        ' Spiral search normalized offsets
Dim c_exposureActive                                            ' For UI annunciators and exposure 
Dim c_exposureInterval, c_exposureProgress, c_exposureRemain    '    progbars on web pages
Dim c_slewStartRA, c_slewStartDec, c_slewDist                   ' For slew progbars on web pages
Dim c_previewReady                                              ' For web pages preview
Dim c_previewPath                                               ' Path where (common) preview images go

Dim c_haveAF, c_FMx, c_usePWI
Dim c_afActive, c_calActive                                     ' For UI annunciator
Dim c_lastFWHM(), c_lastFWHMNum, c_lastSolveFWHM, c_lastAvgFWHM, c_lastFocusFWHM     ' Adaptive autofocus tracking
Dim c_lastFocusPosition                                         ' Position (counter) of last focus

Dim c_allowUnsafeWeather                                        ' If true allow initialization in unsafe weather (panel flats)
Dim c_userActions                                               ' User actions component object
Dim c_brightStarMinMag                                          ' FindBrightStar parameters for no FilterInfo
Dim c_brightStarMaxMag                                          ' (defaulted in Initialize())
Dim c_brightStarSearchDeg
Dim c_filterOffset()                                            ' Offset for each Filter
Dim c_focusFilter()                                             ' Reference filter for above offset (use this filter for focusing)
Dim c_pointingFilter()                                          ' Filter to use for pointing exposures
Dim c_filterBrightMag()                                         ' Brightest mag of focus star for each filter
Dim c_filterFaintMag()                                          ' Faintest mag of focus star for each filter
Dim c_selectedFilter	                                        ' Currently selected IMAGING filter
Dim c_curReadoutMode	                                        ' Currently selected IMAGING readout mode

Dim c_haveRotator                                               ' True if we have a running rotator
Dim ROT                                                         ' The rotator controller object

Dim c_guideStarX, c_guideStarY                                  ' Guide star position picked by MaxIm
Dim c_guideExpMin, c_guideExpMax, c_guideExpCur                 ' Minimum and maximum  & current guider exposure intervals
Dim c_guideErrMax                                               ' Max guider tracking error, pixels
Dim c_guideSNRMin                                               ' Minimum guiding signal-to-noise ratio
Dim c_guideDecComp                                              ' Controls whether guider dec comp is used
Dim c_guideSensorType                                           ' 0=ext, 1=int, 2=OAG (ACP API)
Dim c_guideSensorAngle	                                        ' Rotation angle of int/OAG sensor
Dim c_guideExtern                                               ' Indicates an external guider (no filters)
Dim c_haveAOx                                                   ' For AO-x sensing
Dim c_multiStarGuiding	                                        ' If Multi-Star guiding in effect (MaxIm V6 & later)

' ==============
' INITIALIZATION
' ==============
'
' Component initialization has been moved into a separate method 
' instead of being coded into the global scope of the script. The
' reason for this is to allow errors to come back to the caller.
' Errors at component creation time (global script) do not come back
' from the call to CreateObject(). You get a "script interrupted 
' before completion" error instead (this assumes that <?component
' error=false debug=false ?> above.
'
' Further, the two public initialization methods allow starting with
' or without weather unsafe condition being allowed. It is up to any
' script calling InitializeUnsafeWeather() top check later if it needs
' to. This is used for autoflat and panel flats, and acquireimages
' so it can compile and check the plan for dark/bias only and allow
' those during unsafe weather.
'
Sub Initialize()
    c_allowUnsafeWeather = False
    InitializeCommon
End Sub

Sub InitializeUnsafeWeather()
    c_allowUnsafeWeather = True
    InitializeCommon
End Sub

Sub InitializeCommon()
    Dim x, y, z, i, buf, Camera, Telescope, Prefs, FmxOk
    Dim fsfName, fsfStream, prevFilt, prevFocus, prevFiltFocusTime, curLoc, bits

    Util.Abortable = True           ' Mark this Util as script-abortable
    Util.Console.PrintLine "Initializing AcquireSupport V" & LIBVERSION
    Set Prefs = Util.Prefs
    
    c_previewPath =  Util.Prefs.WebRoot & "\images"

    On Error Resume Next
    FSO.DeleteFile c_previewPath & "\" & GUIDEPRVTBOXNAME       ' Hide guider image stuff from web
    On Error GoTo 0

    If Not c_allowUnsafeWeather Then                            ' Skipped for panel/screen flats (typ.)
        '
        ' Assure that weather is safe.
        '
        If Util.Weather.Available Then                          ' No short-circuit booleans
            If Not Util.Weather.Safe Then                       ' Huh? Bail out!
                Err.Raise vbObjectError, "ACP.AcquireSupport", _
                    "**The weather is unsafe. Cannot continue."
            Else
                Util.Console.PrintLine "Weather safe, server is " & Util.Weather.Name
            End If
        End If
    End If
    '
    ' Do the ScriptStart User Action here.
    '
    On Error Resume Next
    Set c_userActions = CreateObject("ACP.UserActions")         ' Try for user action component
    If Err.Number = 0 Then                                      ' If we have it
        On Error Goto 0                                         ' Back to error trapping
        Util.Console.PrintLine "User actions detected."
        If Not c_userActions.ScriptStart() Then
            Err.Raise vbObjectError, "User Actions", _
                    "**User action ScriptStart() returned False"
        End If
    Else
        On Error Goto 0                                         ' Back to error trapping
        Set c_userActions = Nothing                             ' No user actions
    End If

    
    Set Telescope = Util.ScriptTelescope
    On Error Resume Next
    buf = ", driver V" & Telescope.InterfaceVersion             ' Try for driver version
    If Err.Number <> 0 Then buf = ""
    On Error GoTo 0
    Util.Console.PrintLine "Telescope is " & Telescope.Name & buf
    If Util.Dome.Available Then 
        Util.Console.PrintLine "Dome is " & Util.Dome.Name
        If Util.Dome.Available And Util.Dome.CanSetShutter And Not Util.Dome.ScopeClearsClosedDome Then
            c_domeHazardous = True
            Util.Console.PrintLine " and must not close unless scope is parked"
        Else
            c_domeHazardous = False
        End If
    End If
    '
    ' If scope supports unparking, then unpark it. 
    '
    If Telescope.CanUnpark Then
        Telescope.Unpark
    End If
    '
    ' Twig MaxIm to prevent problems when a script is aborted during an exposure.
    ' This seems to leave AutoDownload in a weird state where ReadyForDownload 
    ' goes True but the image never downloads. Validate that MaxIm 4.60 is installed.
    '
    Set Camera = Util.ScriptCamera
    Camera.LinkEnabled = True                                   ' Make sure camera is connected (harmless if already)
    Err.Clear
    Camera.AbortExposure                                        ' Abort leftovers in progress
    If Prefs.DisableSlewOverlap Then                            ' If user wants sequential download/slew
        Camera.AutoDownload = True                              ' Turn on Auto-Download
    Else
        If Not Camera.AutoDownload Then                         ' If already in manual download
            Camera.StartDownload                                ' This clears the flag from prev. aborted image
            Util.WaitForMilliseconds 500                        ' Give it a chance to do whatever
        Else
            Camera.AutoDownload = False                         ' We need camera to do manual downloading
        End If
    End If
    Call Camera.SetFullFrame()                                  ' Assure no subframe Set
    Util.Console.PrintLine "MaxIm DL is version " & Util.FormatVar(MaxIm.Version, "0.00")
    Util.Console.PrintLine "Imager is " & Camera.CameraName     ' Log the imager name

    If Util.ScriptCamera.FilterWheelName <> "No Filter Wheel" Then
        c_haveFilters = True                                    ' We have filters...
        c_filterNames = Util.ScriptCamera.FilterNames           ' Copy MaxIm's filter names array
        If Util.Prefs.CameraPrefs.ClearFilterNumber < 0 Or _
            Util.Prefs.CameraPrefs.ClearFilterNumber > UBound(c_filterNames) Then _
                Err.Raise vbObjectError, "ACP.AcquireSupport", _
                    "Pointing/Focus Reference filter is invalid. Check ACP Imaging preferences"
        SetupFilters                                            ' Try for filter/focus offset info
        buf = Util.Profile.GetValue("LastFilterUsedTime", "\", "") ' ["" = sentinel] means no saved data available
        If buf <> "" Then
            prevFilt = CInt(Util.Profile.GetValue("LastFilterUsed", "\", "0"))  ' Should never see these 0 defaults!
'' Never believe MaxIm, just do it!
''          If Util.ScriptCamera.Filter <> prevFilt Then        ' If MaxIm's filter changed since the last run
                Util.Console.PrintLine "Selecting filter " & FilterName(prevFilt) & " from previous ACP run at " & _
                    Util.FormatVar(CDate(buf), "yyyymmdd@HhNnSs") & " UTC"
                Util.ScriptCamera.Filter = prevFilt             ' Tell MaxIm to use THIS filter now
''          End If
            c_selectedFilter = Util.ScriptCamera.Filter         ' And sync our state var
        Else
            c_selectedFilter = Util.Prefs.CameraPrefs.ClearFilterNumber ' Need to positively set something for sync
            Util.Profile.WriteValue "LastFilterUsed", CStr(c_selectedFilter), "\"
            Util.Profile.WriteValue "LastFilterUsedTime", Util.SysUTCDate, "\"
        End If
    Else
        c_haveFilters = False                                   ' No filters
        c_filterNames = Empty
        c_haveFilterInfo = False
        c_selectedFilter = 0
    End If

    SetupReadoutModes                                           ' Set up modes and special config
    c_curReadoutMode = c_normalReadoutMode                      ' Start in normal readout mode
    If c_haveReadoutModes Then
        Camera.ReadoutMode = c_curReadoutMode                   ' Make sure starts out in normal mode
    End If
    ClearAGHistory                                              ' For ACP web UI
    
    '
    ' Initialize guiding info
    '
    c_guideSensorType = Prefs.AutoGuiding.SensorType
    c_guideSensorAngle = Prefs.AutoGuiding.SensorAngle
    c_guideExtern = (c_guideSensorType = 0)                     ' 0 = External Guide Scope
    c_haveAOx = Prefs.Autoguiding.AdaptiveOptics
    If Prefs.AutoGuiding.Enabled Then
        Select Case  c_guideSensorType                          ' V7 - This is much betterr!
            case 0:     buf = "no rotator"
            case 1:     buf = "rotated internal"
            case 2:     buf = "rotated off-axis"
        End Select
        Util.Console.PrintLine "Guider is " & Camera.GuiderName & " (" & buf & ")"
        If c_haveAOx Then
            Util.Console.PrintLine " and it uses adaptive optics."
        End If
        If Util.Prefs.AutoGuiding.SensorPlateScale > 0 Then
            Util.Console.PrintLine "Guider plate scale is " & _
                    Util.FormatVar(Prefs.AutoGuiding.SensorPlateScale, "0.0") & _
                    " arcsec/pix. Guided dither with main imager pixels"
        Else
            Util.Console.PrintLine "Guider plate scale unknown, guided dither with guider pixels"
        End If
        Util.Console.PrintLine "Max unguided exposure " & Prefs.AutoGuiding.MaxUnguidedExposureInterval & " sec."
        If Prefs.AutoGuiding.DisableAggregation Then Util.Console.PrintLine "  and exposure agregation is disabled"
    Else
        Util.Console.PrintLine "Autoguiding is disabled"
    End If
    c_guiding = False
    c_guideExpMax = Prefs.AutoGuiding.MaximumExposureInterval  ' make copies of these
    c_guideExpMin = Prefs.AutoGuiding.MinimumExposureInterval
    c_guideErrMax = Prefs.AutoGuiding.MaximumStartupError
    c_guideSNRMin = Prefs.AutoGuiding.MinimumGuideStarSNR
    c_guideDecComp = Prefs.AutoGuiding.UseDecCompensation
    On Error Resume Next                                        ' Safely test for Multi-Star guiding (Preserve MaxIm 5 compat)
    c_multiStarGuiding = Camera.MultiStarGuiding
    If Err.Number <> 0 Then c_multiStarGuiding = False
    On Error GoTo 0
    If c_multiStarGuiding Then Util.Console.PrintLine "Guider is set to multi-star mode"
    '
    ' AutoFocus stuff
    '
    c_haveAF = Prefs.AutoFocus.Enabled                          ' Used throughout
    c_usePWI = Prefs.AutoFocus.UsePWI
    c_afActive = False                                          ' Not autofocusing right now (annunciator)
    c_lastFocusFWHM = CDbl(Util.Profile.GetValue("LastFocusFWHM", "\", "0")) ' [0.0 = sentinel]
    c_lastAvgFWHM = CDbl(Util.Profile.GetValue("LastAverageFWHM", "\", "0")) ' [0.0 = sentinel]
    ReDim c_lastFWHM(MXAFAVG)                                   ' Init FWHM averaging
    For i = 0 To (MXAFAVG)
        c_lastFWHM(i) = c_lastAvgFWHM                           ' Start out with previous average
    Next
    c_lastFWHMNum = 0
    If c_haveAF And Not c_usePWI Then                           ' If using FMx get it going here
        Util.Console.PrintLine "(assuring that FocusMax is running now...)"
        Set c_FMx = CreateObject("FocusMax.FocusControl")       ' Need this for check below
        Util.WaitForMilliseconds 5000                           ' How ugly! (it is required)
        '
        ' Assure that FocusMax 3.4.1 or later is installed.
        '
        FMxOk = True
        On Error Resume Next
        z = c_FMx.Version
        If Err.Number <> 0 Then FmxOk = False                   ' Doesn't even have Version property
        On Error GoTo 0
        If FmxOk Then
            bits = Split(z, ".")
            If UBound(bits) < 2 Then 
                FmxOk = False                                   ' No 3/4-part version (???)
            Else
                curLoc = GetLocale()
                SetLocale "en-us"
                If CSng(bits(0) & "." & bits(1)) < 3.4 Then     ' Accept 3.4 x or later
                    FmxOk = False
                End If
                SetLocale(curLoc)
            End If
        End If
        If Not FmxOk Then
            Set c_FMx = Nothing                                 ' Release FocusMax
            Err.Raise vbObjectError, "ACP.AcquireSupport", _
                 "**Autofocus failed - FocusMax too old. See ACP Help AutoFocus section."
        End If
    End If
    '
    ' Initialize other component scope variables
    '
    c_solveFails = 0
    c_exposureInterval = 0.0
    c_exposureProgress = 0.0
    C_exposureRemain = 0.0
    c_exposureActive = False
    c_previewReady = False
    c_calActive = False
    c_needLocalTopo = Prefs.DoLocalTopo                         ' Get local topo conversion pref
    c_simPosErrRMS = CDbl(Util.Profile.GetValue("PosErrRMS", "\PtgErrGen", CStr(0.5)))
    c_simImagePAOffset = CDbl(Util.Profile.GetValue("ImagePAOffset", "\PtgErrGen", "0"))
    c_simImagePA = c_simImagePAOffset                           ' For no rotator, StartRotateToPA() never called, PA is always 0
    c_simImageTimeCompress = True                               ' Default to 10:1 simulation imaging time
    c_ScaleH = (Camera.PixelSizeX / Telescope.FocalLength) * 0.206
    c_ScaleV = (Camera.PixelSizeY / Telescope.FocalLength) * 0.206
    Util.Console.PrintLine "Calculated unbinned plate scales (arcsec/pix): H = " & _
            Util.FormatVar(c_ScaleH, "0.00") & _
            " V = " & Util.FormatVar(c_ScaleV, "0.00")
    c_FovH = Camera.CameraXSize * (c_ScaleH / 60.0)
    c_FovV = Camera.CameraYSize * (c_ScaleV / 60.0)
    If c_FovV < c_FovH Then
        c_FovMin = c_FovV
    Else
        c_FovMin = c_FovH
    End If
    Util.Console.PrintLine "Calculated field of view (arcmin): H = " & _
            Util.FormatVar(c_FovH, "0.0") & _
            " V = " & Util.FormatVar(c_FovV, "0.0")
    c_lastSolvePosErr = 0.0                                     ' No plate solutions available yet
    c_lastSolvePA = 0.0                                         ' Position angle unknown so far
    c_lastSolveFWHM = 0                                         ' etc.
    c_brightStarMinMag = 6                                      ' Default values for FindBrightStar() and no FilterInfo
    c_brightStarMaxMag = 9
    c_brightStarSearchDeg = 15
    c_lastSyncRA = Telescope.RightAscension
    c_lastSyncDec = Telescope.Declination + 90                  ' Force full sim error on first update
    If c_lastSyncDec  > 90 Then c_lastSyncDec = 180.0 - c_lastSyncDec 
    Call put_DefocusCount(0)                                    ' Remove any old defocus from other run
    

    '
    '
    ' Echo PinPoint catalog
    '
    Util.Console.PrintLine "Plate solving with " & GetRefCatName(Util.Prefs.ReferenceCatalogType)
    '
    ' As of ACP 8 we are responsible for killing leftover rate offsets here. 
    ' No more of this nonsense internal to ACP. Plus we use Telescope V2
    ' properties instead of time wasting tests. Are there any mounts that don't
    ' support tracking control???
    '
    ' OOPS! The AP driver requires Tracking to be ON for TESTING DeclinationRate (only) and for
    ' changing the rates. I think I had better turn on tracking if either of the rates need to 
    ' be changed. Also for the AP I will catch the exception from testing DeclinationRate and 
    ' just turn on tracking, set the rates to 0, then back off. This will be the old logic for
    ' the AP only. Too bad I didn't make a note about this in the old code that was here.
    '
    If Telescope.CanSetTracking And Telescope.CanSetRightAscensionRate And Telescope.CanSetDeclinationRate Then
        c_haveTrackOffset = True
        Util.Console.PrintLine "Mount supports tracking rate offsets"
        x = False
        Err.Clear
        On Error Resume Next                                    ' Catch errors here 
        If Telescope.RightAscensionRate <> 0.0 Then Telescope.RightAscensionRate = 0.0
        If Err.Number <> 0 Then x = True                        ' Oops this one failed
        Err.Clear
        If Not x Then                                           ' Only if the RightAscensionRate went OK, try DeclinationRate
            If Telescope.DeclinationRate <> 0.0 Then Telescope.DeclinationRate = 0.0
            If Err.Number <> 0 Then x = True
        End If
        On Error GoTo 0
        '
        ' If x is True, then one of the above failed, probably for tracking state.
        ' If tracking is off then turn it on and re-do the above. This time the
        ' actions really should succeed. It is a fatal script error if they don't.
        '
        If x Then
            y = Telescope.Tracking                              ' Preserve current tracking state
            If Not y Then Telescope.Tracking = True             ' Turn it on for these rate initializations
            If Telescope.RightAscensionRate <> 0.0 Then Telescope.RightAscensionRate = 0.0
            If Telescope.DeclinationRate <> 0.0 Then Telescope.DeclinationRate = 0.0
            If Not y Then Telescope.Tracking = False            ' If tracking was off, turn it back on
        End If
        c_trackOffset = False
    Else
        If Not Telescope.CanSetTracking Then Util.Console.PrintLine "**CAUTION: Mount tracking cannot be controlled."
        c_haveTrackOffset = False
        c_trackOffset = False
    End If        
        
    If Util.RotatorConnected Then
        Set ROT = Util.Rotator
        c_haveRotator = True
        Util.Console.PrintLine "Imager rotator support enabled"
    Else
        Set ROT = Nothing
        c_haveRotator = False 
    End If
    
    If Util.ScriptTelescope.CanSync Then
        If Util.Prefs.EnableAllSkySolving Then
            Util.Console.PrintLine "All-sky plate solving will be attempted when needed"
            Util.Console.PrintLine "All-sky service at " & Util.Prefs.AllSkyDomainPort & " will be used"
        End If
    Else
        If Util.Prefs.EnableAllSkySolving Then
            Util.Console.PrintLine "Scope cannot be synced, so all-sky solving is not useful"
        End If
    End If
    GEN.Latitude = Telescope.SiteLatitude                       ' Set up the pointing error generator
    If Telescope.AlignmentMode = 2 Then
        GEN.German = 1
    Else
        GEN.German = 0
    End If
    '
    ' Spiral search factors
    '
    c_searchH = Array(0.0, 1.0, 0.0, -1.0, -1.0, -1.0, 0.0, 1.0, 1.0, 2.0, 1.0, 0.0, -1.0, _
            -2.0, -2.0, -2.0, -2.0, -2.0, -1.0, 0.0, 1.0, 2.0, 2.0, 2.0, 2.0)
    c_searchV = Array(0.0, 1.0, 1.0, 1.0, 0.0, -1.0, -1.0, -1.0, 0.0, 2.0, 2.0, 2.0, 2.0, _
            2.0, 1.0, 0.0, -1.0, -2.0, -2.0, -2.0, -2.0, -2.0, -1.0, 0.0, 1.0)
    
End Sub

' ===========
' TERMINATION
' ===========
Function Terminate()

    Set c_FMx = Nothing                                         ' Make sure FocusMax is released
    '
    ' Only if camera wasn't shut down!
    '
    If c_haveReadoutModes Then
        On Error Resume Next
        Util.ScriptCamera.ReadoutMode = c_normalReadoutMode
        On Error GoTo 0
    End If
    '
    ' Call custom action 
    '
    If Not c_userActions Is Nothing Then
        Call c_userActions.ScriptEnd() 
    End If
    
    Call put_DefocusCount(0)                                    ' Remove any defocus
    
End Function

' ==========
' PROPERTIES
' ==========

'dim ScopeNeedsLocalTopo (PrimalSCRIPT target)
Function get_ScopeNeedsLocalTopo()
    
    get_ScopeNeedsLocalTopo = c_needLocalTopo
    
End Function

Function put_ScopeNeedsLocalTopo(newValue)

    c_needLocalTopo = newValue

End Function

'Dim HaveFilterInfo (PrimalSCRIPT target)
Function get_HaveFilterInfo()

    get_HaveFilterInfo = c_haveFilterInfo
    
End Function

'Dim HaveAO (PrimalSCRIPT target)
Function get_HaveAO()

    get_HaveAO = c_haveAOx
    
End Function

'Dim HaveFilters (PrimalSCRIPT target)
Function get_HaveFilters()

    get_HaveFilters = c_haveFilters
    
End Function

'Dim HaveReadoutModes (PrimalSCRIPT target)
Function get_HaveReadoutModes()

    get_HaveReadoutModes = c_haveReadoutModes
    
End Function

'Dim HaveRotator (PrimalSCRIPT target)
Function get_HaveRotator()

    get_HaveRotator = c_HaveRotator
    
End Function

'Dim HavePinPoint4 (PrimalSCRIPT target)
Function get_HavePinPoint4()

    get_HavePinPoint4 = True        ' Always have PinPoint 4 now!
    
End Function

'Dim HaveTrackOffset (PrimalSCRIPT target)
Function get_HaveTrackOffset()

    get_HaveTrackOffset = c_haveTrackOffset
    
End Function

'Dim DoingOffsetTracking (PrimalSCRIPT target)
Function get_DoingOffsetTracking()

    get_DoingOffsetTracking = c_trackOffset
    
End Function

'Dim GuiderInterval (PrimalSCRIPT target)
Function get_GuiderInterval()

    If get_GuiderRunning Then
        get_GuiderInterval = c_guideExpCur
    Else
        get_GuiderInterval = 0
    End If
    
End Function

'Dim GuiderRunning (PrimalSCRIPT target)
Function get_GuiderRunning()

    If c_HaveAOx Then
        '
        ' AO7TrackBoxCount is sum of (pixel value - 100) for the
        ' track box. Assume 16x16 track box. Observed no-star values
        ' 0-1000, so set it to 2000
        '
        get_GuiderRunning = Util.ScriptCamera.GuiderRunning And _
                            (Util.ScriptCamera.AO7TrackBoxCount >= 2000)
    Else
        get_GuiderRunning = Util.ScriptCamera.GuiderRunning
    End If
    
End Function

'Dim Guiding (PrimalSCRIPT target)
Function get_Guiding()

    get_Guiding = c_guiding
    
End Function

'dim J2000RA (PrimalSCRIPT target)
Function get_J2000RA()

    get_J2000RA = c_J2000RA
    
End Function

'dim J2000Dec (PrimalSCRIPT target)
Function get_J2000Dec()

    get_J2000Dec = c_J2000Dec

End Function

'dim LastSyncRAJ2000 (PrimalSCRIPT target)
Function get_LastSyncRAJ2000()

    get_LastSyncRAJ2000 = c_lastSyncRA
    
End Function

'dim LastSyncDecJ2000 (PrimalSCRIPT target)
Function get_LastSyncDecJ2000()

    get_LastSyncDecJ2000 = c_lastSyncDec

End Function

'dim LastSolveRAJ2000 (PrimalSCRIPT target)
Function get_LastSolveRAJ2000()

    get_LastSolveRAJ2000 = c_lastSolveRA
    
End Function

'dim LastSolveDecJ2000 (PrimalSCRIPT target)
Function get_LastSolveDecJ2000()

    get_LastSolveDecJ2000 = c_lastSolveDec

End Function

'dim LastSolveFWHM (PrimalSCRIPT target)
Function get_LastSolveFWHM()

    get_LastSolveFWHM = c_lastSolveFWHM

End Function

'dim LastSolveScaleH (PrimalSCRIPT target)
Function get_LastSolveScaleH()

    get_LastSolveScaleH = c_LastSolveScaleH

End Function

'dim LastSolveScaleV (PrimalSCRIPT target)
Function get_LastSolveScaleV()

    get_LastSolveScaleV = c_LastSolveScaleV

End Function

'dim LastSolvePosErr (PrimalSCRIPT target)
Function get_LastSolvePosErr()

    get_LastSolvePosErr = c_lastSolvePosErr

End Function

'dim LastSolvePositionAngle (PrimalSCRIPT target)
Function get_LastSolvePA()

    get_LastSolvePA = c_lastSolvePA

End Function

'dim SlewDistance (PrimalSCRIPT target)
Function get_SlewDistance()

    If Not Util.ScriptTelescope.Slewing Then
        get_SlewDistance = 0.0
    Else
        get_SlewDistance = c_slewDist                           ' Computed just once
    End If
    
End Function

'dim SlewProgress (PrimalSCRIPT target)
Function get_SlewProgress()

    If Not Util.ScriptTelescope.Slewing Then
        get_SlewProgress = 0.0
    Else
        '
        ' How the hell To Do this? The scope doesn't move along
        ' a great circle, and can, at times, be further away from 
        ' the starting point than the great circle slew distance!
        '
        get_SlewProgress = 0.0
'         get_SlewProgress = EquDist2(c_slewStartRA, c_slewStartDec, _
'                                 Util.ScriptTelescope.RightAscension, _
'                                 Util.ScriptTelescope.Declination) / c_slewDist
    End If
End Function

'dim SimPosError (PrimalSCRIPT target)
Function get_SimPosError()

    get_SimPosError = c_simPosErrRMS
    
End Function

Function put_SimPosError(newVal)

    c_simPosErrRMS = newVal

End Function

'Dim SimImageRA (PrimalSCRIPT target)
Function get_SimImageRA()

    get_SimImageRA = c_simImageRA
    
End Function

'dim SimImageDec (PrimalSCRIPT target)
function get_SimImageDec()

    get_SimImageDec = c_simImageDec
    
End Function

'Dim SimImageTimeCompress (PrimalSCRIPT target)
Function get_SimImageTimeCompress()

    get_SimImageTimeCompress = c_simImageTimeCompress
    
End Function

Function put_SimImageTimeCompress(newValue)

    c_simImageTimeCompress = newValue

End Function

'dim LocalTopoRA (PrimalSCRIPT target)
Function get_LocalTopoRA()

    get_LocalTopoRA = c_localTopoRA
    
End Function

'dim LocalTopoDec (PrimalSCRIPT target)
Function get_LocalTopoDec()

    get_LocalTopoDec = c_localTopoDec
    
End Function

'dim ExposureActive (PrimalSCRIPT target)
Function get_ExposureActive()

    get_ExposureActive = c_exposureActive

End Function

Function put_ExposureActive(newVal)

    c_exposureActive = newVal
    
End Function

'dim ExposureInterval (PrimalSCRIPT target)
Function get_ExposureInterval()

    get_ExposureInterval = c_exposureInterval

End Function

'dim ExposureProgress (PrimalSCRIPT target)
Function get_ExposureProgress()

    get_ExposureProgress = c_exposureProgress

End Function

'dim PreviewReady (PrimalSCRIPT target)
Function get_PreviewReady()

    get_PreviewReady = c_previewReady

End Function

'dim AutoFocusActive (PrimalSCRIPT target)
Function get_AutoFocusActive()

    get_AutoFocusActive = c_afActive

End Function

Function put_AutoFocusActive(newVal)

    c_afActive = newVal
    
End Function

'dim MaxAutofocusTime (PrimalSCRIPT target)
Function get_MaxAutofocusTime()

    get_MaxAutofocusTime = MXAFTIME

End Function

'dim MaxImDocuments (PrimalSCRIPT target)
Function get_MaxImDocuments()

    Set get_MaxImDocuments = MaxIm.Documents

End Function

'dim MultistarGuiding (PrimalSCRIPT target)
Function get_MultistarGuiding()

    get_MultistarGuiding = c_guiding And c_multiStarGuiding

End Function

'dim LastAverageFWHM (PrimalSCRIPT target)
Function get_LastAverageFWHM()

    get_LastAverageFWHM = c_lastAvgFWHM
    
End Function

'dim LastFocusFWHM (PrimalSCRIPT target)
Function get_LastFocusFWHM()

    get_LastFocusFWHM = c_lastFocusFWHM
    
End Function

'dim LastFocusPosition (PrimalSCRIPT target)
Function get_LastFocusPosition()

    get_LastFocusPosition = c_lastFocusPosition
    
End Function

'dim Calibrating (PrimalSCRIPT target)
Function get_Calibrating()

    get_Calibrating = c_calActive

End Function

'dim ExternalGuider (PrimalSCRIPT target)
Function get_ExternalGuider()

    get_ExternalGuider = c_guideExtern

End Function

'dim UserActions (PrimalSCRIPT target)
Function get_UserActions()

    Set get_UserActions = c_userActions

End Function

'dim PlateScaleH (PrimalSCRIPT target)
Function get_PlateScaleH()

    get_PlateScaleH = c_ScaleH

End Function

'dim PlateScaleV (PrimalSCRIPT target)
Function get_PlateScaleV()

    get_PlateScaleV = c_ScaleV

End Function

'dim FieldOfViewH (PrimalSCRIPT target)
Function get_FieldOfViewH()

    get_FieldOfViewH = c_FovH

End Function

'dim FieldOfViewV (PrimalSCRIPT target)
Function get_FieldOfViewV()

    get_FieldOfViewV = c_FovV

End Function

'dim FieldOfViewMin (PrimalSCRIPT target)
Function get_FieldOfViewMin()

    get_FieldOfViewMin = c_FovMin

End Function

'dim RotatorMoving (PrimalSCRIPT target)
Function get_RotatorMoving()
    If Not c_haveRotator Then
        get_RotatorMoving = False
    Else
        get_RotatorMoving = ROT.IsMoving
    End If
End Function

'dim RotatorPositionAngle (PrimalSCRIPT target)
Function get_RotatorPositionAngle()
    Dim PA
    
    If Not c_haveRotator Then                                   ' Safety catch
        PA = c_lastSolvePA                                      ' Still report the PA that we got
    Else
        PA = ROT.Position                                       ' Current raw PA of rotator
        PA = PA - ROT.PABias                                    ' Remove bias Error
        If Util.GEMWestOfPier Then  PA = PA + 180.0             ' If GEM looking west, roll the imager over
        PA = RangeAngle(PA, 0.0, 360.0)                         ' Range the PA 0-360
    End If
    get_RotatorPositionAngle = PA
    
End Function

'Dim SolveFails (PrimalSCRIPT target)
Function get_SolveFails()

    get_SolveFails = c_solveFails
    
End Function

Function put_SolveFails(newVal)

    c_SolveFails = newVal
    
End Function

'Dim CrosshatchAvoidance (PrimalSCRIPT target)
Function get_CrosshatchAvoidance()
    
    get_CrosshatchAvoidance = CROSSHATCH_SCALING
    
End Function

'Dim AutoflatReadoutMode (PrimalSCRIPT target)
Function get_AutoflatReadoutMode()

    get_AutoflatReadoutMode = c_flatReadoutMode
    
End Function

'Dim ReadoutMode (PrimalSCRIPT target)
Function get_ReadoutMode()

    get_ReadoutMode = ReadoutModeName(c_curReadoutMode)
    
End Function

Function put_ReadoutMode(newVal)

    c_curReadoutMode = DecodeReadoutMode(newVal)
    
End Function

'Dim DefocusCount (PrimalSCRIPT target)
Function get_DefocusCount()
    Dim buf
    
    get_DefocusCount = CLng(Util.Profile.GetValue("CurrentDefocusCount", "\", "0"))
    
End Function

Function put_DefocusCount(newVal)
    Dim curVal

    If Not c_haveAF and newval <> 0 Then
        Err.Raise vbObjectError, "ACP.AcquireSupport", _
            "Defocused images not supported with AutoFocus disabled. Need a focuser."
    End If
    
    curVal = get_DefocusCount()
    If curVal <> newVal Then
        If newVal = 0 Then
            Util.Console.PrintLine "  (removing defocus)"
        Else
            Util.Console.PrintLine "  (defocusing " & newVal & " steps)"
        End If
        Call MoveFocuser(newVal - curVal, False)
    End If
    Util.Profile.WriteValue "CurrentDefocusCount", newVal, "\"
    
End Function

'Dim BrightStarMinMag
Function get_BrightStarMinMag()

    get_BrightStarMinMag = c_brightStarMinMag
    
End Function

Function put_BrightStarMinMag(newVal)

    c_brightStarMinMag = newVal
    
End Function

'Dim BrightStarMaxMag
Function get_BrightStarMaxMag()

    get_BrightStarMaxMag = c_brightStarMaxMag
    
End Function

Function put_BrightStarMaxMag(newVal)

    c_brightStarMaxMag = newVal
    
End Function

'Dim BrightStarSearchDeg
Function get_BrightStarSearchDeg()

    get_BrightStarSearchDeg = c_brightStarSearchDeg
    
End Function

Function put_BrightStarSearchDeg(newVal)

    c_brightStarSearchDeg = newVal
    
End Function


' =======
' METHODS
' =======

'----------------------------------------------------------------------------------------
' ------------
' SolvePlate() - Solve the plate
' ------------
'
' Parameters:
'   File                Complete file name of image
'   RA                  Approx centerpoint RA (J2000)
'   Dec                 Approx centerpoint Dec (J2000)
'   PA                  Imager position angle (0 of no rotator)
'   ScaleH              Approx horiz plate scale (may be binned)
'   ScaleV              Approx vert plate scale (may be binned)
'   MinBrt              Minimum brightness for PinPoint
'   Sigma               Sigma for PinPoint
'   SolveMax            MaxSolveStars for PinPoint
'   CatMax              CatalogMaximumMagnitude for PinPoint
'   TimeMax             MaxSolveTime for PinPoint
'   UpdCorr             True to add pointing corrector observation
'   UpdFWHM             Use FWHM to update the stats (not for pointing images)
'
' Returns:
'   True if plate solved, else False
'
' Sets c_lastSolveRA, c_LastSolveDec, c_lastSolveScaleH, c_lastSolveScaleV, c_lastSolvePosErr 
' and ROT.PABias, c_SolveFails variables, raises error if too many solve failures 
' in a row (Pref).  Performs catalog-driven spiral search (Prefs). Resets c_SolveFails 
' on successful solves.
'----------------------------------------------------------------------------------------
Function SolvePlate(File, RA, Dec, PA, ScaleH, ScaleV, MinBrt, Sigma, SolveMax, _
                        CatMax, TimeMax, UpdCorr, UpdFWHM)
    Dim plate, ST, i, j, fl, x, cl, hstep, vstep, nMax, bSolved, buf, rotPA
    
    '
    ' Set up for possible spiral search...
    '
    Select Case Util.Prefs.PointingUpdates.SpiralSearch
        Case 0: nMax = 0                                        ' 1 point, center
        Case 1: nMax = 8                                        ' 9 points 3 x 3
        Case 2: nMax = 24                                       ' 25 points, 5 x 5
    End Select

    Voice.Speak "Solving plate."
    Set plate = CreateObject("PinPoint.Plate")
    plate.Catalog = Util.Prefs.ReferenceCatalogType
    plate.CatalogPath = Util.Prefs.ReferenceCatalogPath
    '
    ' Allow for DropBox sync to hold this just-created image for up
    ' to 60 seconds for sync.
    '
    On Error Resume Next
    For i = 1 To 30                                             ' Allow DropBox to hold lock for 60 sec
        Err.Clear
        plate.AttachFITS File                                   ' Attach the image
        If Err.Number <> 0 Then 
            Util.Console.PrintLine "Tempfile: " & Err.Description & " (" & i & ")"
            Util.WaitForMilliseconds 2000
        Else
            Exit For
        End If
    Next
    On Error GoTo 0
    plate.RightAscension = RA                                   ' Set approx coordinates
    plate.Declination = Dec
    plate.ArcsecPerPixelHoriz = ScaleH                          ' Set current scale factors
    plate.ArcsecPerPixelVert = ScaleV
    plate.MinimumBrightness = MinBrt                            ' Set target solve sensitivity
    plate.SigmaAboveMean = Sigma
    plate.CatalogMaximumMagnitude = CatMax
    plate.CatalogExpansion = 0.33
    plate.MaxSolveStars = SolveMax
    plate.MaxSolveTime = TimeMax
''  plate.RemoveHotPixels 0.1                                   ' Experimental, commented out
    plate.ImageModified = False                                 ' Assure image is not saved
    If Util.Prefs.SaveStarLists Then plate.CacheImageStars = True  ' Save starlist w/PP4
    plate.FindImageStars
    While Not plate.ImageStarsReady
        Util.WaitForMilliseconds 500
    Wend
    If plate.ImageStars.Count = 0 Then
        Util.Console.PrintLine "No image stars found, failed."
        i = nMax + 1                                            ' [failure sentinel]
    Else
        Util.Console.PrintLine "  " & plate.ImageStars.Count & " image stars found"
        
        If nMax > 1 Then                                        ' hstep/vstep not used on i = 0
''-         Trace "  (doing " & nMax + 1 & " point spiral search if needed)"
            hstep = ((scaleH * plate.Columns * 0.75) / (60.0 * 15.0)) / _
                            Cos(plate.Declination * DEGRAD)     ' Arcminutes, for EquOffset()
            vstep = ((scaleV * plate.Rows * 0.75) / 60.0)
        End If
        For i = 0 To nMax
            Util.WaitForMilliseconds 100                        ' Allow aborting within this loop
            If i > 0 Then
                Call EquOffset(RA, Dec, (hstep * c_searchH(i)), (vstep * c_searchV(i)))
                plate.RightAscension = c_equOffsetRA
                plate.Declination = c_equOffsetDec
            End If
            Err.Clear
            On Error Resume Next
            plate.FindCatalogStars                              ' Failure raises error
            If Err.Number <> 0 Then                             ' Failed to get cat stars???
                Util.Console.PrintLine "** " & Err.Description  ' Print diagnostic and fail
                i = nMax + 1                                    ' [failure sentinel]
                Exit For                                        ' Force failure exit from loop
            End If
            Err.Clear
            Util.Console.PrintLine "  " & plate.CatalogStars.Count & " catalog stars found"
            plate.Solve
            If Err.Number = 0 Then
                x = Abs(ScaleH / plate.ArcsecPerPixelHoriz)     ' Sanity-check solution
                If x < 0.9 Or x > 1.1 Then
                    Util.Console.PrintLine "** Focal length off by more than 10%, solution rejected."
                Else               
                    Exit For                                    ' SOLVED! Exit spiral Loop
                End If
            Else
                Util.Console.PrintLine "** " & Err.Description  ' Didn't solve, oh well...
            End If
            On Error GoTo 0                                     ' Back to fatal errors
        Next
    End If
    On Error Goto 0
    If i > nMax Then                                            ' Failed completely
        plate.DetachFITS
        Set plate = Nothing
        c_lastSolvePosErr = 0.0                                 ' No plate solution available
        ' Other "last solve" variables left alone!
        c_solveFails = c_solveFails + 1
        '
        ' Raise Error if solving has failed too many times
        '
        If c_solveFails >= Util.Prefs.PointingUpdates.MaximumSolveFailures Then
            Err.Raise  vbObjectError, "ACP Plate Solver", _
                "**Too many failures to plate solve. The scope appears to be lost. Aborted."
        Else
            SolvePlate = False
            Exit Function
        End If
    End If       
    '
    ' Solved successfully...
    '
    c_solveFails = 0                                            ' Reset successive fails counter
    c_lastSolveRA = plate.RightAscension
    c_lastSolveDec = plate.Declination
    c_LastSolveScaleH = plate.ArcsecPerPixelHoriz               ' Save corrected plate scales
    c_LastSolveScaleV = plate.ArcsecPerPixelVert
    c_lastSolvePA = PlateToPA(plate)                            ' Save position angle

    plate.UpdateFITS                                            ' Write WCS for later analysis
    
    Util.Console.PrintLine "  Solved! " & plate.MatchedStars.Count & " stars matched."
    Voice.Speak "Solved! " & plate.MatchedStars.Count & " stars matched."
    Util.Console.PrintLine "  Average residual is " & _
            Util.FormatVar(plate.MatchAvgResidual, "0.##") & " arcsec."
    c_lastSolvePosErr = EquDist(RA, Dec, plate.RightAscension, plate.Declination) * 60
    Util.Console.PrintLine "  Pointing error is " & _
                            Util.FormatVar(c_lastSolvePosErr, "0.000") & " arcmin @ angle " & _
                            Util.FormatVar(PositionAngle(RA, Dec, plate.RightAscension, plate.Declination), "0.00")
    Voice.Speak "Pointing error is " & _
                            Util.FormatVar(c_lastSolvePosErr, "0.00") & " arc minutes."
    '
    ' Update the corrector if wanted, corrector is enabled, and auto-mapping is enabled.
    '
    If UpdCorr and Util.PointingCorrectionEnabled And Util.AutoMappingEnabled Then
        ST = plate.SiderealTime                                 ' More accurate ST for image
        If Util.AddPointingObservation(RA, Dec, plate.RightAscension, plate.Declination, Util.GEMWestOfPier, ST) Then
        Util.Console.PrintLine "  (pointing corrector updated with this observation)"
        Voice.Speak "Pointing corrector updated with this observation."
        End If
    End If
    '
    ' We only use FWHMs of 1.5 pixels or more
    '
    If UpdFWHM Then
        If plate.FullWidthHalfMax > 1.5 Then
            c_lastSolveFWHM = plate.FullWidthHalfMax * Abs(plate.ArcsecPerPixelHoriz) ' FWHM in arcsec!
        Else
            c_lastSolveFWHM = 0                                 ' [sentinel] see below
            ' (scary) Util.Console.PrintLine("  (FWHM measurement suspect, plate scale too high)")
        End If
    End If

    ' 
    ' Log and update focal length to 1 decimal place in mm. Log
    ' roll angle too. Report ACP focal length error > 10%
    '
    fl = Util.ScriptCamera.PixelSizeX * 0.206 / Abs(c_LastSolveScaleH / plate.BinningHoriz)
    Util.Console.PrintLine "  True focal length is " & _
                            Util.FormatVar(fl * 1000.0, "0.0") & " mm."
    x = Abs(fl / Util.ScriptTelescope.FocalLength)              ' Check against ACP FL setting
    If x < 0.9 Or x > 1.1 Then                                  ' If more than 10% off
        Util.Console.PrintLine "**NOTE: Focal Length setting in ACP is off by more than 10%"
    Else
        plate.WriteFITSDouble "FOCALLEN", fl * 1000.0, 1
        Util.Console.PrintLine "  True binned plate scales (arcsec/pix): H = " & _
            Util.FormatVar(Abs(c_LastSolveScaleH), "0.00") & " V = " & _
            Util.FormatVar(Abs(c_LastSolveScaleV), "0.00")
    End If
    '
    ' This should appear right next to the sky PA
    '
    Util.Console.PrintLine "  True image center (J2000): " & _
                            Util.Hours_HMS(plate.RightAscension, "h ", "m ", "s ", 1) & _
                            "  " & Util.Degrees_DMS(plate.Declination, , , , 2)
    '
    ' Calculate the current difference between the mechanical rotator PA and the
    ' true PA from the plate solution. This is used for all transformations 
    ' to and from true (equatorial) PA. The assumption is that a pointing update
    ' always starts a plan or run, and this gives us the offset. We recalculate
    ' the offset after each plate solution just in case. This is probably overkill, 
    ' as the imager  misalignment on the rotator "probably" won't drift, but what 
    ' the hey! It's conceptually consistent and will handle that error if it DOES 
    ' occur.
    '
    ' The mechanical PA of the rotator and the GEM pier side info are put into the 
    ' FITS header by TakePicture() so we have that for the moment the image was 
    ' acquired, regardless of slew-ahead actions that may have been taken thereafter
    ' (and before we were called).
    '
    ' Write the rotator PA offset to the first line of RotatorInfo.txt
    '
    buf = Util.FormatVar(c_lastSolvePA, "0.0")
    If(buf = "360.0") Then buf = "0.0"
    Util.Console.PrintLine "  Imager sky position angle is " & buf & " deg."
    If c_haveRotator Then
        cl = GetLocale()                                        ' Get locale (. vs , s**t)
        SetLocale "en-us"                                       ' Make sure numbers convert properly
        rotPA = CDbl(Trim(plate.ReadFITSValue("ROT_PA")))       ' Gets raw floating-point String
        buf = Util.FormatVar(rotPA, "0.0")                      ' Needs regular decimals too!
        If(buf = "360.0") Then buf = "0.0"                      ' As does this :-(
        SetLocale cl                                            ' Now restore the locale
        Util.Console.PrintLine "  Rotator mech. position angle is " & buf & " deg."
        x = rotPA - c_lastSolvePA
        If Util.ScriptTelescope.AlignmentMode = 2 Then          ' Only for  GEM
            ' Compensate for GEM rollover (EAST -> looking west)
            If UCase(plate.ReadFITSValue("PIERSIDE")) = "'EAST    '" Then x = x + 180.0 
        End If
        ROT.PABias = RangeAngle(x, -180.0, 180.0)               ' Imager roll offset from rotator
'       If Abs(ROT.PABias) >= 10.0 Then _
'           Util.Console.PrintLine "  NOTE: Imager and rotator are misaligned by " & _
'               Util.FormatVar(ROT.PABias, "0.0") & " deg."
    End If
    '
    ' FWHM and Adaptive Autofocus processing
    '
    If UpdFWHM Then
        If c_lastSolveFWHM > 0 Then                             ' Have usable FWHM (see above)
            Util.Console.PrintLine "  Image FWHM is " & _
                Util.FormatVar(c_lastSolveFWHM, "0.0") & _
                " arcsec (" & Util.FormatVar(plate.FullWidthHalfMax, "0.00") & " pixels)"
        End If
        If c_haveAF And c_lastSolveFWHM > 0 Then                ' Only do this for valid solve FWHMs
            If c_lastFocusFWHM = 0 Then 
                c_lastFocusFWHM = c_lastSolveFWHM               ' If first good FWHM after AutoFocus remember this
                Util.Profile.WriteValue "LastFocusFWHM", CStr(c_lastFocusFWHM), "\"    ' Save this across script invocations
                For i = 0 To (MXAFAVG)
                    c_lastFWHM(i) = c_lastSolveFWHM             ' Fill averaging array with post-focus FWHM
                Next
                c_lastFWHMNum = 0
                c_lastAvgFWHM = c_lastSolveFWHM                 ' We knnow the average too!
                Util.Profile.WriteValue "LastAverageFWHM", CStr(c_lastAvgFWHM), "\"    ' Save this across script invocations
            Else                                                ' 
                c_lastFWHM(c_lastFWHMNum) = c_lastSolveFWHM
                '
                ' At this point the last image FWHM is stored in the c_lastFWHM() Array
                ' Do not use "way out" FWHMs! NOTE <= BELOW FOR INITIALIZATION!
                '
                If (c_lastAvgFWHM = 0.0) Or (c_lastFWHM(c_lastFWHMNum) <= (3.0 * c_lastAvgFWHM)) Then ' Only if reasonable FWHM this Time
                    c_lastFWHMNum = c_lastFWHMNum + 1           ' Bump index
                    If c_lastFWHMNum > MXAFAVG Then c_lastFWHMNum = 0 ' Wrap index around if needed
                    x = 0.0
                    j = 0
                    For i = 0 To MXAFAVG                        ' Calculate running average
                        If c_lastFWHM(i) > 0 Then 
                            x = x + c_lastFWHM(i)               ' Average only live values
                            j = j + 1
                        End If
                    Next
                    If j > 0 Then
                        c_lastAvgFWHM = x / CDbl(j)             ' Running average of live values
                        Util.Profile.WriteValue "LastAverageFWHM", CStr(c_lastAvgFWHM), "\"    ' Save this across script invocations
                        If c_haveAF Then Util.Console.PrintLine "  (avg FWHM = " & Util.FormatVar(c_lastAvgFWHM, "0.00") & " arcsec)"
                    Else
                        c_lastAvgFWHM = 0.0                     ' [sentinel] Still no data
                    End If
                Else
                   If (c_lastAvgFWHM > 0.0) Then Util.Console.PrintLine "  (way-out FWHM, ignored)"
                End If
            End If
        End If
    End If

    plate.DetachFITS                                            ' Clean up
    SolvePlate = True

End Function

'----------------------------------------------------------------------------------------
' ----------------
' RecenterTarget() - Jog the scope to center the target
' ----------------
'
' SAFE FOR GUIDING
'
' Parameters:
'   TargetName              Target name (for logging)
'   RightAscension          Target RA (J2000)
'   Declination             Target Dec (J2000)
'
' NOTE: DEPENDS ON LAST PLATE SOLUTION!
'----------------------------------------------------------------------------------------
Sub RecenterTarget(TargetName, RightAscension, Declination)
    Dim wasGuiding
    '
    ' If the pointing corrector is enabled, we could still have a small
    ' uncorrected error in the telescope's pointing. Thus, we use the 
    ' desired and actual J2000 coordinates to calculate an offset which
    ' is then applied to the CURRENT telescope (local topo, possibly 
    ' corrected) coordinates, to get the desired telescope coordinates.
    ' Whether the sync was sent directly to the telescope or was applied To
    ' the model, this gives us the right delta coordinates to put the 
    ' target on-center. If the corrector is running, the indicated coordinates
    ' will be off by the model error, but that's probably not a big deal.
    ' This function puts the desired telescope J2000 coordinates into
    ' c_slewTargetRA and c_slewTargetDec.
    '
    wasGuiding = c_guiding                                      ' Slew kills guiding
    CalcSlewTarget RightAscension, Declination, _
                    c_lastSolveRA, c_lastSolveDec, _
                    Util.ScriptTelescope.RightAscension, _
                    Util.ScriptTelescope.Declination
    Util.Console.PrintLine "  Re-slew to target."
    StartSlewJ2000 TargetName, c_slewTargetRA, c_slewTargetDec
    WaitForSlew
    If wasGuiding Then AutoGuide True                           ' If needed re-start guider
    
End Sub

'----------------------------------------------------------------------------------------
' ----------------
' UpdatePointing() - Point the scope right at the object
' ----------------
'
' Parameters:
'   TargetName              Target name (for image file name)
'   RightAscension          Target RA (J2000)
'   Declination             Target Dec (J2000)
'   PositionAngle           Image PA for possible rotator (0 if no rotator)
'
' Returns:
'   True/False depending on whether the pointing update was successful
'   May be called during a #repeat (after meridian flip!) while orbital tracking is 
'   active. Save and restore same.
'
' Refuses and returns False if positioned within 1 deg. of hard limits.
'----------------------------------------------------------------------------------------
Function UpdatePointing(TargetName, RightAscension, Declination, PositionAngle) 
    Dim fn, plate, tRA, tDec, oRA, oDec, rotErr, curDefocus
    
    '
    ' Refuse if within 1 degree of ACP horizon limits
    '
    If Not SafeAboveHorizon(RightAscension, Declination, 1.0) Then
        Util.Console.PrintLine "  Pointing update refused, within 1 degree of horizon limits."
        UpdatePointing = False
        Exit Function
    End If
    '
    ' OK, looks good to press on...
    '
    If Util.ScriptTelescope.CanSync Then                        ' Window dressing
        Util.Console.PrintLine "  Updating pointing..."
        Voice.Speak "Updating pointing."
    Else
        Util.Console.PrintLine "  Doing auto-center..."
        Voice.Speak "Doing auto-center."
    End If
    
    curDefocus = get_DefocusCount()
    If curDefocus <> 0 Then
        Call put_DefocusCount(0)
    End If
        
    '
    ' Make the pointing exposure pathname (no ext. per TakeImage)
    '
    fn = Util.Prefs.LocalUser.DefaultImageDir & "\PointingExps"
    CreateFolder fn, False
    fn = fn & "\p-" & MakeFileName(TargetName)
    '
    ' Acquire the pointing exposure and solve it. COMPLEX INTERACTION
    ' READ THE COMMENTS IN TakePointingImage() BELOW!
    '
    If Not TakePointingImage(TargetName, fn, RightAscension, _
                            Declination, PositionAngle) Then
        UpdatePointing = False
        If curDefocus <> 0 Then
            Call put_DefocusCount(curDefocus)
        End If
        Exit Function                                           ' FAILED! RETURN
    End If
    If curDefocus <> 0 Then
        Call put_DefocusCount(curDefocus)
    End If
    '
    ' If this was a successful pointing update, delete the good pointing image
    ' to save user's disk space. We rarely look at good ones!!
    '
    On Error Resume Next										' Just in case, best efforts
    FSO.DeleteFile fn & ".fts", True
    On Error GoTo 0
    '
    ' OK we now have the real J2000 RA/Dec of the center of the 
    ' picture we just took. Sync the scope to update its coordinates
    ' or the pointing corrector's model.
    '
    If Util.ScriptTelescope.CanSync Then                        ' If we have a sync-able scope
'       =========================================
        SyncToJ2000 c_lastSolveRA, c_lastSolveDec
'       =========================================
    End If
    '
    ' If we didn't need to offset, we may have a tiny distance to correct. 
    ' Some scopes have a problem with this, so try to avoid such tiny
    ' slews. However if we have an internal guider always recenter, as the
    ' pin-hole guider needs the star potentially selected by hand using
    ' an FOVI. If we did offset, just slew back to the target and we should
    ' be right on.
    '
    If c_equOffsetDec = 0.0 Then                                ' Got it w/o offset
        If c_lastSolvePosErr < Util.Prefs.PointingUpdates.MaximumError Then
            Util.Console.PrintLine "  Within max error tolerance, no re-slew needed."
            '
            ' Unguided dithering needs c_slewTargetRA/Dec (not target RA/Dec) as its
            ' reference point. These are set by RecenterTarget, but we're not doing
            ' that..
            '
            If c_needLocalTopo Then
                LocalTopocentricToJ2000 Util.ScriptTelescope.RightAscension, Util.ScriptTelescope.Declination
                c_slewTargetRA = c_J2000RA
                c_slewTargetDec = c_J2000Dec
            Else
                c_slewTargetRA = Util.ScriptTelescope.RightAscension
                c_slewTargetDec = Util.ScriptTelescope.Declination
            End If
        Else
            RecenterTarget TargetName, RightAscension, Declination ' Need to recenter
        End If
    Else                                                        ' We did offset
        RecenterTarget Targetname, RightAscension, Declination  ' Always recenter
    End If

    ' 
    ' If we have a rotator, and the rotator is off by more than one degree, 
    ' then rotate to remove that error/bias.
    '
    If c_haveRotator Then
        rotErr = Abs(c_lastSolvePA - PositionAngle)
        If rotErr > 180.0 Then rotErr = 360.0 - rotErr
        If rotErr > 1.0 Then
            Util.Console.PrintLine "  PA error of " & _
                                   Util.FormatVar(rotErr, "0.0") & _
                                   " deg. detected. Correcting..."
            StartRotateToPA PositionAngle, RightAscension
            WaitForRotator
        End If
    End If
    Util.Console.PrintLine "  Target is now centered."
    
    UpdatePointing = True                                       ' Hooray!
    
End Function

'----------------------------------------------------------------------------------------
' -------------------
' TakePointingImage() - Acquire and solve a pointing image
' -------------------
'
' Parameters:
'   TargetName              Target name (for image file name)
'   FileName                Image file name (without extension)
'   RightAscension          New Scope RA (J2000)
'   Declination             New scope Dec (J2000)
'   PositionAngle           Image PA for possible rotator (0 if no rotator)
'
' Returns:
'   True/False depending on whether the pointing update was successful
'
' If successful, leaves the scope at the position of the exposure. If fails
' it will slew back to the original position. Sets c_equOffsetDec to the
' distance it had to offset to get a solvable image. Does not add an
' observation to the pointing corrector. Uses configured Clear filter,
' unless focus offset data is available, then uses the specified Filter
' for pointing updates for the currently selected filter. Also sets, via 
' call to SolvePlate, c_lastSolvePosErr (pos err, arcmin). Finally, it
' updates the focal length preference in ACP, so that changes in optics
' can be tracked and plate solutions will be as reliable as possible.
' This does NOT cause FWHM stats to be changed. The pointing images are 
' useless for this.
'----------------------------------------------------------------------------------------
Function TakePointingImage(TargetName, FileName, RightAscension, Declination, PositionAngle)
    Dim fovH, fovV, fovMin, subframe, offset, oDec, pole
    Dim bin, n, fl, doGuide, Camera, PtgPrefs, prevCA, ptgErr
    
    Set Camera = Util.ScriptCamera
    Set PtgPrefs = Util.Prefs.PointingUpdates
    
    '
    ' Plate scales and FOVs
    '
    fovH = Camera.CameraXSize * c_ScaleH
    fovV = Camera.CameraYSize * c_ScaleV
    If fovV < fovH Then
        offset = fovH / 30.0        ' 2 x max FOV, arcmin.
        fovMin = fovV               ' Remember smaller FOV dimension
    Else
        offset = fovV / 30.0        ' 2 x max FOV, arcmin.
        fovMin = fovH               ' Remember smaller FOV dimension
    End If
    '
    ' Optimize the time given to the pointing exposure. Set the binning to take only as 
    ' detailed a pic as needed...
    '
    bin = get_PointingBinning()     ' See the JS section of AcquireSupport
    '
    ' If we have a huge FOV, subframe it again to optimize pointing exposure 
    ' time. Don't bother to alter the offset computed above. It'll still work
    ' just fine, though it will be more than 2x (subframed) FOV.
    '
    If fovMin > 2400 Then
        subframe = 2400 / fovMin
    Else
        subframe = 1.0
    End If
    '
    ' Polar direction for offset movement in Dec
    '
    If Util.ScriptTelescope.SiteLatitude > 0 Then 
        pole = 1.0
    Else
        pole = -1.0
    End If
    '
    ' Use the guider if the pointing exposure is "long"
    '
    doGuide = False
    If Util.Prefs.AutoGuiding.Enabled And _
                (PtgPrefs.Interval > Util.Prefs.AutoGuiding.MaxUnguidedExposureInterval) Then
        If c_guideExtern Then
            doGuide = True
        Else
            Util.Console.PrintLine "** Internal/OAG guider, cannot guide pointing exposures!"
        End If
    End If
    '
    ' Loop trying to plate solve first at the initial coordinates, Then
    ' at twice and four times the FOV towards pole from the initial
    ' coordinates. This will catch the problem of trying to plate solve
    ' with a giant extended object or globular cluster in the field.
    ' Going toward the pole for the offset avoids meridian flipping
    ' problems as well as hitting the low elevation limit. 
    '
    oDec = Declination                                          ' Start at original coordinates
    c_equOffsetDec = 0.0                                        ' Clients know we haven't offset
    For n = 1 To OFFSET_TRIES
        '
        ' Start the guider if needed
        '
        If doGuide Then
            Util.Console.PrintLine "  (long exp, trying to autoguide)"
            AutoGuide True                                      ' Best efforts
        End If
        '
        ' Take the image for pointing, no dithering
        '
        TakePicture PtgPrefs.Interval, bin, subframe, 0.0, _
                            c_selectedFilter, _
                            FileName, "", True, False, False, False, "PinPoint", _
                            "Pointing Image", RightAscension, oDec, _
                            False, "", "", 0, 0, False, PositionAngle
        If c_guiding Then AutoGuide False                       ' If guiding, stop it
        '
        ' Use PinPoint to plate-solve the image and get back the 
        ' real center point RA/Dec (J2000) as well as the actual
        ' plate scales. 
        '
        Util.Console.PrintLine "  Plate-solve pointing image."
        Voice.Speak "Plate-solve pointing image."
        If SolvePlate(FileName & ".fts", RightAscension, oDec, PositionAngle, _
                    c_ScaleH * bin, c_scaleV * bin, _
                    PtgPrefs.MinimumBrightness, PtgPrefs.Sigma, 300, _
                    PtgPrefs.CatalogMaximumMagnitude, 45, False, False) Then
            Exit For                                            ' SOLVED!
        End If
        If n < OFFSET_TRIES Then
            '
            ' Plate solution failed, move 2 FOV toward the pole unless 
            ' we just did the last try. [4.2] Disable CA for this/
            '
            Call EquOffset(RightAscension, Declination, 0, (pole * offset * n))
            oDec = c_equOffsetDec
            On Error Resume Next
            Call Util.EnforceSlewLimits(RightAscension, Declination)
            If Err.Number = 0 Then
                prevCA = Util.ConsistentApproachEnabled         ' Remember current CA setting
                Util.ConsistentApproachEnabled = False          ' Disable CA for this
                On Error GoTo 0
                StartSlewJ2000 "offset", RightAscension, oDec
                WaitForSlew
                Util.ConsistentApproachEnabled = prevCA         ' Restore config'ed CA setting
            Else
                On Error Goto 0
                n = OFFSET_TRIES
            End If
        ElseIf Util.ScriptTelescope.CanSync And Util.Prefs.EnableAllSkySolving Then
            '
            ' Offset attempt(s) failed, now drop the hammer, but only for sync-able scopes. 
            '
            Voice.Speak "Trying all-sky plate solution"
            If Not AllSkySolve(FileName & ".fts") Then          ' Try all-sky recovery
                n = OFFSET_TRIES
            Else
                If Util.Prefs.DoLocalTopo Then
                    LocalTopocentricToJ2000 Util.ScriptTelescope.RightAscension, Util.ScriptTelescope.Declination
                Else
                    c_J2000RA = Util.ScriptTelescope.RightAscension
                    c_J2000Dec = Util.ScriptTelescope.Declination
                End If
                Util.Console.PrintLine "  All-sky solution successful!"
                Util.Console.PrintLine "  Scope:  " & Util.Hours_HMS(c_J2000RA) & " " & Util.Degrees_DMS(c_J2000Dec)
                Util.Console.PrintLine "  Actual: " & Util.Hours_HMS(c_lastSolveRA) & " " & Util.Degrees_DMS(c_lastSolveDec)
                ptgErr = (EquDist2(c_J2000RA, c_J2000Dec, c_lastSolveRA, c_lastSolveDec)) * 60.0
                Util.Console.PrintLine "    Pointing error is " & Util.FormatVar(ptgErr, "0.0") & " arcmin."
                Exit For                                        ' YES! All-Sky OK
            End If
            ' Got here, all-sky OK, loop will terminate on OFFSET_TRIES count
        End If
    Next
    '
    ' If failed, slew back and bail out.
    '
    If n > OFFSET_TRIES Then
        StartSlewJ2000 TargetName, RightAscension, Declination
        WaitForSlew
        TakePointingImage = False                               ' Failed
    Else
        TakePointingImage = True                                ' SUCCESS!
    End If

End Function

'----------------------------------------------------------------------------------------
' -------------
' TakePicture() - Acquire an image per the given specifications
' -------------
'
' Parameters:
'   Interval
'   Binning
'   Subframe
'   Dither
'   FilterNum       IMAGING filter, may be changed if ForPointing, MUST ALREADY BE IN c_selectedFilter!
'   FinalFile
'   ConfirmationFile
'   ForPointing     (If True, use pointing filter if FilterInfo, skips JPEG and compression)
'   ForceCal
'   Compress
'   SavePNG
'   ObserverName
'   TargetName
'   TargetRA
'   TargetDec
'   SlewNext        (If True, stops guider before slewing)
'   NextMPSource    (Elements, NEOCP, or "MP xxx" line for ephem update before slew)
'   NextName
'   NextRA
'   NextDec
'   RotNext
'   NextPA
'
' Returns:
'   True/False indicating whether SlewNext was True, AND actually succeeded.
'   Also returns True if SlewNext is False (we don't even NEED to slew). 
'
' If Interval is 0, it is a Bias frame, if < 0 it is a Dark frame. If the shutter has
' been closed by some outside source, and it is a light frame, abort.
'
' Updates properties for caller and ASP pages (via caller.SUP):
'   c_exposureInterval
'   c_exposureProgress
'   c_exposureActive
'   c_previewReady
'
' Readout Mode control: If this is a pointing image, the "fast" mode is used, otherwise
' the currently selected readout mode in c_curReadoutMode. 
'----------------------------------------------------------------------------------------
Function TakePicture(Interval, Binning, Subframe, Dither, FilterNum, FinalFile, _
                     ConfirmationFile, ForPointing, ForceCal, Compress, SavePNG, ObserverName, _
                     TargetName, TargetRA, TargetDec, SlewNext, NextMPSource, NextName, _
                     NextRA, NextDec, RotNext, NextPA)
    Dim StartTime, Timeout, CamStat, ExpType, MaxType, Bias, Doc, PScale, Buf, ActInterval, x
    Dim Camera, Console, Telescope, PtgPrefs, PL, simRA, simDec, simPA
    Dim i, j, dx, dy, ex, ey, gx, gy
    Dim EN, ED, ES, RotatorPA, GEMWasWest, Rollover, GuidedDither, GuiderRetryLimit
    Dim z1, z2, wasSlaved, wasTracking, pixFmt, RawFile, TestInterval, gps
    Dim CurRA, CurDec, useFilt, sra, sdec, workFile, W, CT, ExpStart, curLocale
    
    If Not c_userActions Is Nothing Then
        If Not c_userActions.ImageStart(Interval, Binning, Subframe, c_selectedFilter, ForPointing) Then
            Err.Raise vbObjectError, "UserAction", _
                    "**User action ImageStart() returned False"
        End If
    End If
    
    '
    ' If we're being asked to slew after imaging, we need to check to see if this is safe.
    ' This typically happens when a hardware weather system closes the shutter out from 
    ' under ACP. If the scope can't clear the closed dome, stop right here!
    '
    If SlewNext And Util.Dome.Available And Util.Dome.CanSetShutter And _
    		Not Util.Dome.ScopeClearsClosedDome Then  	            ' If slewing and dome and dome has shutter
        If Util.Dome.ShutterStatus <> 0 Then                        ' If the shutter is not open
            '
            ' This typically happens when a hardware weather system closes the shutter
            ' out from under ACP. Rather than try to figure out if its a roof, and whether
            ' the scope needs parking, and whether there are cal frames not needing skies 
            ' and ??? Just stop the acquisition process.
            '
            Err.Raise vbObjectError, "Dome Controller", _
                    "** Shutter or roof is closed and is a slewing hazard. Cannot continue."
        End If
    End If
    
    Set Camera = Util.ScriptCamera
    Set Telescope = Util.ScriptTelescope
    Set PtgPrefs = Util.Prefs.PointingUpdates
    Set Console = Util.Console
    
    wasTracking = True                                              ' Assume called with tracking on
    '
    ' ExpType: 0 = Light, 1 = Dark, 2 = Bias
    '
    If Interval = 0 Then
        ExpType = 2
        Console.PrintLine "  (taking bias frame, binning = " & Binning & ")"
        If c_haveReadoutModes Then 
            Camera.ReadoutMode = c_curReadoutMode
            Console.PrintLine "  (using " & ReadoutModeName(c_curReadoutMode) & " readout mode)"
        End If
        ''' (too fast, voice gets behind) Voice.Speak "Taking bias frame, binning " & Binning 
    Elseif Interval < 0 Then 
        ExpType = 1
        Interval = -Interval
        Console.PrintLine "  (taking " & Interval & " sec. dark frame, binning = " & Binning & ")"
        Voice.Speak "Taking " & Interval & " second dark frame, binning " & Binning 
        If c_haveReadoutModes Then 
            Camera.ReadoutMode = c_curReadoutMode
            Console.PrintLine "  (using " & ReadoutModeName(c_curReadoutMode) & " readout mode)"
        End If
        If Telescope.CanSetTracking Then
            wasTracking = Telescope.Tracking                        ' Allow caller to turn tracking off for multiple darks
            If wasTracking Then
                Console.PrintLine "  (turning tracking off for dark frame)"
                Telescope.Tracking = False
                Util.WaitForMilliseconds 1000           ' **TODO** Remove after this is done inside ACP
            End If
        End If
    Else
        ExpType = 0
        If c_haveFilters Then
            '
            ' Assert - This uses the selected filter in c_selectedFilter. I don't want to change the
            ' interface to TakePicture, so I just assert that FilterNum must be the same. This is 
            ' also a check for the convention that the filter number for the no-filter case is
            ' now 0 throughout. Check this only if we're going to actually USE a filter. Ignore
            ' any mismatch between c_selectedFilter and FilterNum for darks/biases.
            '
            If FilterNum <> c_selectedFilter Then
                Err.Raise vbObjectError, "AcquireSupport", _
                            "**Programmer error: Assert TakePicture() filter " & FilterNum & _
                            " not same as last SelectFilter() " & c_selectedFilter
            End If
            '
            ' Select appropriate filter and readout mode, for imaging or pointing
            '
            If ForPointing Then
                useFilt = SetFilterForTask(FO_FORPOINTING)
            Else
                useFilt = SetFilterForTask(FO_FORIMAGE)         ' Last filter set by SelectFilter
            End If
            Console.PrintLine "  (taking " & Interval & " sec. exposure, " & _
                    c_filterNames(useFilt) & " filter, binning = " & Binning & ")"
            Voice.speak "Taking " & Interval & " second exposure, " & _
                    c_filterNames(useFilt) & " filter, binning " & Binning
        Else
            Console.PrintLine "  (taking " & Interval & " sec. exposure, binning = " & Binning & ")"
            Voice.Speak "Taking " & Interval & " second exposure, binning " & Binning 
        End If
        '
        ' Set up readout mode accordingly
        '
        If c_haveReadoutModes Then
            If ForPointing Then
                Camera.ReadoutMode = c_fastReadoutMode
            Else
                Camera.ReadoutMode = c_curReadoutMode
            End If
            Console.PrintLine "  (using " & ReadoutModeName(Camera.ReadoutMode) & " readout mode)"
        End If
    End If
    
    '
    ' Set Binning & Subframe size
    '
    Camera.BinX = Binning                                       ' Set Binning
    Camera.BinY = Binning
    Camera.SetFullFrame                                         ' Start with full frame
    If Subframe < 1.0 Then                                      ' Set up Subframe if < 1.0
        Camera.NumX = (Camera.CameraXSize * Subframe) / Binning
        Camera.StartX = ((Camera.CameraXSize / Binning) - Camera.NumX) / 2.0
        Camera.NumY = (Camera.CameraYSize * Subframe) / Binning
        Camera.StartY = ((Camera.CameraYSize / Binning) - Camera.NumY) / 2.0
    End If
    '
    ' Guiding...
    '
    GuidedDither = False                                        ' Assume not doing guided dithering
    gps = Util.Prefs.AutoGuiding.SensorPlateScale               ' Make a local copy of guider plate scale
    If (ExpType = 0) And (Dither <> 0.0) Then
        If c_guiding Then
            If Dither = -1.0 Then 
                If gps > 0 Then
                    Dither = AUTO_UNGUIDED_DITHER
                Else
                    Dither = AUTO_GUIDED_DITHER
                End If
            End If
            '
            ' If the guider plate scale is available, convert given dither value
            ' from main imager pixels to guider pixels.
            '
            z1 = c_ScaleH
            If c_ScaleV < c_ScaleH Then z1 = c_ScaleV           '' Use smaller of two scales
            If gps > 0 Then 
                Console.PrintLine "  (converting dither " & Dither & " to guider pixels)"
                Dither = Dither * (z1 / gps)
            End If
            Console.PrintLine "  (dithering " & Util.FormatVar(Dither, "0.0") & " pixels std-dev on guider)"
            dx = Dither - UnifRand(2 * Dither)
            dy = Dither - UnifRand(2 * Dither)
            '
            ' Move the guide star for dithering, random distance from original
            ' MaxIm-selected position. This will generate a transient guiding
            ' error. We'll wait below for this to settle down. For the AO we
            ' also have to wait for another round of darkframes!
            '
            GuidedDither = True                                 ' Alters guider startup below
            gx = c_guideStarX + dx
            gy = c_guideStarY + dy
            Console.PrintLine "  (guided dither - moving guide star dx=" & _
                                                    Util.FormatVar(dx, "0.0") & " dy=" & _
                                                    Util.FormatVar(dy, "0.0") & " guider pixels"
            Camera.GuiderMoveStar gx, gy
            If c_HaveAOx Then                                   ' Another round of darks if Guidestar moves!
                x = c_guideExpCur * 10
                Console.PrintLine "  (AO - waiting " & x & " sec for new dark frames...)"
                Util.WaitForMilliseconds (x * 1000)
            End If    
        Else
            If Dither = -1.0 Then Dither = AUTO_UNGUIDED_DITHER
            dx = Dither - UnifRand(2 * Dither)
            dy = Dither - UnifRand(2 * Dither)
            Console.PrintLine "  (unguided dither - moving field dx=" & _
                                                    Util.FormatVar(dx, "0.0") & " dy=" & _
                                                    Util.FormatVar(dy, "0.0") & " pixels"
            '
            ' Unguided, random pixel distance from INITIAL scope position. Cannot use Target
            ' RA/Dec here! May have offset for model or TPOINT (unsyncable scope). Last-Slew
            ' position unreliable, so we'll use the current J2000 scope coordinates as the base.
            '
            If Util.Prefs.DoLocalTopo Then
                Call LocalTopocentricToJ2000(Util.ScriptTelescope.RightAscension, Util.ScriptTelescope.Declination)
                sra = c_J2000RA
                sdec = c_J2000Dec
            Else
                sra = Util.ScriptTelescope.RightAscension
                sdec = Util.ScriptTelescope.Declination
            End If
            Console.PrintLine "  (unguided dither " & Dither & " pixels std-dev, doing small slew)"
            EquOffset sra, sdec, dx * c_ScaleH / 60.0, dy * c_ScaleV / 60.0
            StartSlewJ2000 "dither", c_equOffsetRA, c_equOffsetDec
            WaitForSlew
        End If
    End If
    '
    ' Monitor guider errors, even if taking dark/bias frame
    '
    i = 0                                                       ' Counts reps in this loop
    j = 0                                                       ' Counts successive good measurements 
                                                                ' for guided dither startup
    If GuidedDither Then GuiderRetryLimit = 50 Else GuiderRetryLimit = 20   ' Allow more loops for guided dithering
    Do While (ExpType = 0 ) And c_guiding
        If Not GetGuiderMeasurement(ex, ey) Then                ' Also checks GuiderRunning
            c_guiding = False
            TakePicture = False
            ' WARNING! DO NOT CHANGE THE TEXT OF THIS MESSAGE - USED BY ACQUIREIMAGES!
            Err.Raise vbObjectError, "MaxIm.CCDCamera", _
                        "**Guider stopped or lost star just before image acquisition"
        Else                                                    ' At least guider is running and tracking
            '
            ' Monitor guide errors. Both > 0 and < c_guideErrMax 
            ' means success (0 = "star faded", which should have 
            ' been caught above!) Just wait for one good measurement.
            ' I could do averaging here, but that would be guaranteed 
            ' to chew up time, at least the number of cycles over
            ' which the average or RMS would be take. Instead, just press
            ' on as soon as one good measurement is taken. HOWEVER
            ' if doing guided dithering, then we do need to wait for 
            ' several guider cycles since MaxIm takes time to do the 
            ' move of the guide star. This is better than just waiting 
            ' some fixed time!
            '
            ex = Abs(ex)    
            ey = Abs(ey)
            Console.PrintLine "  (ex=" & Util.FormatVar(ex, "0.00") & " ey=" & Util.FormatVar(ey, "0.00") & ")"
            If (ex > 0.0 Or ey > 0.0) And ex <= c_guideErrMax And ey <= c_guideErrMax Then
                If GuidedDither Then                            ' Guided dither...
                    j = j + 1                                   ' ... count this as a good measurement
                    Console.PrintLine "  (guided dither, " & j & " good cycles)"
                Else                                            ' No guided dither, 1 good one is enough
                    If i > 0 Then Console.PrintLine "  (guiding errors within limits)"   ' Report only if retrie(s)
                    Exit Do                                     ' Good guide measurement, press On
                End If
            Else
                j = 0                                           ' Reset successive-good counter 
                Console.PrintLine "  (guider error n/a or too high, try #" & (i + 1) & ")"
            End If
            If GuidedDither And j >= 5 Then Exit Do             ' Guided dithering requires 5 successive good
            i = i + 1
            If i >= GuiderRetryLimit Then                       ' If doesn't get started after retry limit
                Call AutoGuide(False)                           ' Stop the guider now, hopeless
                TakePicture = False                             ' Fail the image acquisition with Error
                ' WARNING! DO NOT CHANGE THE TEXT OF THIS MESSAGE - USED BY ACQUIREIMAGES!
                Err.Raise vbObjectError, "MaxIm.CCDCamera", _
                            "**Excessive guiding errors just before image acquisition"
            End If
        End If
    Loop
    If c_guiding Then
        Console.PrintLine "  (guider check OK)"
    End If
    '
    ' Save the image-time RA, Dec, pier side and rotator PA for FITS header
    '
    If Telescope.AlignmentMode = 2 Then
        GEMWasWest = Util.GEMWestOfPier                         ' Save this image's GEM-west value
    End If
    If c_haveRotator Then
        RotatorPA = ROT.Position                                ' Save this image's raw rotator PA for later FITS
    End If
	CurRA = Telescope.RightAscension							' Also need image-time scope position for FITS/Airmass
	CurDec = Telescope.Declination

    '
    ' Start the exposure
    '
    If PtgPrefs.Simulate And c_simImageTimeCompress Then 
        ActInterval = Interval / 10                             ' 10x rate for simulation
    Else 
        ActInterval = Interval
    End If
    c_exposureInterval = Interval
    c_exposureProgress = 0.0
    c_exposureActive = True
    If Util.Prefs.DisableSlewOverlap Then                       ' If user doesn't want overlapped slew/download
        Util.WaitForMilliseconds 200                            ' Try to let expose light turn On
        Util.UserInterfaceLive = False                          ' Must put ACP UI to sleep for expoure AND download :=((
    End If
    '
    ' Shoot both darks and biases in MaxIm "dark" mode, so setups
    ' with "filter as shutter" will obscure the chip for both!
    '
    If ExpType = 0  Then                                        ' Real light frame?
        MaxType = 1                                             ' Put MaxIm into "light" mode
    Else                                                        ' Otherwise...
        MaxType = 0                                             ' MaxIm "dark" mode
    End If
    wasSlaved = Util.Dome.Slaved                                ' Safe for no dome
    If wasSlaved And Not Util.Dome.SlaveWhileImaging Then Util.Dome.Slaved = False   ' Disable slaving while imaging
    If Not Camera.Expose(ActInterval, MaxType, useFilt) Then
        c_exposureActive = False
        Util.Dome.Slaved = wasSlaved
        Call put_DefocusCount(0)
        TakePicture = False
        Err.Raise vbObjectError, "MaxIm.CCDCamera", _
                    "**Failed to start the exposure"
    End If
''  Trace "[tkpic] Exposure request OK"

    '
    ' Here we wait for the exposure to actually start. If the camera has RBI pre-flash
    ' this could be a significant time! We watch the camera status until it is idle or
    ' in one of the "exposing" states. Starts with 2=Idle, then 9=Waiting, then 3/11/12
    ' (one of the exposing)
    '
    CamStat = Camera.CameraStatus
    If ActInterval > 1.0 Then                                   ' Avoid timing hole for really short exposures
''      Trace "[tkpic] StartWait - STAT = " & CamStat
        While CamStat <> 3 And CamStat <> 11 And CamStat <> 12    ' Any of the non-exposing status
''          Trace "[tkpic] InitialWait - STAT = " & CamStat 
            Util.WaitForMilliseconds 500
            CamStat = Camera.CameraStatus
        Wend
    End If
    Console.PrintLine "  (starting exposure)"
    
    '
    ' Wait QUIETLY until the shutter should be closed, then start calling MaxIm
    ' checking to see that it is. This is really shameful, but some of those
    ' damn imagers are so fragile to CPU activity... Set values for ASP page
    ' progress bar. The WaitForMilliseconds call is not that accurate, and 
    ' can run long, so back it off by 10%
    '
    Timeout = Interval + 120                                    ' Sanity timer
    StartTime = Now
    Do While CamStat = 3 Or CamStat = 12                        ' While exposing Light or Dark (not Bias, div by zero!)
        c_exposureRemain = CInt(ActInterval - (CDbl(Now - StartTime) * 86400.0))
        c_exposureProgress = (ActInterval - c_exposureRemain) / ActInterval
        If PtgPrefs.Simulate And c_simImageTimeCompress Then
            Timeout = Timeout - 10                              ' 10x rate for simulation
        Else
            Timeout = Timeout - 1
        End If
''      Trace "[tkpic] Looping - REM = " & c_exposureRemain & " PRG = " & c_exposureProgress & " STAT = " & Camera.CameraStatus
        If Timeout <= 0 Then Exit Do
        If Util.Prefs.DisableSlewOverlap Then
            If Camera.ImageReady Then Exit Do
        Else
            If Camera.ReadyForDownload Then Exit Do
        End If
        Util. WaitForMilliseconds 1000
    Loop
''  Trace "[tkpic] End exposure - REM = " & c_exposureRemain & " PRG = " & c_exposureProgress & " STAT = " & Camera.CameraStatus
    If Timeout = 0 Then                                         ' Timed out, failed
''      Trace "[tkpic] Timed out (int + 120) before completing exposure"
        c_exposureProgress = 0.0
        c_exposureRemain = 1.0
        c_exposureActive = False
        Util.Dome.Slaved = wasSlaved
        Call put_DefocusCount(0)
        On Error Resume Next
        Camera.AbortExposure                                    ' Try to recover the camera for  the next image
        Camera.StartDownload
        On Error GoTo 0
        Util.WaitForMilliseconds 1000
        TakePicture = False
        Err.Raise vbObjectError, "MaxIm.CCDCamera", _
                "**Exposure failed after being successfully started"
    End If
    Console.PrintLine "  (exposure complete)"
    c_exposureProgress = 1.0
    c_exposureRemain = 0.0
    c_exposureActive = False

    If Not Util.Prefs.DisableSlewOverlap Then                   ' Normal overlap... (AutoDownload has been set to False)
        '
        ' If SlewNext flag is set, start slew to next target now.
        ' THIS CHANGES c_SimImageRA/Dec!!
        '
        simRA = c_simImageRA                                    ' Make copies of sim image position!
        simDec = c_simImageDec                                  ' (upcoming slew changes c_simImageRA/Dec)
        simPA = c_simImagePA                                    ' (upcoming rotation changes c_simImagePA too!)
        
        TakePicture = False                                     ' Assume we aren't post-slewing
        If SlewNext Then                                        ' Going to try slew now...
            Console.PrintLine "  (can pre-slew to next target)"
            Util.Dome.Slaved = wasSlaved                        ' Re-slave now!

            '
            ' If this is a minor planet (NextMPSource <> "") then we need to 
            ' recalculate the bloody ephemeris. It's OK that we change the by-ref
            ' parameters to this function, they are the latest coordinates anyway!
            '
            If NextMPSource <> "" Then
                If Not CalcEphemeris(NextMPSource, NextName, NextRA, NextDec, z1, z2) Then ' Catch junk source
                    Call put_DefocusCount(0)
                    Err.Raise vbObjectError, "Slew-ahead failed, next target MP data unusable.", "ACP.AcquireSupport"
                End If
            End If
            '
            ' Last minute check for observatory limits. This just shrinks the window
            ' and the StartSlew still has a (tiny) chance of failing from the target
            ' setting in the west. Thus, we also make slew failures for the limit
            ' errors fatal. WARNING: DEPENDS ON ACP ERROR NUMBERS.
            '
            On Error Resume Next
            Call  Util.EnforceSlewLimits(NextRA, NextDec)
            If Err.Number = 0 Then                              ' But this just shrinks the timing window
                Err.Clear                                       ' Get ready for possible slew failure
                StartSlewJ2000 NextName, NextRA, NextDec        ' Start the slew (stops guider and offset tracking)
                EN = Err.Number                                 ' Save any error info from slew
                ED = Err.Description
                ES = Err.Source
                On Error Goto 0                                 ' Back to fatal errors, clears error onfo
                Select Case EN                                  ' Depending on Err.Number
                    Case 0:                                     ' Success!
                        Util.WaitForMilliseconds 1000           ' Allow slew to start before camera grabs CPU!
                        TakePicture = True                      ' We did post slew
                    Case &H80040004:                            ' Below minimum elevation
                    Case &H80040404:                            ' Another of these
                    Case &H80040005:                            ' Below configured horizon
                    Case &H80040006:                            ' Above tilt-up limit
                    Case Else:                                  ' Serious scope error
                        Call put_DefocusCount(0)
                        Err.Raise EN, ES, ED                    ' Re-signal the error
                End Select
            Else
                On Error Goto 0
            End If
        Else
            TakePicture = True                                  ' Didn't need to slew, so we're OK
        End If
        If c_haveRotator Then                                   ' If we have rotator
            If RotNext Then StartRotateToPA NextPA, NextRA      ' If requested, start rotation to next PA
        End If
        '
        ' Re-up the timeout and start the image download.
        ' Camera.ImageReady indicates that downloading is complete.
        '
''      Trace "[tkpic] Start async image download..."
        Util.UserInterfaceLive = False                          ' Put ACP UI to sleep for download only
        Camera.StartDownload
    End If
    '
    ' Wait till the image has been downloaded. If overlapping it
    ' should already be done!
    '
    Timeout = 120                                               ' Huge timeout on this
    Do While Not Camera.ImageReady
''      Trace "[tkpic] Wait for image to download..."
        Util.WaitForMilliseconds 1000
            Timeout = Timeout - 1
        If Timeout <= 0 Then Exit Do
    Loop
''  Trace "[tkpic] Image downloaded"
    If Util.Prefs.DisableSlewOverlap Then                       ' Overlap disabled, need to clean some things up
        c_exposureProgress = 1.0                                ' Finally 100% thermometer
        c_exposureActive = False
        TakePicture = True                                      ' Act like post-slew succeeded if requested (won't be, but)
        simRA = c_simImageRA                                    ' Make copies of sim image position!
        simDec = c_simImageDec
        simPA = c_simImagePA                                    ' Same with sim position angle
    End If
    Util.WaitForMilliseconds 1000                               ' Give MaxIm time to restart guider (McMillan)
    If Timeout <= 0 Then                                        ' Timed out, failed
        Util.Dome.Slaved = wasSlaved
        Call put_DefocusCount(0)
        TakePicture = False
        Err.Raise vbObjectError, "MaxIm.CCDCamera", _
                    "**Exposure timed out waiting for ImageReady."
    End If
    Util.UserInterfaceLive = True                               ' Wake ACP UI back up
    Util.Dome.Slaved = wasSlaved                                ' Harmless if re-slaved above for overlapped slew
    Console.PrintLine "  (exposure complete and image downloaded)"
    Voice.Speak "Image acquired and downloaded."
    '
    ' If Auto-Calibrate flag is set and it's a final image, or if the 
    ' AutoCalpointing flag is set and it's a pointing image, do the 
    ' calibration now. Use the ACP\Calibration images per the comments
    ' above. Skip this for dark frames..
    '
    pixFmt = 1                                                  ' Assume no cal, save image as uint-16
    If (ExpType = 0) And _
            ((Util.Prefs.CameraPrefs.AutoCalibrate Or ForceCal) And Not ForPointing) Or _
            (Util.Prefs.CameraPrefs.AutoCalPointing And ForPointing) Then 
        Console.PrintLine "  Calibrating image..."
        Voice.Speak "Calibrating image."
        '
        ' For final images, save a copy of the uncalibrated file as RAW-<filename>
        '
        If Util.Prefs.CameraPrefs.AutoCalSaveRaw And Not ForPointing Then  ' Save raw image
            RawFile = FSO.GetParentFolderName(FinalFile) & "\RAW" ' Get path to final file, add RAW subfolder
            CreateFolder rawFile, False                         ' Make sure that subfolder exists
            RawFile = RawFile & "\RAW-" & FSO.GetFileName(FinalFile)
            If PtgPrefs.Simulate  Then
                SimulateImage simRA, simDec, simPA, Interval, MaxType, RawFile & ".fts", 1
            Else
                Camera.Document.SaveFile CStr(RawFile & ".fts"), 3, False, 1 ' CStr() should not be needed :-)
            End If
        End If
        On Error Resume Next                                    ' Cal failures are non-fatal
        Call Camera.Calibrate
        If Err.Number <> 0 Then
            Console.PrintLine "**Calibration failed. Original image saved."
            Console.PrintLine "**MaxIm reports " & Err.Description
            If FSO.FileExists(RawFile) Then FSO.DeleteFile(RawFile)  ' Don't need RAW file
        Else
            If Not ForPointing Then pixFmt = 3                  ' Save cal'd final images as FP-32
        End If
        On Error GoTo 0
    End If
    '
    ' Save the image (and rotate 180 deg if no rotator and GEM West) or if 
    ' simulating, replace with simulated image and save. Use the offset 
    ' coordinates calculated by the last slew command. WE MUST DELETE OLD 
    ' CACHED STARS FILE!!!!
    '
    ' As of ACP6 we make this process DropBox-friendly. To avoid race condition
    ' with DropBox sync, we save the image as a temp file, then open it in 
    ' PinPoint to add info, detach, then move it into the final path/name.
    '
    If Not forPointing Then
        workFile = FSO.GetSpecialFolder(2).Path & "\" & FSO.GetBaseName(FSO.GetTempName()) & ".fts" ' 2 = temporary folder path
    Else
        workFile = FinalFile & ".fts"
    End If
    On Error Resume Next
    FSO.DeleteFile workFile & ".stars"
    On Error Goto 0
    Rollover = False                                            ' Assume not going to roll over for stacking
    If PtgPrefs.Simulate Then                                   ' If simulating images (don't rotate for GEM)
        SimulateImage simRA, simDec, simPA, Interval, MaxType, workFile, pixFmt  ' This saves it to disk
    Else
        If Not c_haveRotator And Util.GEMWestOfPier And _
                Not Util.Prefs.DisableGEMImageFlip And _
                ExpType = 0 Then                                ' If no rotator, GEM, west of pier, and light image
            Camera.Document.Flip                                ' Rotate so image stacking will work!
            Camera.Document.Mirror                              ' (this way guarantees pixel integrity)
            Rollover = True                                     ' We rolled it in software (add FITS field below)
        End If
        Camera.Document.SaveFile workFile, 3, False, pixFmt ' CStr() should not be needed :-)
    End If
'   === FOR DATA IMAGES LEAVE THIS WINDOW OPEN - PEOPLE LOOK AT IT ===
    If forPointing Then _
        Camera.Document.Close                                   ' Close this pointing image window
''- Trace "  FITS image file saved to work/temp file"
    Camera.SetFullFrame                                         ' Restore full frame Now
    If Util.Prefs.DisableSlewOverlap Then                       ' If we didn't overlap slew above, and need to slew
    	CurRA = Telescope.RightAscension						' Save for later FITS/Airmass
    	CurDec = Telescope.Declination
	    If Telescope.AlignmentMode = 2 Then
	        GEMWasWest = Util.GEMWestOfPier                     ' Save this image's GEM-west value for later FITS
	    End If
        If SlewNext Then StartSlewJ2000 NextName, NextRA, NextDec   ' Start the slew (stops guider and offset tracking)
        If c_haveRotator Then                                   ' If we have rotator
            RotatorPA = ROT.Position                            ' Save this image's raw rotator PA for later FITS
            If RotNext Then StartRotateToPA NextPA, NextRA      ' If requested, start rotation to next PA
        End If
    End If
    If (ExpType = 0) Then                                       ' Don't do this for darks or bias frames...
        '
        ' Add FITS keywords. Some are added only if not there (MaxIM set these)
        '
        Set PL = CreateObject("PinPoint.Plate")
        PL.AttachNoImage workFile                               ' Fast attach, no image array
        On Error Resume Next
        buf = PL.Observatory                                    ' Raises excep if not set (typ)
        If Err.Number <> 0 Or Trim(buf) = "" Then  PL.Observatory = Util.Prefs.SiteName
        Err.Clear                                               ' Reset any exception (typ)
        buf = PL.Observer
        If Err.Number <> 0 Or Trim(buf) = "" Then  PL.Observer = ObserverName
        Err.Clear
        buf = PL.Telescope
        If Err.Number <> 0 Or Trim(buf) = "" Then PL.Telescope = Telescope.Name
        Err.Clear
        buf = PL.Camera
        If Err.Number <> 0 Or Trim(buf) = "" Then PL.Camera = Util.Prefs.CameraPrefs.Name
        Err.Clear
        If c_haveFilters Then
            buf = PL.FilterName
            If Err.Number <> 0 Or Trim(buf) = "" Then PL.FilterName = c_filterNames(c_selectedFilter)
        End If
        On Error Goto 0
        PL.AirMass = AirMass(CurRA, CurDec)
        PL.SiteElevation = Telescope.SiteElevation
        PL.SiteLatitude = Telescope.SiteLatitude
        PL.SiteLongitude = Telescope.SiteLongitude
        PL.TargetName = TargetName
        PL.TargetRightAscension = TargetRA
        PL.TargetDeclination = TargetDec
        '
        ' These are not supported by PinPoint
        '
        ExpStart = CDate(PL.ExposureStartTime - (Util.SysUTCOffset / 24.0))
        PL.WriteFITSDouble "JD-OBS", Util.Date_Julian(ExpStart), 7
        PL.WriteFITSDouble "HJD-OBS", HJD(Util.Date_Julian(ExpStart), TargetRA, TargetDec, False), 7
        PL.WriteFITSDouble "BJD-OBS", HJD(Util.Date_Julian(ExpStart), TargetRA, TargetDec, True), 7
        PL.SiderealTime = Util.Date_GMST(ExpStart) + Telescope.SiteLongitude / 15 ' WAS Telescope.SiderealTime
        Set CT = Util.NewCT(Telescope.SiteLatitude, PL.SiderealTime)
        CT.RightAscension = TargetRA
        CT.Declination = TargetDec
        PL.WriteFITSDouble "OBJCTAZ", CT.Azimuth, 4
        PL.WriteFITSDouble "AZIMUTH", CT.Azimuth, 4
        PL.WriteFITSDouble "OBJCTALT", CT.Elevation, 4
        PL.WriteFITSDouble "ALTITUDE", CT.Elevation, 4
        curLocale = GetLocale()
        SetLocale "en-us"                                       ' Prevent , decimals in FITS
        buf = Util.Hours_HMS(Util.HourAngle12(TargetRA, PL.SiderealTime),  " ", " ", "", 2)
        SetLocale curLocale
        PL.WriteFITSString "OBJCTHA", buf
        PL.WriteFITSString "HA", buf
        Set CT = Nothing                                        ' Release the CT right now
        If Telescope.AlignmentMode = 2 Then                     ' Only if this is a GEM
            If GEMWasWest Then                                  ' Write the imaging time pier side
                PL.WriteFITSString "PIERSIDE", "EAST"           ' Add pier-side indication (reversed from our convention!)
            Else
                PL.WriteFITSString "PIERSIDE", "WEST"
            End If
        End If
        If Rollover Then 
            PL.WriteFITSString "IMGROLL", "Y"                   ' Add software rollover indicator to FITS
        Elseif c_haveRotator Then                               ' Never does rollover if rotator installed
            PL.WriteFITSDouble "ROT_PA", RotatorPA, 1           ' Add raw rotator PA (saved above) to FITS
        End If
        If c_haveReadoutModes Then
            PL.WriteFITSString "READMODE", ReadoutModeName(Camera.ReadoutMode)
        End If
        Set W = Util.Weather
        If W.Available Then                                     ' Write new weather fields that are available
            On Error Resume Next
            x = W.AmbientTemperature
            If Err.Number = 0 Then 
                PL.WriteFITSDouble "AMBTEMP", x, 1
                PL.Temperature = x
            End If 
            Err.Clear
            x = W.RelativeHumidity * 100.0
            If Err.Number = 0 Then PL.Humidity = x
            Err.Clear
            x = W.DewPoint
            If Err.Number = 0 Then PL.WriteFITSDouble "DEWPOINT", x, 1
            Err.Clear
            x = W.WindVelocity
            If Err.Number = 0 Then PL.WriteFITSDouble "WINDSPD", x, 0
            Err.Clear
            x = W.WindDirection
            If Err.Number = 0 Then PL.WriteFITSDouble "WINDDIR", x, 0
            Err.Clear
            x = W.SkyTemperature
            If Err.Number = 0 Then PL.WriteFITSDouble "SKYTEMP", x, 1
            Err.Clear
            x = W.BarometricPressure
            If Error.Number = 0 Then PL.Pressure = x
            Err.Clear
            x = W.Name
            If Err.Number = 0 Then PL.WriteFITSString "WXSENSOR", x  
            Err.Clear
        End If
        PL.UpdateFITS
        PL.DetachFITS
        Set PL = Nothing
''-     Trace "  Additional FITS headers added by PinPoint"
    End If
    '
    ' We're finished with this image, so now is the time to move/rename
    ' to its final place. We cannot mess with it now, if it is in a DropBox
    ' folder.
    '
    If Not ForPointing Then
''-     Trace "  File moved to final path/name"
        FSO.MoveFile workFile, FinalFile & ".fts"
    End If
    '
    ' Call custom action here before exiting
    '
    If Not c_userActions Is Nothing Then
        If Not c_userActions.ImageEnd(FinalFile & ".fts") Then
            Err.Raise vbObjectError, "UserAction", _
                    "**User action ImageEnd() returned False"
        End If
    End If
    Console.PrintLine "  Image finished"
    Voice.Speak "Image finished."
    
    '
    ' If pointing exposure, skip everything else
    '
    If ForPointing Then    
        Exit Function                                           ' Return value already set
    End If
    '
    ' Save PNG preview and confirmation images, if requested. In both
    ' cases, honor the quirk in MaxIm where single-shot color images will
    ' end up with cross-hatching if the reduced dimensions are not such
    ' that the original image x-width is an integral multiple of the 
    ' final x-width. For example, for a 1600 pix original width, 400
    ' pixels works (1600 = 4 * 400) but 512 does not! In 5.1.15 this
    ' is optional.
    '
    If SavePNG Then
        Util.Console.PrintLine "*** OBSOLETE CODE CALLED - PLEASE CONTACT DC-3 DREAMS ***"
    End If
    
    If ConfirmationFile <> "" Then                              ' If requested, save thumbnail previews
        Set Doc =  CreateObject("MaxIm.Document")
        Doc.OpenFile FinalFile & ".fts"
        If CROSSHATCH_SCALING Then
            ' Emulate 'ciel' function
            PScale = Fix(Doc.XSize / 128) + 1                   ' Honor cross-hatch limitation
            If Doc.XSize >= 128 And CInt( Doc.XSize / 128) = Doc.XSize / 128 Then PScale = PScale - 1   ' Catch edge condition
        Else
            PScale = Doc.XSize / 128.0
        End If
        Doc.Resize (Doc.XSize / PScale), (Doc.YSize / PScale)
        Doc.KernelFilter 5, 20
        Doc.DDP 0, true, true, 0, 0, 100
        Doc.RemoveGradient
        Doc.SaveFile ConfirmationFile, 7, True, 0               ' Scaled, 8-bits/pix, PNG
''-     Trace "  Web confirmation image file saved"
        c_previewReady = True
        On Error Resume Next
        Doc.Close                                               ' Close for MaxIm V4 only
        On Error Goto 0
        Util.WaitForMilliseconds 500                            ' [BUG/WORKAROUND] See 25-Oct-2004 edit track
        Set Doc = Nothing                                       ' Release to close window
    End If

    '
    ' If compression requested, do it
    '
    If Compress Then 
        Util.CompressFile FinalFile & ".fts", FinalFile & ".fts.zip"
''-     Trace "  Image file ZIP-compressed for net transfer"
    Else
        On Error Resume Next
        FSO.DeleteFile FinalFile & ".fts.zip"                   ' Delete fossils
        On Error GoTo 0
    End If
    
    ' Return value already set
    '
    ' Dark frames run with tracking off. Restore tracking to state
    ' when we were called if this was a dark.
    '
    If ExpType = 1 And Telescope.CanSetTracking And wasTracking Then
        If Interval < 5 Then Util.WaitForMilliseconds CLng((5.0 - Interval) * 1000.0) ' Assure min 5 sec track off to on (Paramount)
        Console.PrintLine "  (turning tracking on after dark frame)"
        Telescope.Tracking = True
        Util.WaitForMilliseconds 1000                           ' **TODO** Remove after this is done inside ACP
    End If
End Function


'----------------------------------------------------------------------------------------
' -----------
' AutoGuide() - Start/Stop the guider (must already be calibrated)
' -----------
'
' Returns immediate success if want guiding and guider is already running
' or turning guider off and is already off.
'
' NOTE:  Turns off offset tracking if in effect.
'----------------------------------------------------------------------------------------
Function AutoGuide(State)
    Dim Camera, Console, guiderDec, guiderAngle, prevExp, OAG, buf
    Dim i, j, ex, ey, z

    Set Camera = Util.ScriptCamera
    Set Console = Util.Console
    
    If State Then
        If get_GuiderRunning Then                               ' If already running (AO Check here!)
            Console.PrintLine "  (autoguider still running...)"
            c_guiding = True                                    ' Just for grins
            AutoGuide = True                                    ' Success...
            Exit Function                                       ' DONE - GUIDING
        End If
        ' If get here, fall thru to guider startup below
    Else                                                        ' Stop guiding
        If Camera.GuiderRunning Then                            ' If it is running (hardware check)
            Camera.GuiderStop                                   ' Shut down the guider
            While Camera.GuiderRunning                          ' Make sure it's stopped before returning
                Util.WaitForMilliseconds 500                    ' (next operation may be a slew)
            Wend
            Console.PrintLine "  (stopping  the autoguider)"
            Voice.Speak "Stopping autoguider."
        Else
            if c_Guiding Then Console.PrintLine "  (**autoguider stopped on its own)"
        End If
        c_guiding = False                                       ' Must always clear our state flag
        ClearAGHistory                                          ' For ACP web UI, no more graph
        AutoGuide = True                                        ' Success...
        Exit Function                                           ' DONE - GUIDER STOPPED
    End If
    '
    ' We're starting guiding...
    '
    '
    ' Guider needs filter NOW! We can't wait till it's changed in TakePicture()
    '
    SetFilterForTask(FO_FORIMAGE)                               ' Last filter set by SelectFilter
                            
    Voice.Speak "Starting auto guider."
    If c_TrackOffset Then                                       ' Cancel offset tracking
        Call SetTrackOffset(0.0, 0.0)
    End If
    If c_guideDecComp Then                                      ' If wants dec compensation
        guiderDec = Util.ScriptTelescope.Declination            ' Get scope declination
        If Abs(guiderDec) > 79.0 Then                           ' Limit for MaxIm's guider 
            guiderDec = Sgn(guiderDec) * 79.0
            Console.PrintLine "  ** Using MaxIm max guide declination of " & guiderDec & " deg."
        End If
    Else
        guiderDec = 0.0                                         ' Dec compensation disabled
    End If
    '
    ' ------------------------
    ' Exposure adjustment Loop
    ' ------------------------
    '
    c_guideExpCur = Util.Prefs.AutoGuiding.TrackingExposureInterval    ' Start with exposure from prefs
    For i = 0 To 3                                              ' Try 4 times to get exposure adjusted
        '
        ' Select the guide star and get the optimum guider interval
        '
        Console.PrintLine "  (take guider image at initial interval " & c_guideExpCur & " sec)"
        c_guideExpCur = SetupGuider(True, c_guideExpCur, False) ' Get a guess as to optimal exposure
        If c_guideExpCur = -1 Then                              ' Failed to find usable stars
            Console.PrintLine "**No usable stars in guider image; trying again at max guider exposure"
            c_guideExpCur = SetupGuider(True, c_guideExpMax, False)   ' Try once more at max interval
            If c_guideExpCur = -1 Then                          ' If -that- failed...
                Console.PrintLine "**No usable stars at max guider exposure interval, can't guide"
                Exit For                                        ' === EXIT WITH FAILURE ===
            End If
        End If
        Console.PrintLine "  (first exposure estimate " & c_guideExpCur & " sec)"
        c_guideExpCur = SetupGuider(False, c_guideExpCur, False)   ' Get a refined guess as to optimal exposure
        If c_guideExpCur = -1 Then                                  ' If -that- failed...
            Console.PrintLine "**No usable stars this time, must be extremely weak, giving up."
            Exit For                                                ' === EXIT WITH FAILURE ===
        Else
            Console.PrintLine "  (final exposure for guiding " & c_guideExpCur & " sec)"
            SetupGuider False, c_guideExpCur, True                  ' Final for Simple AutoDark, save previews
        End If
        '
        ' We MUST wait to set polarity switches till here (MaxIm quirk)
        '
        Camera.GuiderDeclination = guiderDec                    ' Limited to +/- 79 deg. or 0 if disabled in prefs
        If Not Util.Prefs.PointingUpdates.Simulate Then         ' This doesn't apply if sim guider
            '
            ' Rotated internal/OAG imager is special. Note that we may be manually
            ' rotating as well, and get_RotatorPositionAngle() will pick up the last
            ' solve PA so this will still work here!
            '
            If Not c_guideExtern Then 
                If Not c_haveRotator Then
                    Console.PrintLine "  No rotator - assuming manual rotation of camera"
                End If
                guiderAngle = get_RotatorPositionAngle()        ' Get this even if no rotator (manual rotation!)
                OAG = (c_guideSensorType = 2)                       
                buf = "  PA=" & CInt(guiderAngle)               ' Log before adding OAG bias
                If OAG Then
                    buf = buf & " (off-axis"
                Else
                    buf = buf & " (internal"
                End If
                buf = buf & " guider @ " & Util.FormatVar(c_guideSensorAngle, "0.0") & " deg)"
                Console.PrintLine buf
                If Util.Prefs.AutoGuiding.ReverseYonFlip Then _
                    Console.PrintLine "  Mount reverses Y guiding signal on flip"
                
                '
                ' Take care of reflection difference here, simply (but a brain burner)
                ' Due to my having established the "calibrate looking east" convention
                ' (ugh), we have to reverse the guiding angle unless it *IS* an OAG. 
                ' Note the sign here ---------
                '                            |
                '                            V
                If OAG Then 
                    guiderAngle = RangeAngle(+(guiderAngle + c_guideSensorAngle), -180, 180)
                Else
                    guiderAngle = RangeAngle(-(guiderAngle + c_guideSensorAngle), -180, 180)
                End If 
                Console.PrintLine "  Guide angle is " & Util.FormatVar(guiderAngle, "0.0") & " deg."
                
                If c_haveAOx Then                               ' For AO...
                    SetupAOBumping guiderAngle, OAG             ' In the AcquireSupportJS section
                Else
                    Camera.GuiderAngle = guiderAngle            ' Tell the guider the angle to use per above
                    '
                    ' On west, the only effect is to reverse Dec motion, since the
                    ' imager is NOT rolled over (rotator rolled it back after flip).
                    ' Hence, we need to reverse Y, but only if the mount controller 
                    ' doesn't already do it!! See ACP-626 and related tickets.
                    '
                    If Util.Prefs.AutoGuiding.ReverseYonFlip Then   ' If the mount does the reverse
                        Camera.GuiderReverseY = False               ' Never do it in MaxIm's guider servo
                    Else                                            ' Raw guiding (shaft rotations)
                        Camera.GuiderReverseY = Util.GEMWestOfPier  ' Reverse Y if west
                    End If
                End If
            Else                                                ' Unrotated internal or external?
                '
                ' Unrotated guider (angle calibrated and constant)...
                ' On west, effect is to reverse Dec motion, which reverses Y, 
                ' combined with the imager being rolled over 180 deg, which 
                ' reverses both X and Y. The net effect is just reverse X 
                ' (reverse Ys cancel out!)... unless the mount does a reverse
                ' Y on flip... in which case we need to re-reverse that too. 
                ' (more brain burning)
                '
                Camera.GuiderReverseX = Util.GEMWestOfPier      ' Reverse X if west
                If Util.Prefs.AutoGuiding.ReverseYonFlip Then
                    Camera.GuiderReverseY = Util.GEMWestOfPier
                End If
            End If
        End If
        '
        ' Start the guider
        '
        On Error Resume Next                                    ' Prevent hard error here!
        If Camera.GuiderTrack(c_guideExpCur) Then               ' (guider throws if can't start)
            On Error Goto 0                                     ' Trap errors again...
            Camera.GuiderMoveStar c_guideStarX, c_guideStarY    ' Force MaxIm sub-pixel positioning
            If c_HaveAOx Then                                   ' If AO-x, allow for 10 darks at start
                z = c_guideExpCur * 10
                Console.PrintLine "  (wait " & z & " sec for AO startup darkframes...)"
                Util.WaitForMilliseconds (z * 1000)
            End If
            If GetGuiderMeasurement(ex, ey) Then                ' If guider looks healthy
                ' --------------------
                ' Guider settling loop
                ' --------------------
                '
                For j = 0 To 19                                 ' Wait for up to 20 cycles
                    If Not GetGuiderMeasurement(ex, ey) Then    ' Dang! Guider stopped or lost star
                        Exit For                                ' === EXIT WITH FAILURE ===
                    End If
                    '
                    ' Monitor guide errors. Both > 0 and < c_guideErrMax 
                    ' means success (0 = "star faded")
                    '
                    ex = Abs(ex)                                ' This resets GuiderNewMeasurement flag
                    ey = Abs(ey)
''-                 Trace "[autogd] Got measurement #" & j & ":  " & Util.FormatVar(ex, "0.00") & " " & Util.FormatVar(ey, "0.00")
                    If ex > 0.0 And ex < c_guideErrMax And ey > 0 And ey < c_guideErrMax Then
                        Console.PrintLine "  (autoguiding at " & _
                                        Util.FormatVar(c_guideExpCur, "0.00") & " sec.)"
                        Voice.Speak "Auto guider running."
                        c_guiding = True
                        AutoGuide = True
                        Exit Function                           ' FINISHED, IT'S GUIDING!
                    End If
                Next
            End If
        Else
            On Error Goto 0                                     ' Back to error trapping
''-         Trace "[autogd] Guider failed to start tracking"
        End If
        '
        ' Failed. Didn't start tracking, it quit tracking, or errors too high
        '
        Camera.GuiderStop                                       ' Must stop guider here!
        Util.WaitForMilliseconds 1000
        If c_guideExpCur >= c_guideExpMax Then Exit For         ' Sayonara, no usable guide stars!
    Next
    Camera.GuiderStop
    Console.PrintLine "**Autoguiding failed."
    c_guiding = False        
    AutoGuide = False
End Function


'----------------------------------------------------------------------------------------
' -----------------
' CalibrateGuider() - Calibrate guider
' -----------------
'
' Use "pointing" or clear filter for this. May be used for AO-x. Don't change rotation
' so it will work for calibrating the AO-x. Don't use FindBrightStar/Slew for internal
' guiders, as it is assumed that there will be a guide star positioned on the internal
' chip anyway!
'----------------------------------------------------------------------------------------
Function CalibrateGuider(RightAscension, Declination)
    Dim Camera, raStar, decStar, magStar, filt

    Set Camera = Util.ScriptCamera

    If c_guiding Then AutoGuide False                           ' Stop guider
    '
    ' If above 70 deg dec, too high
    '
    If Declination > 70.0 Then
       Util.Console.PrintLine "**Cannot calibrate guider above 70 deg declination."
       CalibrateGuider = False
       Exit Function
    End If
    
    If Util.ScriptTelescope.AlignmentMode = 2 Then              ' GEM (no short circuit bools)
        If Util.ScriptTelescope.SideOfPier = 0 Then             ' 0 = pierEast, LOOKING WEST!!!
            Util.Console.PrintLine "**Calibration must be done with scope looking east."
            Exit Function
        End If
    End If
    
    c_calActive = True                                          ' Light annunciator
    '
    ' Select filter for pointing updates to be used for guider cal
    '
    c_selectedFilter = Util.Prefs.CameraPrefs.ClearFilterNumber ' Clear filter for "imaging"
    filt = SetFilterForTask(FO_FORPOINTING)                     ' Switch to appropriate filter/offset for focusing
    '
    ' If external guider, find the brightest mag 6-9 star in the area. Center it.
    '
    If c_guideExtern Then
        If Not FindBrightStar(RightAscension, Declination, filt, raStar, decStar, magStar) Then
            c_calActive = False
            CalibrateGuider = False                             ' FAILED - EXIT Function
            Exit Function
        End If
        Util.Console.PrintLine "  Using star at mag " & Util.FormatVar(magStar, "0.0") & _
                " Slew to star."
        StartSlewJ2000 "Guider cal", raStar, decStar
        WaitForSlew
    Else
        If c_haveRotator Then
            Util.Console.PrintLine "  Assuring PA = 0 for guider angle measurement"
            StartRotateToPA 0, Util.ScriptTelescope.RightAscension
            WaitForRotator
        End If
    End If
    '
    ' Take the star-selection exposure
    '
    Util.Console.PrintLine "  Take star-selection image"
    Util.WaitForMilliseconds 2000                               ' Allow light to come on before sleeping UI
    Camera.GuiderAutoSelectStar = True
    Camera.GuiderExpose(Util.Prefs.AutoGuiding.TrackingExposureInterval)
    Do While Camera.GuiderRunning = True                        ' Must use hardware GuiderRunning here!
        Util.WaitForMilliseconds 1000
    Loop
    Util.WaitForMilliseconds 1000
    '
    ' Calibrate the guider. Must wait to reverse X till here (MaxIm Quirk)
    '
    Util.Console.PrintLine "  Calibrating..."
    If Util.Dome.Available Then Util.Dome.Slaved = False        ' Disable dome slaving
    Camera.GuiderDeclination = Util.ScriptTelescope.Declination
    Camera.GuiderReverseX = False                               ' Assure that the reversal switches are off
    Camera.GuiderReverseY = False
    Camera.GuiderCalibrate(Util.Prefs.AutoGuiding.TrackingExposureInterval)
    Do While Camera.GuiderRunning = True                        ' Must use hardware GuiderRunning here!
        Util.WaitForMilliseconds 1000
    Loop
    Util.Prefs.AutoGuiding.SensorAngle = Camera.GuiderAngle     ' Let ACP know what the sensor angle is
    Util.Console.PrintLine "  ACP guide sensor sngle updated to " & Util.FormatVar(Camera.GuiderAngle, "0.0")
    If Util.Dome.Available Then Util.Dome.Slaved = True         ' Re-enable dome slaving    
    Util.Console.PrintLine "  ...done"
    c_calActive = False                                         ' Shut off annunciator
    '
    ' If slewed out above, return to original position
    '
    If c_guideExtern Then
        StartSlewJ2000 "Cal return", RightAscension, Declination
        WaitForSlew
    End If

    CalibrateGuider = True                                      ' SUCCESS

End Function

'----------------------------------------------------------------------------------------
' ----------------
' SetTrackOffset() - Start/Stop offset tracking
' ----------------
'
' If starting offset tracking, turns off the guider if running.
'----------------------------------------------------------------------------------------
Function SetTrackOffset(RightAscensionRate, DeclinationRate)
    
    If Not c_haveTrackOffset Then
        Err.Raise vbObjectError, "AcquireSupport", _
                "**Offset tracking is not available for selected telescope"
    End If
    '
    ' Mount supports it...
    '
    If (RightAscensionRate = 0.0) And (DeclinationRate = 0.0) Then  ' Turning off
        If c_trackOffset Then 
            Util.Console.PrintLine "  (stop orbital tracking)"
            Voice.Speak "Stop orbital tracking."
        End If
        c_trackOffset = False
    Elseif c_haveTrackOffset Then                               ' Starting
        If c_guiding Then AutoGuide False                       ' Safety Valve
        Util.Console.PrintLine "  (doing orbital tracking. RA " & _
                Util.FormatVar(RightAscensionRate * 15.0, "0.0000") & " ""/sec, Dec " & _
                Util.FormatVar(DeclinationRate, "0.0000") & " ""/sec)"
        Voice.Speak "Starting orbital tracking."
        c_trackOffset = True
    End If
    Util.ScriptTelescope.RightAscensionRate = RightAscensionRate * SIDRATE ' ASCOM needs sec/sidereal-sec
    Util.ScriptTelescope.DeclinationRate = DeclinationRate                 ' ASCOM declination rate
    
End Function


'----------------------------------------------------------------------------------------
' --------------
' SelectFilter() - Specify filter to be used for subsequent imaging
' --------------
'
' Input
'   fNum = 0-based filter number to Select
'
' Returns
'   Nothing
'
' Selects filter for imaging, this is a public method. 
'----------------------------------------------------------------------------------------
Sub SelectFilter(fNum)
''- Trace "Selected filter " & FilterName(fNum)
    c_selectedFilter = fNum
End Sub


'----------------------------------------------------------------------------------------
' ------------------
' SetFilterForTask() - Physically change filter in MaxIm and apply focus offset if appropriate
' ------------------
'
' Inputs
'   Task        Purpose for filter (see FO_xxx constants)
'
' Returns the filter number of the changed-to filter (0 for no-filters)
' Sets the globals and public properties BrightStarMinMag and BrightStarMaxMag If
' filter info is available.
'
' Selects the appropriate filter for a given task (imaging, focusing, pointing) given the
' filter that will be used for imaging (c_selectedFilter). If FilterInfo is available, 
' does the focus offset. Avoids needless physical change of filter. Harmless if no filters.
'----------------------------------------------------------------------------------------
Function SetFilterForTask(Task)
    Dim needWait, curFilter, useFilter, taskName, useFocusOffsets, fsfName, fsfStream
    
    If Not c_haveFilters Then 
        SetFilterForTask = 0
        Exit Function
    End If
    
''- Trace "  [setfilttask] Selected imaging filter is " & FilterName(c_selectedFilter)

    useFocusOffsets = c_haveFilterInfo And Not Util.Prefs.Autofocus.ForcePerFilter
    Select Case Task 
        Case FO_FORIMAGE:                                       ' Filter for imaging, use it directly
            useFilter = c_selectedFilter                        ' Last filter set by SelectFilter
            taskName = "imaging"
        Case FO_FORFOCUS:                                       ' Filter to be used for focusing of given filter
            If useFocusOffsets Then
                useFilter = c_focusFilter(c_selectedFilter)
            Else                                                ' If no FilterInfo
                useFilter = c_selectedFilter                    ' Focus using imaging filter
            End If
            taskName = "auto-focus"
        Case FO_FORPOINTING:
            If useFocusOffsets Then
                useFilter = c_pointingFilter(c_selectedFilter)
            Else                                                ' If no FilterInfo
                useFilter = Util.Prefs.CameraPrefs.ClearFilterNumber    ' Use "clear" filter for P.U.
            End If
            taskName = "pointing exposure"
        Case Else:
            Err.Raise vbObjectError, "AcquireSupport", _
                "**Programmer error: Invalid task code in SetFilterForTask()"
    End Select
    
    If c_haveFilterInfo Then
        c_brightStarMinMag = c_filterBrightMag(useFilter)       ' Set up this filter's bright star mags
        c_brightStarMaxMag = c_filterFaintMag(useFilter)
''-     Trace "Bright-star mags " & c_brightStarMinMag & " to " & c_brightStarMaxMag
    End If
    If Util.ScriptCamera.Filter = useFilter Then
''-     Trace "Using already selected " & FilterName(useFilter) & " filter for " & taskName
        SetFilterForTask = useFilter
        Exit Function                                           ' No need for anything
    End If
    '
    ' Really switching filters...
    '
    Util.Console.PrintLine "  Switching from " & FilterName(Util.ScriptCamera.Filter) & _
                        " to " & FilterName(useFilter) & " filter for " & taskName
    If useFocusOffsets Then  SetFilterOffset useFilter          ' Adjust focus
    Util.ScriptCamera.Filter = useFilter                        ' Finally, change Filter
    '
    ' The SBIG AO doesn't wait for filter switch before doing its locate
    ' exposure. So if there's an AO, just wait here for 30 sec. This was
    ' extended from 10 sec in 2018 due to "slow" filter wheels.
    '
    If c_HaveAOx Then
        Util.Console.PrintLine "  (using AO, waiting 30 sec. for filter switch)"
        Util.WaitForMilliseconds 30000
    End If
    '
    ' Finally, write out the filter for the next cold start of ACP. 
    ' We have to do this every time we change filters
    '
    Util.Profile.WriteValue "LastFilterUsed", CStr(useFilter), "\"
    Util.Profile.WriteValue "LastFilterUsedTime", Util.SysUTCDate, "\"
    
    SetFilterForTask = useFilter

End Function

'----------------------------------------------------------------------------------------
' ------------------
' GetFilterForTask() - Get the filter for the task and set min/max mag globals
' ------------------
'
' Inputs
'   Task        Purpose for filter (see FO_xxx constants)
'
' Returns the filter number of the appropriate filter (0 for no-filters) given the
' selected imaging filter. This is a "no action" version of the above. Sets the 
' globals and public properties BrightStarMinMag and BrightStarMaxMag if filter info 
' is available. Used to get the min/mas focus star mags before FindBrightStar.
'
'----------------------------------------------------------------------------------------
Function GetFilterForTask(Task)
    Dim useFocusOffsets
''- Trace "  [getfilttask] Selected imaging filter is " & FilterName(c_selectedFilter)

    useFocusOffsets = c_haveFilterInfo And Not Util.Prefs.Autofocus.ForcePerFilter
    Select Case Task 
        Case FO_FORIMAGE:                                       ' Filter for imaging, use it directly
            GetFilterForTask = c_selectedFilter                 ' Last filter set by SelectFilter
        Case FO_FORFOCUS:                                       ' Filter to be used for focusing of given filter
            If useFocusOffsets Then
                GetFilterForTask = c_focusFilter(c_selectedFilter)
            Else                                                ' If no FilterInfo
                GetFilterForTask = c_selectedFilter             ' Focus using imaging filter
            End If
        Case FO_FORPOINTING:
            If useFocusOffsets Then
                GetFilterForTask = c_pointingFilter(c_selectedFilter)
            Else                                                ' If no FilterInfo
                GetFilterForTask = Util.Prefs.CameraPrefs.ClearFilterNumber  ' Use "clear" filter for P.U.
            End If
        Case Else:
            Err.Raise vbObjectError, "AcquireSupport", _
                "**Programmer error: Invalid task code in GetFilterForTask()"
    End Select
    
    If c_haveFilterInfo Then
        c_brightStarMinMag = c_filterBrightMag(GetFilterForTask) ' Set up this filter's bright star mags
        c_brightStarMaxMag = c_filterFaintMag(GetFilterForTask)
''-     Trace "Bright-star mags " & c_brightStarMinMag & " to " & c_brightStarMaxMag
    End If

End Function

'----------------------------------------------------------------------------------------
' -----------
' AutoFocus() - Perform an autofocus
' -----------
'
' Returns:      True if focus succeeded, else False
'
' Suspends orbital tracking or guiding, as necessary. Refuse and return False if 
' the current coordinates are within 5 deg. to the horizon (unless using AcquireStar
' and its zenith mode is on). Requires FocusMax 3.4.1 or later.
'
' NOTES:    The filter to use after autofocusing MUST be selected before calling this!!
'           Will NEVER do a pointing update after the re-slew back to the given RA/Dec!!
'           Will ALWAYS do a return slew back to the given RA/Dec
'           Will ALWAYS stop the guider and track offsets, even if failed or refusec
'
'----------------------------------------------------------------------------------------
Function AutoFocus(RightAscension, Declination)
    Dim AFTime, i, wasGuiding, rRA, rDec
    Dim curFilt, curDefocus
    Dim lafName, lafStream
    Dim fsfName, fsfStream
    
    ' 
    ' Strictly speaking, if we were guiding, we could not 
    ' have been orbital tracking! This logic is simpler. (er...)
    '
    If c_guiding Then AutoGuide False                           ' Assure guider is stopped
    If c_haveTrackOffset Then                                   ' If we can do orbital tracking
        SetTrackOffset 0.0, 0.0                                 ' Return to sidereal rate
    End If

    If Not c_haveAF Then
        Util.Console.PrintLine "**Autofocus Failed: AutoFocus is not enabled in ACP Preferences."
        AutoFocus = False
        Exit Function
    End If
    
    If c_usePWI Then
        SetFilterForTask(FO_FORFOCUS)

        Util.Console.PrintLine "Using PlaneWave AutoFocus"
        c_afActive = True
        AutoFocus = PlaneWaveAutoFocus()
        c_afActive = False
        If AutoFocus Then
            Util.Console.PrintLine "PlaneWave AutoFocus completed successfully"
        Else
            Util.Console.PrintLine "PlaneWave AutoFocus unable to find best focus"
        End If
    Else
        
        '
        ' Check the coordinates against ACP's horizon limits. If within
        ' 5 degrees, refuse to do the autofocus due to the possibility
        ' of the focus star OR the slew-back being below the horizon.
        '
        If Not Util.Prefs.AutoFocus.UseAcquireStar Or Not c_FMx.AcquireStarZenithEnable Then
            If Not SafeAboveHorizon(RightAscension, Declination, 5.0) Then
                Util.Console.PrintLine "**Autofocus refused: Position is within 5 deg. of horizon limit."
                AutoFocus = False                                   ' Return failure indication
                Exit Function                                       ' REFUSED, RETURN
            End If
        End If
        
        '
        ' Now do the autofocus
        '
        Voice.Speak "Starting auto focus."
        c_afActive = True
        Util.WaitForMilliseconds 2000                               ' Allow light to come on before sleeping UI
        
        '
        ' Load the system file if we have one, and ONLY if not already loaded. This
        ' avoids wiping out the latest best focus position, per Larry Weber.
        '
        If (Util.Prefs.AutoFocus.SystemFile <> "") And _
                        (LCase(c_FMx.SystemFileName) <> LCase(Util.Prefs.AutoFocus.SystemFile)) Then 
            c_FMx.SystemFileName = Util.Prefs.AutoFocus.SystemFile   ' Change the system file
        End If
        '
        ' Regardless wiether we use AcquireStar or our star selector,
        ' we need FM to return to prev focus if there is a focus failure.
        '
        c_FMx.FocusRoutineReturnToStartPositionEnable = True 
        '
        ' At this point remove any defocus. Wheh we're done we'll put it back.
        '
        curDefocus = get_DefocusCount()
        If curDefocus <> 0 Then
            Call put_DefocusCount(0)
        End If
            
        '
        ' Set up per AscquirStar or not
        '
        If Util.Prefs.AutoFocus.UseAcquireStar Then                 ' If prefs selected AcquireStar
            '
            ' (1) Look at the currently selected imaging filter, and select the correct
            ' filter for doing autofocus, then apply filter offsets if appropriate.
            '
            curFilt = SetFilterForTask(FO_FORFOCUS)                 ' Switch to appropriate filter/offset for focusing
            '
            ' (2) Set up FocusMax, make sure has AcquireStar and is on, 
            '     return is on, final pointing updates are off. Disallow
            '     meridian crossing if GEM.
            '
            c_FMx.AcquireStarEnable = True                          ' Make sure AcquireStar is On
            c_FMx.AcquireStarReturnSlewEnable = True                ' Make sure it returns to orig coordinates after focusing
            If Util.ScriptTelescope.AlignmentMode = 2 Then          ' If GEM, disallow meridian cross (not really our flip points!)
                c_FMx.AcquireStarMeridianCrossEnable = False
            Else
                c_FMx.AcquireStarMeridianCrossEnable = True
            End If
            c_FMx.AcquireStarFinalPointingUpdate = False            ' Inhibit FM's final pointing update
            '
            ' Later FocusMax can use our star mag range (from FilterInfo.txt) for star selection
            '
            If c_haveFilterInfo Then
                On Error Resume Next                                ' Allow these to fail on older FocusMax
                Console.PrintLine "  (AcquireStar will use stars mag " & _
                                        c_filterBrightMag(curFilt) & " to " & _
                                        c_filterFaintMag(curFilt) & ")"
                c_FMx.AcquireStarMinMagTgtStar = c_filterBrightMag(curFilt)
                c_FMx.AcquireStarMaxMagTgtStar = c_filterFaintMag(curFilt)
                On Error GoTo 0
            End If

            
            '
            ' (2.5) Select the configured fast readout mode for most efficient focus
            '
            If c_haveReadoutModes Then 
                Util.ScriptCamera.ReadoutMode = c_fastReadoutMode
                Util.Console.PrintLine "  (AF will use " & ReadoutModeName(Util.ScriptCamera.ReadoutMode) & " readout mode)"
            End If
            '
            ' (3) Start AcquireStar Focus
            '
            Util.Console.PrintLine "  Starting FocusMax AcquireStar autofocus..."
            AutoFocus = False                                       ' Assume failure
            If c_FMx.AcquireStarAsync() Then                        ' Try to start FocusMax
                '
                ' (4) Wait till it completes one way or 'tother
                '
                Util.WaitForMilliseconds 2000                       ' FM 3.2.1 has race condition
                AFTime = MXAFTIME                                   ' FM timeout counter
                Do While (c_FMx.AcquireStarAsyncStatus = -1) And (AFTime > 0)  ' Loop while FM is running and not timed out
                    Util.WaitForMilliseconds 1000
                    AFTime = AFTime - 1
                Loop
                If AFTime <= 0 Then                                 ' If FM ran too long
                    Util.Console.PrintLine "**Autofocus took too long. Check FocusMax log for details."
                    '
                    ' WARNING! FocusMax will hang forever if you call this when it
                    ' is not actually busy. There is a small timing window above where 
                    ' AFTime could be <= 0 AND FMx went idle. 
                    '
                    If c_FMx.AcquireStarAsyncStatus = -1 Then c_FMx.Halt ' IF STILL BUSY(!) Stop FocusMax focus cycle
                Elseif (c_FMx.AcquireStarAsyncStatus = 1) And (c_FMx.HalfFluxDiameter <> 0) Then    ' If looks like good AF run
                    c_lastFocusPosition = c_FMx.Position
                    Call ResetSimFWHM                               ' Reset simulator (quick so just do it)
                    c_lastFocusFWHM = 0                             ' **VITAL** Indicate just focused, plate solve will stach new lastFocusFWHM
                    c_lastAvgFWHM = 0                               ' **VITAL** Indicate to clients that no average is available yet
                    Util.Console.PrintLine "  FocusMax auto-focus successful!"
                    Util.Console.PrintLine "    HFD = " & Util.FormatVar(c_FMx.HalfFluxDiameter, "###.00")
                    Util.Console.PrintLine "    Focus position = " & c_FMx.Position
                    AutoFocus = True
                Else
                    Util.Console.PrintLine "**Autofocus failed. Check FocusMax log for details."
                End If
            Else
                Util.Console.PrintLine "**AutoFocus failed. Check FocusMax log for details."
            End If
        Else
            '
            ' ACP "not-so-smart" Autofocus
            '
            Dim  raStar, decStar, magStar
            '
            ' (1) Look at the currently selected imaging filter, and get the filter we're
            ' going to focus through (depending on whether FilteInfo is available). This also
            ' sets the focus star mag range.
            '
            curFilt = GetFilterForTask(FO_FORFOCUS)                    ' Get the filter and focus star mag range (no action)
            '
            ' (2) Find a nearby suitable focus star
            '
            If Not FindBrightStar(RightAscension, Declination, curFilt, raStar, decStar, magStar) Then
                c_afActive = False
                AutoFocus = False
                If c_haveTrackOffset Then                           ' If orbital tracking supported
                    SetTrackOffset rRA, rDec                        ' Restore rates (may be 0)
                End If
                If curDefocus <> 0 Then
                    Call put_DefocusCount(curDefocus)
                End If
                Exit Function                                       ' FAILED, RETURN
            End If
            '
            ' (3) Slew to the chosen focus star
            '
            Util.Console.PrintLine "  Using star at mag " & Util.FormatVar(magStar, "0.0") & _
                    ". Slew to star."
            StartSlewJ2000 "AutoFocus", raStar, decStar 
            WaitForSlew
            '
            ' (4) Try to do a pointing update to center the focus star precisely
            '
            If Util.Prefs.PointingUpdates.Enabled Then
                UpdatePointing "AutoFocus", raStar, decStar, get_RotatorPositionAngle()
            End If
            '
            ' (5) Look at the currently selected imaging filter, and select the correct
            ' filter for doing autofocus, then apply filter offsets if appropriate.
            '
            SetFilterForTask(FO_FORFOCUS)
            '
            ' (6) Select the configured fast readout mode for most efficient focus
            '
            If c_haveReadoutModes Then 
                Util.ScriptCamera.ReadoutMode = c_fastReadoutMode
                Util.Console.PrintLine "  (AF will use " & ReadoutModeName(Util.ScriptCamera.ReadoutMode) & " readout mode)"
            End If
            '
            ' (7) Do the autofocus
            '
            Util.Console.PrintLine "  Starting Autofocus..."
            AutoFocus = False                                       ' Assume failure
            If c_FMx.FocusAsync() Then                              ' Keep UI alive via Async...
                Util.WaitForMilliseconds 2000                       ' FM 3.2.1 has race condition
                AFTime = MXAFTIME                                   ' FM timeout counter
                Do While (c_FMx.FocusAsyncStatus = -1) And (AFTime > 0)  ' Loop while FM is running and not timed out
                    Util.WaitForMilliseconds 1000
                    AFTime = AFTime - 1
                Loop
                If AFTime <= 0 Then                                 ' If FM ran too long
                    Util.Console.PrintLine "**Autofocus took too long. Check FocusMax log for details."
                    '
                    ' WARNING! FocusMax will hang forever if you call this when it
                    ' is not actually busy. There is a small timing window above where 
                    ' AFTime could be <= 0 AND FMx went idle. 
                    '
                    If c_FMx.FocusAsyncStatus = -1 Then c_FMx.Halt  ' IF STILL BUSY(!) Stop FocusMax focus cycle
                Elseif (c_FMx.FocusAsyncStatus = 1) And (c_FMx.HalfFluxDiameter <> 0) Then
                    c_lastFocusPosition = c_FMx.Position
                    Call ResetSimFWHM                               ' Reset simulator (quick so just do it)
                    c_lastFocusFWHM = 0                             ' **VITAL** Indicate just focused, plate solve will stach new lastFocusFWHM
                    c_lastAvgFWHM = 0                               ' **VITAL** Indicate to clients that no average is available yet
                    Util.Console.PrintLine "  FocusMax auto-focus successful!"
                    Util.Console.PrintLine "    HFD = " & Util.FormatVar(c_FMx.HalfFluxDiameter, "###.00")
                    Util.Console.PrintLine "    Focus position = " & c_FMx.Position
                    AutoFocus = True                                ' Report success to caller
                Else
                    Util.Console.PrintLine "**AutoFocus failed. Check FocusMax log for details."
                End If
            Else
                Util.Console.PrintLine "**AutoFocus failed. Check FocusMax log for details."
            End If
            '
            ' (8) Return to starting position
            '
            Util.Console.PrintLine "  Slewing back to original position..."
            StartSlewJ2000 "AF return", RightAscension, Declination
        End If    
    End If ' End of FocusMax-specific code

    '
    ' GEM:519 Mainly for Scheduler
    ' GEM:1032 Move this to the config area and out of Program Files (need change in Scheduler!)
    '
    If AutoFocus Then
        lafName = Util.GetConfigFilePath(LASTAFNAME)                ' Find the last AF file
        If lafName <> "" Then 
            FSO.DeleteFile(lafName)                                 ' Delete any old one
            Util.WaitForMilliseconds 500                            ' Another "fast system" safety rest
        End If
        Set lafStream = FSO.CreateTextFile(ACPApp.ConfigPath & "\" & LASTAFNAME, False) ' Must be gone (above)
        lafStream.WriteLine Util.SysJulianDate
        lafStream.Close
    End If

    '
    ' Finish up
    '
    WaitForSlew                                                     ' Wait for above Slew or AcquireStar's return slew
 
    If curDefocus <> 0 Then                                         ' Restore defocus count if active
        put_DefocusCount(curDefocus)
    End If
    
    Util.Console.PrintLine "  Autofocus finished."
    Voice.Speak "Auto focus complete."
    c_afActive = False
    
End Function

'----------------------------------------------------------------------------------------
' ----------------
' StartSlewJ2000() - Start (or complete, if no async) a slew to new J2000 coordinates
' ----------------
'
' Tries to detect GEM meridian flip and returns indication of same.
' STOPS GUIDER IF RUNNING!
'
' Parameters:
'   TargetName                  Name of target, for logging only
'   RightAscension              J2000 Right Ascension
'   Declination                 J2000 Declination
'
' Return
'   True if GEM flipped
'
' Generates a new set of image simulator coordinates (with errors) whenever you 
' slew. These coordinates are based on the slew destination coordinates J2000
' and the RMS error is increased from 0 to c_simPosErrRMS as the slew distance
' increases from 0 to c_Util.Prefs.PointingUpdates.MaximumSlew. Above this, 
' the RMS error remains constant at c_simPosErrRMS.
'----------------------------------------------------------------------------------------
Function StartSlewJ2000(TargetName, RightAscension, Declination)
    Dim RALoc, DecLoc, sd, ms, dr, dd, erms, Telescope
    Dim rRA, rDec, iRA, iDec, ptgerr, msg

    If Not c_userActions Is Nothing Then
        If Not c_userActions.SlewStart(RightAscension, Declination) Then
            Err.Raise vbObjectError, "UserAction", _
                    "**User action SlewStart() returned False"
        End If
    End If
    
    '
    ' Allow SlewStart to open the dome/roof!
    '
    If c_domeHazardous And Not Util.Dome.ShutterStatus = 0 Then
        Err.Raise vbObjectError, "ACP.AcquireSupport", _
            "**The shutter or roof is closed. Cannot slew safely."
    End If
    
    If c_guiding Then AutoGuide False                           ' Stop the guider!
    If c_trackOffset Then Call SetTrackOffset(0.0, 0.0)         ' Stop offset tracking
    
    Set Telescope = Util.ScriptTelescope
    
    If Telescope.CanSlewAsync Then
        Util.Console.PrintLine "  Start slew to " & TargetName & "..."
        Voice.Speak "Start slew to " & TargetName & "."
    Else
        Util.Console.PrintLine "  Slewing to " & TargetName & "..."
        Voice.Speak "Slewing to " & TargetName & "."
    End If
''- Trace "      ([strtslw] J2000 coords: RA = " & Util.Hours_HMS(RightAscension) & _
''-                         "  Dec = " & Util.Degrees_DMS(Declination) & ")"
    
    If Util.Prefs.PointingUpdates.Simulate Then
        CalcSimImageCoordinates RightAscension, Declination     ' Calculate simulator image
    End If
    
    c_slewStartRA = Telescope.RightAscension                    ' Instrumental, for web pages
    c_slewStartDec = Telescope.Declination
    
    '
    ' Capture the slew TARGET RA/Dec for unguided dither etc. Nots that this is 
    ' updated during a pointing update (see UpdatePointing()), but there are times
    ' when no pointing update is done at the start of a new target (close to 
    ' previous) so we need to capthre this here in any case! Also see TakePicture()
    ' for usage of these during unguided dither.
    '
    c_slewTargetRA = RightAscension
    c_slewTargetDec = Declination
    
    '
    ' Now convert as needed for the scope's coordinate system
    '
    If c_needLocalTopo Then
        '
        ' Convert J2000 to Local topocentric (w/optional refraction)
        '
        Call CvtLocalTopo(RightAscension, Declination, RALoc, DecLoc)
        '
        ' Slew distance and progress computed using instrumental coordinates
        '
        c_slewDist = EquDist2(c_slewStartRA, c_slewStartDec, RALoc, DecLoc)
        '
        ' Call our raw slew Function
        '
        StartSlewJ2000 = StartSlew(TargetName, RALoc, DecLoc)
    Else
        '
        ' Slew distance and progress computed using instrumental coordinates
        '
        c_slewDist = EquDist2(c_slewStartRA, c_slewStartDec, _
                                    RightAscension, Declination)
        '
        ' Call our raw slew function
        '
        StartSlewJ2000 = StartSlew(TargetName, RightAscension, Declination)
    End If    
    
    '
    ' Slew ends here if scope can't do async
    '
    If Not Telescope.CanSlewAsync Then
        If Not c_userActions Is Nothing Then
            If Not c_userActions.SlewEnd() Then
                Err.Raise vbObjectError, "UserAction", _
                        "**User action SlewEnd() returned False"
            End If
        End If
    End If
    
End Function


'----------------------------------------------------------------------------------------
' -------------
' WaitForSlew() - Wait for slew to complete
' -------------
'
' Does nothing if ASCOM scope can't do async slewing. 
' Won't log and speak if entered while Slewing is false.
' BE CAREFUL HERE... ESPECIALLY WITH SlewEnd() User Action!
'----------------------------------------------------------------------------------------
Sub WaitForSlew()
    Dim Telescope, wasSlewing
    
    Set Telescope = Util.ScriptTelescope
    If Telescope.CanSlewAsync Then
        If Telescope.Slewing Then                               ' Skip if not slewing in the first place
            wasSlewing = True
            Util.Console.PrintLine "  (wait for slew to complete)"
            Voice.Speak "Waiting for slew to complete."
        Else
            wasSlewing = False
        End If
        Do While Telescope.Slewing                              ' ASCOM includes settle Time
            Util.WaitForMilliseconds 1000
        Loop
        If wasSlewing Then 
            Util.Console.PrintLine "  (slew complete)"          ' Report completion for async
            Voice.Speak "Slew completed"
            If Not c_userActions Is Nothing Then                ' Call SlewEnd only if was slewing 
                If Not c_userActions.SlewEnd() Then
                    Err.Raise vbObjectError, "UserAction", _
                            "**User action SlewEnd() returned False"
                End If
            End If
        End If
    End If
End Sub

'----------------------------------------------------------------------------------------
' -------------
' SyncToJ2000() - Sync the scope to the given J2000 coordinates
' -------------
'
' Parameters:
'   RightAscension          New RA, J2000
'   Declination             New Dec, J2000
'
' Returns:                  
'   True if sync really done, else False
'
' Sync() avoids sync across meridian for German polar (Bisque Paramount crashes)
' and syncs with corrector off and at "high" declinations.
'----------------------------------------------------------------------------------------
Function SyncToJ2000(RightAscension, Declination)
    Dim RAloc, DecLoc, didSync
   
''- Trace "      ([sync] J2000 coords: RA = " & Util.Hours_HMS(RightAscension) & _
''-                         "  Dec = " & Util.Degrees_DMS(Declination) & ")"
   If c_needLocalTopo Then
        Call CvtLocalTopo(RightAscension, Declination, RAloc, DecLoc)
        didSync = Sync(RAloc, DecLoc)
    Else
        didSync = Sync(RightAscension, Declination)
    End If
    '
    ' If didn't sync, do not copy these. Caller will do the right thing for
    ' non-syncable scope. See UpdatePointing(). BE CAREFUL HERE!!
    '
    If didSync Then
        c_lastSyncRA = RightAscension
        c_lastSyncDec = Declination
        c_simImageRA = RightAscension                           ' Center simulator coordinates too
        c_simImageDec = Declination
    End If
    
    SyncToJ2000 = didSync

End Function

'----------------------------------------------------------------------------------------
' ----------
' Shutdown() - Park scope, close/park dome (if enabled), shutdown cooler
' ----------
'
'----------------------------------------------------------------------------------------
Sub Shutdown()
    Dim Camera, z, i, tNow, tPrev
    
    Set Camera = Util.ScriptCamera
    
    If Not c_userActions Is Nothing Then                        ' If User Actions
        If c_userActions.Shutdown() Then Exit Sub               ' If Shutdown() returns True, that's it!
    End If

    If Util.ScriptTelescope.CanPark Then                        ' If mount supports park or dome and auto-home/close
        Util.Console.PrintLine "Parking scope." 
        Util.ScriptTelescope.Park                               ' Park the scope if possible, and/or close/park dome
    Else                                                        ' If truly lame mount
        Util.Console.PrintLine "Shutdown: your scope can't be parked."
    End If
    
    If Util.ScriptTelescope.Connected Then Util.ScriptTelescope.Connected = False  ' Disconnect it from ACP
    If Util.RotatorConnected Then
        Util.Console.PrintLine "Disconnecting rotator." 
        Util.RotatorConnected = False
    End If
    Util.Console.PrintLine "Shutting down imager. Please wait..."
    If Camera.CoolerOn Then                                     ' Unless cooler is already off
        If Camera.CanSetTemperature Then                        ' Try to do "nice" Shutdown
            z = Camera.TemperatureSetpoint                      ' Remember this, as MaxIm remembers
            Util.Console.PrintLine "  (raising temperature... 10 min max)"
            tPrev = -273.15                                     ' Init warming rate state
            Camera.TemperatureSetpoint = 6.0                    ' Raise temperature to +6C
            For i = 1 To 10                                     ' Take 10 minutes max...
                tNow = Camera.Temperature
                Util.Console.PrintLine "  (cooler is now at " & Util.FormatVar(Camera.Temperature, "0.0") & "C)"
                If tNow >= 4.0 Then Exit For                    ' Warmed, can shut down
                ' Wait at least 3 min so camera can start warming
                If (i > 3) And ((tNow - tPrev) < 3.0) Then Exit For ' Warming rate < 0.05deg/sec, can shut down
                tPrev = tNow
                Util.WaitForMilliseconds 60000
            Next
            Camera.TemperatureSetpoint = z                      ' Reset original setpoint for future
        End If
        Camera.CoolerOn = False
    End If
    Util.WaitForMilliseconds 1000                               ' Give MaxIm a chance to shutdown cooler
    Util.CameraConnected = False                                ' Disconnect it from ACP
    Util.Console.PrintLine "Imager shutdown complete."
End Sub

'----------------------------------------------------------------------------------------
' --------------
' MajorPlanetOb() -  Return current J2000 coordinates/rates of the given major planet
' --------------
'
' This is a wrapper for MajorPlanet(). It is provided for callers who pass an object
' with properties for name, and coordinates/rates (e.g. AcquireImages2.js).
'----------------------------------------------------------------------------------------
Function MajorPlanetOb(O)
    Dim RA, Dec, RARate, DecRate                                ' Can't use obj props as ref params (typ)
    
    MajorPlanetOb = MajorPlanet(O.Name, RA, Dec, RARate, DecRate)
    O.RA = RA
    O.Dec = Dec
    O.RARate = RARate
    O.DecRate = DecRate
    
End Function

'----------------------------------------------------------------------------------------
' -------------
' MajorPlanet() - Return current J2000 coordinates/rates of the given major planet
' -------------
'
' Return True if planet found, else False
'----------------------------------------------------------------------------------------
Function MajorPlanet(Name, RightAscension, Declination, RightAscensionRate, DeclinationRate)
    Dim pl, tvec, kt, ke, jd, pn
    
    Set pl = CreateObject("NOVAS.Planet")
    Set kt = CreateObject("Kepler.Ephemeris")
    Set ke = CreateObject("Kepler.Ephemeris")
    Select Case LCase(Name)
        Case "mercury":     pn = 1
        Case "venus":       pn = 2
        Case "mars":        pn = 4
        Case "jupiter":     pn = 5
        Case "saturn":      pn = 6
        Case "uranus":      pn = 7
        Case "neptune":     pn = 8
        Case "pluto":       pn = 9
        Case Else:
            MajorPlanet = False                                 ' Planet not found
            Exit Function
    End Select
    pl.Ephemeris = kt                                           ' Plug in target ephemeris gen
    pl.EarthEphemeris = ke                                      ' Plug in Earth ephemeris gen
    pl.Type = 0                                                 ' NOVAS: Major planet
    pl.Name = Name                                              ' Planet name
    pl.Number = pn                                              ' Decoded planet number
    jd = Util.SysJulianDate                                     ' Get current jd
    pl.DeltaT = Util.DeltaT(jd)                                 ' Delta T for NOVAS
    Call GetPositionAndVelocity(pl, jd - (pl.DeltaT / 86400), _
                                RightAscension, Declination, _
                                RightAscensionRate, DeclinationRate)
    Set pl = Nothing                                            ' Releases both Ephemeris objs
    MajorPlanet = True

End Function

'----------------------------------------------------------------------------------------
' --------------
' MinorPlanetOb() - Return name and current J2000 coordinates/rates of the minor planet
' --------------
'
' This is a wrapper for MinorPlanet(). It is provided for callers who pass an object
' with properties for elements, name, and coordinates/rates (e.g. AcquireImages2.js).
'----------------------------------------------------------------------------------------
Function MinorPlanetOb(O)
    Dim Name, RA, Dec, RARate, DecRate                          ' Can't use obj props as ref params (typ)

    Name = O.Name
    MinorPlanetOb = MinorPlanet(O.Elements, Name, RA, Dec, RARate, DecRate)
    O.Name = Name
    O.RA = RA
    O.Dec = Dec
    O.RARate = RARate
    O.DecRate = DecRate
    
End Function

'----------------------------------------------------------------------------------------
' -------------
' MinorPlanet() - Return name and current J2000 coordinates/rates of the minor planet
' -------------
'
' May be called in two ways: 
'
' (1) Elements, must be in "MPC 1-line" format. Returns packed designation, 
'     position, and velocity
' (2) Elements = "" And Name given. Name can be MP number (as a string), Name, 
'     provisional designation (2000 SK100), or packed provisional designation 
'     (K00SA0K). In this case, ASCOM.MPCORB is used as the source for elements.
'
' Non-fatal and quiet if (2) fails to find in database, just returns false.
'----------------------------------------------------------------------------------------
Function MinorPlanet(Elements, Name, RightAscension, Declination, RightAscensionRate, DeclinationRate)
    Dim kt, ke, pl, jd, mp, key, cl
    
    Set pl = CreateObject("NOVAS.Planet")
    Set kt = CreateObject("Kepler.Ephemeris")
    Set ke = CreateObject("Kepler.Ephemeris")
    pl.Ephemeris = kt                                           ' Plug in target ephemeris gen
    pl.EarthEphemeris = ke                                      ' Plug in Earth ephemeris gen
    pl.Type = 1                                                 ' NOVAS: Minor Planet (Passed to Kepler)
    pl.Number = 1                                               ' Must pass valid number to Kepler, but is ignored
    If Elements = "" Then                                       ' No elements, try using MPCORB
        On Error Resume Next
        Set mp = CreateObject("ASCOM.MPCORB")
        mp.Open
        If Err.Number <> 0 Then
            MinorPlanet = False
            Exit Function
        End If
        Err.Clear
        mp.GetElements(Name)                                    ' Look up in database
        If Err.Number <> 0 Then                                 ' Not found
            MinorPlanet = False
            Exit Function
        End If
        On Error Goto 0
        kt.Name = mp.Designation
        kt.Epoch = mp.Epoch                                     ' Epoch of osculating elements
        kt.M = mp.M                                             ' Mean anomaly
        kt.n = mp.n                                             ' Mean daily motion (deg/day)
        kt.a = mp.a                                             ' Semimajor axis (AU)
        kt.e = mp.e                                             ' Orbital eccentricity
        kt.Peri = mp.Peri                                       ' Arg of perihelion (J2000, deg.)
        kt.Node = mp.Node                                       ' Long. of asc. node (J2000, deg.)
        kt.Incl = mp.Incl                                       ' Inclination (J2000, deg.)
        mp.Close                                                ' Release the database
        Set mp = Nothing                                        ' Release all that memory now!
    Else                                                        ' Elements given split and fill In
        Name = Trim(Left(Elements, 7))                          ' Object name (return)
        kt.Name = Name
        kt.Epoch = PackedToJulian(Trim(Mid(Elements, 21, 5)))   ' Epoch of osculating elements
        cl = GetLocale()                                        ' Get locale (. vs , shit)
        SetLocale "en-us"                                       ' Make sure numbers convert properly
        kt.M = CDbl(Trim(Mid(Elements, 27, 9)))                 ' Mean anomaly
        kt.n = CDbl(Trim(Mid(Elements, 81, 11)))                ' Mean daily motion (deg/day)
        kt.a = CDbl(Trim(Mid(Elements, 93, 11)))                ' Semimajor axis (AU)
        kt.e = CDbl(Trim(Mid(Elements, 71, 9)))                 ' Orbital eccentricity
        kt.Peri = CDbl(Trim(Mid(Elements, 38, 9)))              ' Arg of perihelion (J2000, deg.)
        kt.Node = CDbl(Trim(Mid(Elements, 49, 9)))              ' Long. of asc. node (J2000, deg.)
        kt.Incl = CDbl(Trim(Mid(Elements, 60, 9)))              ' Inclination (J2000, deg.)
        SetLocale cl                                            ' Restore locale
    End If
    jd = Util.SysJulianDate                                     ' Get current jd
    pl.DeltaT = Util.DeltaT(jd)                                 ' Delta T for NOVAS and Kepler
    Call GetPositionAndVelocity(pl, jd - (pl.DeltaT / 86400), _
                                RightAscension, Declination, _
                                RightAscensionRate, DeclinationRate)
    Util.Console.PrintLine "  MP elements for " & kt.Name & " --> RA=" & _
                Util.Hours_HMS(RightAscension) & " Dec=" & _
                Util.Degrees_DMS(Declination) & " (J2000)"
    Set pl = Nothing                                            ' Releases both Ephemeris objs
    MinorPlanet = True                                          ' Success
    
End Function

'----------------------------------------------------------------------------------------
' ---------
' CometOb() - Return name and current J2000 coordinates/rates of a Comet
' ---------
'
' This is a wrapper for Comet(). It is provided for callers who pass an object
' with properties for elements, name, and coordinates/rates (e.g. AcquireImages2.js).
'----------------------------------------------------------------------------------------
Function CometOb(O)
    Dim Name, RA, Dec, RARate, DecRate                          ' Can't use obj props as ref params (typ)

    Name = O.Name
    CometOb = Comet(O.Elements, Name, RA, Dec, RARate, DecRate)
    O.Name = Name
    O.RA = RA
    O.Dec = Dec
    O.RARate = RARate
    O.DecRate = DecRate
    
End Function

'----------------------------------------------------------------------------------------
' -------
' Comet() - Return name and current J2000 coordinates/rates of a Comet
' -------
'
' May be called in two ways:
'
' (1) Elements in "MPC 1-line comet" format as obtainable from
'        http://cfa-www.harvard.edu/iau/Ephemerides/Comets/SoftwareComets.html
'     specifically
'        http://cfa-www.harvard.edu/iau/Ephemerides/Comets/Soft00Cmt.txt

' (2) Elements = "" And Name given. Name can be the number, name or packed 
'     designation (e.g., PJ98U030 or "P/1998 U3", 223P/Skiff or 0223P)
'
' Non-fatal and quiet if (2) fails to find in database, just returns false.

'----------------------------------------------------------------------------------------
Function Comet(Elements, Name, RightAscension, Declination, RightAscensionRate, DeclinationRate)
    Dim cmt, kt, ke, pl, jd, q, cl
    
    Set pl = CreateObject("NOVAS.Planet")
    Set kt = CreateObject("Kepler.Ephemeris")
    Set ke = CreateObject("Kepler.Ephemeris")
    pl.Ephemeris = kt                                           ' Plug in target ephemeris gen
    pl.EarthEphemeris = ke                                      ' Plug in Earth ephemeris gen
    pl.Type = 2                                                 ' NOVAS: Comet (passed to Kepler)
    pl.Number = 1                                               ' NOVAS bug: Must set number. Ignored.
    If elements = "" Then
        On Error Resume Next
        Set cmt = CreateObject("ASCOM.MPCCOMET")
        cmt.Open
        If Err.Number <> 0 Then
            Comet = False
            Exit Function
        End If
        Err.Clear
        cmt.GetElements(Name)                                   ' Look up in database
        If Err.Number <> 0 Then                                 ' Not found
            Comet = False
            Exit Function
        End If
        On Error Goto 0
        kt.Name = cmt.Designation
        kt.Epoch = cmt.Epoch                                    ' Epoch of osculating elements
        kt.e = cmt.e                                            ' Orbital eccentricity

        If kt.e >= 1 Then                                       ' If parabolic or hyperbolic...
            kt.a = cmt.q                                        ' ... then mean dist = perihelion dist
        Else                                                    ' But if elliptical... 
            kt.a = cmt.q / (1 - kt.e)                           ' ... then mean dist =  q / (1 - e)
        End If
        
        kt.Peri = cmt.Peri                                      ' Arg of perihelion (J2000, deg.)
        kt.Node = cmt.Node                                      ' Long. of asc. node (J2000, deg.)
        kt.Incl = cmt.Incl                                      ' Inclination (J2000, deg.)
        cmt.Close                                               ' Release the database
        Set cmt = Nothing                                       ' Release all that memory now!
    Else
        Name = Trim(Mid(Elements, 1, 12))                       ' Object name 'mpc packed designation'
        kt.Name = Name
        cl = GetLocale()                                        ' Get locale (. vs , shit)
        SetLocale "en-us"                                       ' Make sure numbers convert properly
        kt.Epoch = Util.Calendar_Julian(CInt(Mid(Elements,13,6)), _
                        CInt(Mid(Elements,19,3)),CDbl(Mid(Elements,22,8)))
        kt.e = CDbl(Trim(Mid(Elements, 40, 10)))                ' Orbital eccentricity
        q = CDbl(Trim(Mid(Elements, 30, 10)))                   ' Perihelion distance
        If kt.e >= 1 Then                                       ' If parabolic or hyperbolic...
          kt.a = q                                              ' ... then mean dist = perihelion dist
        Else                                                    ' But if elliptical... 
          kt.a = q / (1 - kt.e)                                 ' ... then mean dist =  q / (1 - e)
        End If
        kt.M = 0                                                ' For comet mean anomaly = 0
        kt.n = 0                                                ' For conet mean daily motion = 0 
        kt.Peri = CDbl(Trim(Mid(Elements, 50, 10)))             ' Arg of perihelion (J2000, deg.)
        kt.Node = CDbl(Trim(Mid(Elements, 60, 10)))             ' Long. of asc. node (J2000, deg.)
        kt.Incl = CDbl(Trim(Mid(Elements, 70, 10)))             ' Inclination (J2000, deg.)
        SetLocale cl                                            ' Restore locale
    End If
    jd = Util.SysJulianDate                                     ' Get current JD
    pl.DeltaT = Util.DeltaT(jd)                                 ' Delta T for NOVAS & Kepler
    Call GetPositionAndVelocity(pl, jd - (pl.DeltaT / 86400), _
                                RightAscension, Declination, _
                                RightAscensionRate, DeclinationRate)
    Util.Console.PrintLine "  Comet elements for " & kt.Name & " --> RA=" & _
                Util.Hours_HMS(RightAscension) & " Dec=" & _
                Util.Degrees_DMS(Declination) & " (J2000)"
    Set pl = Nothing                                            ' Releases both Ephemeris objs
    Comet = True
                                                                ' Always successful
End Function

'----------------------------------------------------------------------------------------
' ----------
' NEOEphOb() - Return current J2000 coordinates/rates given NEOCP style ephemeris records
' ----------
'
' This is a wrapper for NeoEph(). It is provided for callers who pass an object
' with properties for elements, name, and coordinates/rates (e.g. AcquireImages2.js).
'----------------------------------------------------------------------------------------
Function NeoEphOb(O)
    Dim RA, Dec, RARate, DecRate                                ' Can't use obj props as ref params (typ)

    NeoEphOb = NEOEph(Mid(O.TargetLine, 12), RA, Dec, RARate, DecRate)
    O.RA = RA
    O.Dec = Dec
    O.RARate = RARate
    O.DecRate = DecRate
    
End Function

'----------------------------------------------------------------------------------------
' --------
' NEOEph() - Return current J2000 coordinates/rates given NEOCP style ephemeris records
' --------
'
' The input ephemeris lines must be produced by selecting the following options in the
' NEO Confirmation Page at http://cfa-www.harvard.edu/iau/NEO/ToConfirm.html
'
' * Geocentric observing point
' * Decimal Units
' * Ephemeris interval 1 hour 
' * Motions in "/hr
' * Separate RA and Dec COORDINATE (not sky) rates
' * Full Output (not brief!) 
'
' The original MPC ephemeris lines must look like this:
'
' 0        1         2         3         4         5         6     
' 12345678901234567890123456789012345678901234567890123456789012345
' -----------------------------------------------------------------
' 2003 05 29 01    21.2471    +29.068     93.8  17.4  -13.92  16.01
'
' Input to NEOEph() must be a single string, with at least 2 (preferably 4 or more
' ephemeris records, '|' delimited. Each ephemeris record must consist ONLY of the
' date/time, RA, and Dec portions of the above. Here is what the Eph string should
' look like given 4 ephemeris records spaced 2 hours apart:
' 
' 0        1         2         3         4         5         6     
' 12345678901234567890123456789012345678901234567890123456789012345
' -----------------------------------------------------------------
' 2003 05 29 01    21.2471    +29.068|2003 05 29 03    21.2341    +29.121|2003 05 29 05    21.2224    +29.293|2003 05 29 07    21.2093    +29.145
'
' Eph                  = [in]  NEOCP ephemeris lines as a string formatted per the above ^^
' RightAscension       = [out] Right Ascension, hours
' Declination          = [out] Declination, degrees
' RightAscensionRate   = [out] RightAscension Rate, seconds per second
' DeclinationRate      = [out] Declination Rate, arcseconds per second
'----------------------------------------------------------------------------------------
Function NEOEph(Eph, RightAscension, Declination, RightAscensionRate, DeclinationRate)
    Dim T(), RA(), Dec(), bits
    Dim n, u, i, tn, cl
    Dim RA2, Dec2
    
    tn = Util.SysJulianDate                                     ' Get current JD (copy)
    bits = Split(Eph, "|")                                      ' Split up ephemeris records
    u = UBound(bits)                                            ' Max index in arrays
    n = u + 1                                                   ' Number of ephemeris records (order of interp)

    ReDim T(u)                                                  ' Crate arrays for interpolator
    ReDim RA(u)
    ReDim Dec(u)
    '
    ' Parse each ephemeris record and fill arrays. Each record
    ' is checked to see that it is exactly 35 characters long.
    ' If not, it is probably bad!
    '
    cl = GetLocale()                                            ' Get locale (. vs , shit)
    SetLocale "en-us"                                           ' Make sure numbers convert properly
    For i = 0 To u
        If Len(bits(i)) <> 35 Then
            Util.Console.PrintLine "**Bad ephemeris record, not 35 characters long."
            NEOEph = False
            Exit Function
        End If
        T(i) = DateToJulian(CInt(Mid(bits(i), 1, 4)), CInt(Mid(bits(i), 6, 2)), CInt(Mid(bits(i), 9, 2))) + _
                Mid(bits(i), 12, 2) / 24.0
        RA(i) = CDbl(Mid(bits(i), 18, 7))
        Dec(i) = CDbl(Mid(bits(i), 29, 7))
    Next
    SetLocale cl                                                ' Restore locale
    '
    ' Ephemerides that start or end more than 2 hours away
    ' are unacceptable. Fail.
    '
    If (tn < (T(0) - 0.0833334)) Or (tn > (T(u) + 0.0833334)) Then  ' Eph more than 2 hours off
        Util.Console.PrintLine "**Ephemeris data starts or ends more than 2 hours from Now"
        NEOEph = False
        Exit Function
    End If
    '
    ' Calculate RA and Dec
    '
    RightAscension = NevilleVB(T, RA, n, tn)
    Declination = NevilleVB(T, Dec, n, tn)
    '
    ' Advance time by 5 minutes, calculate new RA/Dec and
    ' differentiate to get velocities.
    '
    tn = tn + 0.0034722222                                      ' 300sec / 86400 sec
    RA2 = NevilleVB(T, RA, n, tn)
    Dec2 = NevilleVB(T, Dec, n, tn)
    RightAscensionRate = ((RA2 - RightAscension) * 3600.0) / 300.0  ' RA rate sec/sec
    DeclinationRate = ((Dec2 - Declination) * 3600.0) / 300.0   ' Dec rate, arcsec/sec

    Util.Console.PrintLine "  Interpolated coordinates: RA=" & _
                Util.Hours_HMS(RightAscension) & " Dec=" & _
                Util.Degrees_DMS(Declination) & " (J2000)"

    NEOEph = True
        
End Function

'----------------------------------------------------------------------------------------
' ---------------
' CalcEphemeris() - Master ephemeris calculator
' ---------------
'
' Given orbital elements (could be MP, NEOCP, or comet), or a name of the form
' "MP xxxxx" or "CT yyyyy", return the coordinates and the coordinate rates 
' via reference parameters. Return True if the function succeeded, else False. 
' Sourceis the line from an ACP Plan, which could be orbital elements or the
' "MP/CT xxxx" line. This function figures out which of them. The returned
' values are passed back through Name, RA, RARate, Dec, DecRate.
'
' Input:    Source - Orbital elements, a set of NEOCP ephemerides, "MP xxxx", or "CT yyyy"
' Outputs:  Name, RA, RARate, Dec, DecRate
' Return:   True if succeeded, else False
'
'----------------------------------------------------------------------------------------
Function CalcEphemeris(Source, Name, RightAscension, Declination, RightAscensionRate, DeclinationRate)
    Dim buf, RX
  
    buf = Source                                                ' Prevent munging Source here
    If Left(buf, 3) = "MP " Then                                ' Named minor planet
        buf = Trim(Mid(buf, 4))                                 ' Get rid of leading "MP "
        If MinorPlanet("", buf, RightAscension, Declination, RightAscensionRate, DeclinationRate) Then  ' Try MPCORB database (Logs all errors)
            Name = buf
            CalcEphemeris = True
        Else
            CalcEphemeris = False                               ' Errors logged, return failure
        End If
	Elseif left(buf,3) = "CT " Then								' Comet
	    buf = Trim(Mid(buf, 4))                                 ' Get rid of leading "CT "
        If Comet("", buf, RightAscension, Declination, RightAscensionRate, DeclinationRate) Then  ' Try MPCCOMET database (Logs all errors)
            Name = buf
            CalcEphemeris = True
        Else
            CalcEphemeris = False                               ' Errors logged, return failure
        End If
    Elseif Mid(buf, 47, 1) = "|" Then                           ' NEOCP ephemeris data w/10-char name
        If NEOEph(Mid(buf, 12), RightAscension, Declination, RightAscensionRate, DeclinationRate) Then
            Name = Trim(Mid(buf, 1, 10))
            CalcEphemeris = True
        Else
            CalcEphemeris = False                               ' Errors logged, return failure
        End If
    Elseif Len(buf) > 90 Then                                   ' MUST BE LAST TEST - Comet or asteroid elements
        Set RX = New RegExp
        RX.Pattern = "[PCD]-?[A-Z]?/"                            ' Match normal and fragmentary names
        '
        ' Historically, we allowed truncated MPC 1-line for minor planets: the data
        ' after column 103 could be omitted. In order to preserve backward compatibility
        ' the test for Comet vs MP elements looks for C/ P/ D/ or C-x P-x D-x (latter are
        ' comet fragment names) somewhere after column 95.
        '
        If RX.Test(Mid(buf, 95)) Then                           ' C/ or P/ or D/ Comet
            On Error Resume Next                                ' Handle all errors w.r.t. elements (format, etc.)
            CalcEphemeris = Comet(buf, Name, RightAscension, Declination, RightAscensionRate, DeclinationRate)
            If Err.Number <> 0 Then
                Util.Console.PrintLine "Bad comet elements: " & Err.Description
                CalcEphemeris = False
            End If
        Else                                                    ' Asteloid
            On Error Resume Next                                ' Handle all errors w.r.t. elements (format, etc.)
            CalcEphemeris = MinorPlanet(buf, Name, RightAscension, Declination, RightAscensionRate, DeclinationRate)
            If Err.Number <> 0 Then
                Util.Console.PrintLine "Bad asteroid elements: " & Err.Description
                CalcEphemeris = False
            End If
        End If
        Set RX = Nothing
    Else
        CalcEphemeris = False                                   ' Nothing we can recognize
    End If

End Function


'----------------------------------------------------------------------------------------
' -------
' DeepSky - Return the J2000 coordinates of an object in the MiniSAC database
' -------
'
'----------------------------------------------------------------------------------------
Function DeepSky(Name, RightAscension, Declination)
    Dim cat
    
    Set cat = CreateObject("MiniSAC.Catalog")                   ' Hook up to MiniSAC
    If Not cat.SelectObject(Name) Then                          ' Try to find object
        DeepSky = False                                         ' Just return False
        RightAscension = 0
        Declination = 0
    Else                                                        ' Found it!
        DeepSky = True                                          ' Return True and coordinates
        RightAscension = cat.RightAscension
        Declination = cat.Declination
    End If
    Set cat = Nothing                                           ' Release our MiniSAC
    
End Function

'----------------------------------------------------------------------------------------
' ----------------
' PackedToJulian() - Convert packed date to UTC Julian. 
' ----------------
'
' Uses PCODE and YCODE tables for MPC packed conversions
'----------------------------------------------------------------------------------------
Function PackedToJulian(Packed) 
    Dim yr, mo, dy
    
    yr = (17 + InStr(YCODE, Left(Packed, 1))) * 100             ' Century
    yr = yr + CInt(Mid(Packed, 2, 2))                           ' Year in century   
    mo = InStr(PCODE, Mid(Packed, 4, 1))                        ' Month (1-12)
    dy = CDbl(InStr(PCODE, Mid(Packed, 5, 1)))                  ' Day (1-31)
    PackedToJulian = DateToJulian(yr, mo, dy)                   ' UTC Julian Date
    
End Function

'----------------------------------------------------------------------------------------
' --------------
' DecodeFilter()
' --------------
'
' Use the MaxIM filter name array to convert a filter name
' into a filter number. If fails, log it and use the clear
' filter. 
'----------------------------------------------------------------------------------------
Function DecodeFilter(FilterName)
    Dim buf, i
    
    If IsNumeric(FilterName) Then
        i = CInt(FilterName)
        If i >= 0 And i <= UBound(c_filterNames) Then           ' Legal numeric?
            DecodeFilter = CInt(FilterName)                     ' Make integer
        Else
            Util.Console.PrintLine "**Bad filter number " & i & ", using " & _
                        c_filterNames(Util.Prefs.CameraPrefs.ClearFilterNumber) & "."
            DecodeFilter = Util.Prefs.CameraPrefs.ClearFilterNumber
        End If
        Exit Function                                           ' DONE!
    End If
    
    buf = LCase(FilterName)
    For i = 0 To UBound(c_filterNames)
        If buf = LCase(c_filterNames(i)) Then                   ' Matched name
            DecodeFilter = i                                    ' Return index
            Exit Function                                       ' DONE!
        End If
    Next
    
    Util.Console.PrintLine "**Bad filter name " & FilterName & ", using " & _
                c_filterNames(Util.Prefs.CameraPrefs.ClearFilterNumber) & "."
    DecodeFilter = Util.Prefs.CameraPrefs.ClearFilterNumber     ' DONE!
    
End Function


'----------------------------------------------------------------------------------------
' ------------
' FilterName() - Convert a filter number to a name using the array. 
' ------------
'
' Log and return clear name if out of range
'----------------------------------------------------------------------------------------
Function FilterName(FilterNumber)
    Dim i
    
    If FilterNumber < 0 Or FilterNumber > UBound(c_filterNames) Then
        i = FilterNumber                                        ' Copy bad index
        FilterNumber = Util.Prefs.CameraPrefs.ClearFilterNumber ' Change to clear
        Util.Console.PrintLine "**Bad filter number " & i & ", returning " & _
                    c_filterNames(FilterNumber) & "."
    End If
    FilterName = c_filterNames(FilterNumber)
    
End Function


'----------------------------------------------------------------------------------------
' --------------
' FilterExists() - Test If a Filter exists (by name or number)
' --------------
'
' Used To avoid substitution of Clear Filter In above methods And SelectFilter()
'----------------------------------------------------------------------------------------
Function FilterExists(FilterName)
    Dim buf, i
    
    If IsNumeric(FilterName) Then
        If FilterName >= 0 And FilterName <= UBound(c_filterNames) Then
            FilterExists = True
            Exit Function
        End If
    Else
        buf = LCase(FilterName)
        For i = 0 To UBound(c_filterNames)
            If buf = LCase(c_filterNames(i)) Then               ' Matched name
                FilterExists = True                             ' Exists...
                Exit Function                                   ' DONE!
            End If
        Next
    End If
    FilterExists = False                                        ' Assume doesn't exist

End Function


'----------------------------------------------------------------------------------------
' -------------------
' DecodeReadoutMode()
' -------------------
'
' Given a readout mode name, return the readout mode number for MaxIm. Log and use the
' "normal" readout mode if the number desn't exist. Return 0 if no readout mode supported.
'----------------------------------------------------------------------------------------
Function DecodeReadoutMode(ReadoutModeName)
    Dim buf, i
    
    If IsNumeric(ReadoutModeName) Then
        i = CInt(ReadoutModeName)
        If i >= 0 And i <= UBound(c_ReadoutModes) Then           ' Legal numeric?
            DecodeReadoutMode = CInt(ReadoutModeName)            ' Make integer
        Else
            Util.Console.PrintLine "**Bad readout mode number " & i & ", using " & _
                        c_normalReadoutMode & "."
            DecodeReadoutMode = c_normalReadoutMode
        End If
        Exit Function                                           ' DONE!
    End If
    
    buf = LCase(ReadoutModeName)
    For i = 0 To UBound(c_ReadoutModes)
        If buf = LCase(c_ReadoutModes(i)) Then                  ' Matched name
            DecodeReadoutMode = i                               ' Return index
            Exit Function                                       ' DONE!
        End If
    Next
    
    Util.Console.PrintLine "**Bad readout mode name " & ReadoutModeName & ", using " & _
                c_ReadoutModes(c_normalReadoutMode) & "."
    DecodeReadoutMode = c_normalReadoutMode                     ' DONE!
        
End Function

'----------------------------------------------------------------------------------------
' -----------------
' ReadoutModeName() - Convert a readout mode number to a name using the array. 
' -----------------
'
' Return "none" if out of range
'----------------------------------------------------------------------------------------
Function ReadoutModeName(ReadoutModeNumber)
    
    If ReadoutModeNumber < 0 Or ReadoutModeNumber > UBound(c_readoutModes) Then
        Util.Console.PrintLine "**Bad readout mode number " & ReadoutModeNumber
        ReadoutModeName = "none"
    Else
        ReadoutModeName = c_readoutModes(ReadoutModeNumber)
    End If
    
End Function

'----------------------------------------------------------------------------------------
' -------------------
' ReadoutModeExists() - Test If a ReadoutMode exists (by name or number)
' -------------------
'
' Used by compiler in live mode to report bad readout modes
'----------------------------------------------------------------------------------------
Function ReadoutModeExists(ReadoutModeName)
    Dim buf, i
    
    If IsNumeric(ReadoutModeName) Then
        If ReadoutModeName >= 0 And ReadoutModeName <= UBound(c_filterNames) Then
            ReadoutModeExists = True
            Exit Function
        End If
    Else
        buf = LCase(ReadoutModeName)
        For i = 0 To UBound(c_readoutModes)
            If buf = LCase(c_readoutModes(i)) Then              ' Matched name
                ReadoutModeExists = True                        ' Exists...
                Exit Function                                   ' DONE!
            End If
        Next
    End If
    ReadoutModeExists = False                                   ' Assume doesn't exist

End Function

'----------------------------------------------------------------------------------------
' -----------------------
' J2000ToLocalTopocentric
' -----------------------
'
' Public method to convert J200 to local topo. Returned coordinates are in properties
' LocalTopoRA and LocalTopoDec (for JScript usage, no ref parameters).
'----------------------------------------------------------------------------------------
Sub J2000ToLocalTopocentric(RightAscension, Declination)

    Call CvtLocalTopo(RightAscension, Declination, c_localTopoRA, c_localTopoDec)
    
End Sub

'----------------------------------------------------------------------------------------
' -----------------------
' LocalTopocentricToJ2000
' -----------------------
'
' Public method to convert local topo to J2000. Returned coordinates are in properties
' J2000RA and J2000Dec (for JScript usage, no ref parameters).
'----------------------------------------------------------------------------------------
Sub LocalTopocentricToJ2000(RightAscension, Declination)

    Call CvtJ2000(RightAscension, Declination, c_J2000RA, c_J2000Dec)
    
End Sub

'----------------------------------------------------------------------------------------
' --------------
' MakeFileName()
' --------------
'
' Make a legal file name from a target name. This removes not only the characters that
' are illegal in Windows file names, but also the parentheses that would otherwise 
' trigger special file operations in PinPoint if present. An attempt is made to make 
' the resulting file name recognizeable from the target name. 
'
' Returns legal file name, safe to use with PinPoint.
'----------------------------------------------------------------------------------------
Function MakeFileName(TargetName)
    Dim rx
    
    Set rx = New RegExp 
    rx.Global = True                                    ' Replace throughout the String
    MakeFileName = TargetName                           ' Start with target name
    '
    ' (1) Remove <([])> completely
    '
    rx.Pattern = "[\<\(\[\]\)\>]"
    MakeFileName = rx.Replace(MakeFileName, "")
    '
    ' (2) Replace other illegal charachters with "-"
    '
    rx.Pattern = "[\\\/\:\*\?\""\|]"
    MakeFileName = rx.Replace(MakeFileName, "-")
  
    Set rx = Nothing                                    ' Not really needed but..
End Function

'----------------------------------------------------------------------------------------
' ----------------
' FindBrightStar() - Find the brightest nearby mag 6-9 star
' ----------------
'
' Searches a N degree square around the given RA/Dec. Returns the RA/Dec/Mag of the 
' brightest mag M-N star in the area, omitting any that have another star within
' 10 arcseconds. Return True if succeeded, else False. Search area and mag range are
' now set as properties BrightStarXxx see below. If FilterInfo is available, though,
' the bright and faint mag range is taken from that instead of the c_brightStarXxxMag
' globals.
'----------------------------------------------------------------------------------------
Function FindBrightStar(RightAscension, Declination, FilterNumber, raStar, decStar, magStar)
    Dim i, j, PL, A(), nCross, HASafe, CT, CS, CSX, S, SX, SX2, D, DS, RA, sz, limOK
    Dim magMax, magMin, magThis
    
    Set PL = CreateObject("PinPoint.Plate")
    PL.Catalog = Util.Prefs.ReferenceCatalogType
    PL.CatalogPath = Util.Prefs.ReferenceCatalogPath
    '
    ' (see below, scale is 6 arcmin/pix)
	sz = (c_brightStarSearchDeg * 10) - 1						' Upper index of image array for search area
	ReDim A(sz, sz)
    For i = 0 To sz
        For j = 0 To sz
            A(i,j) = CLng(0)
        Next
    Next
    PL.ImageArray = A
    PL.ArcsecPerPixelHoriz = 360								' 6 arcmin/pix
    PL.ArcsecPerPixelVert = 360
    PL.RollAngle = 0
    PL.Equinox = 2000 
    PL.ProjectionType = 1
    PL.CatalogExpansion = 0.0                                   ' No expansion!!!
    '
    ' Unfortunately PinPoint 5.1 uses V mags for mag range filtering
    ' and these are synthesized in the catalogs. For bright stars these 
    ' values can be spectacularly wrong. Thus, we need to do our own
    ' filtering after calling FindCatalogStars. So we set a wide range here.
    ' Sorry to say but it looks like this made it into PinPoint 6, see
    ' See PINPOINT-1089. For PinPoint 6, though, we will use the Red 
    ' magnitude for filtering since all catalogs must have Red as of 6.
    '
'     If c_haveFilterInfo Then
'         PL.CatalogMinimumMagnitude = c_filterBrightMag(FilterNumber)
'         PL.CatalogMaximumMagnitude = c_filterFaintMag(FilterNumber)
'     Else
'         PL.CatalogMinimumMagnitude = c_brightStarMinMag
'         PL.CatalogMaximumMagnitude = c_brightStarMaxMag
'     End If
    PL.CatalogMinimumMagnitude = 0.0
    PL.CatalogMaximumMagnitude = 11.0
    PL.ExposureStartTime = Now()                                ' PP5 requires this
    '
    ' If German Mount, avoid flipping. Force entire search area to be 
    ' on the same side we're currently on. Watch it, the signs are 
    ' a head-bender since HA an is negative east and flip limits are 
    ' HA's in degrees. 
    '
    If Util.ScriptTelescope.AlignmentMode = 2 Then
        If Util.GEMWestOfPier Then                              ' Looking west now
            EquOffset Util.ScriptTelescope.SiderealTime, Declination, _
                        -((Util.Prefs.GEMFlipEastbound + c_brightStarSearchDeg) * 60), 0   ' Westward
''_         Trace "  East limit at " & Util.Hours_HMS(c_equOffsetRA)
            HASafe = RightAscension - c_equOffsetRA
            If HASafe < -12 Then HASafe = HASafe + 24
            If HASafe > 12 Then HASafe = HASafe - 24
''_         Trace "  HASafe = " & Util.FormatVar(HASafe, "0.0000")
            If HASafe < 0 Then
                PL.RightAscension = RightAscension
            Else
                Util.Console.PrintLine "  (offset to west to avoid flip)"
                PL.RightAscension = c_equOffsetRA
            End If
        Else                                                    ' If on East side
            EquOffset Util.ScriptTelescope.SiderealTime, Declination, _
                        ((Util.Prefs.GEMFlipWestbound + c_brightStarSearchDeg) * 60), 0    ' Eastward
''_         Trace "  West limit at " & Util.Hours_HMS(c_equOffsetRA)
            HASafe = RightAscension - c_equOffsetRA
            If HASafe < -12 Then HASafe = HASafe + 24
            If HASafe > 12 Then HASafe = HASafe - 24
''_         Trace "  HASafe = " & Util.FormatVar(HASafe, "0.0000")
            If HASafe > 0 Then
                PL.RightAscension = RightAscension
            Else
                Util.Console.PrintLine "  (offset to east to avoid flip)"
                PL.RightAscension = c_equOffsetRA
            End If
        End If
    Else
        PL.RightAscension = RightAscension
    End If
    PL.Declination = Declination
    Util.Console.PrintLine "  Search " & c_brightStarSearchDeg & _
				" deg-square area for possible stars"
    Err.Clear
    On Error Resume Next
    PL.FindCatalogStars
    If Err.Number <> 0 Then
        Util.Console.PrintLine "  **FAILED** No mag 0 to 11 catalog stars found in area!"
        FindBrightStar = False
        Exit Function                                           ' FAILED, EXIT
    End If
    On Error GoTo 0
    Set CS = PL.CatalogStars
    If c_haveFilterInfo Then
        magMin = c_filterBrightMag(FilterNumber)
        magMax = c_filterFaintMag(FilterNumber)
    Else
        magMin = c_brightStarMinMag
        magMax = c_brightStarMaxMag
    End If
    Util.Console.PrintLine "  Looking for stars between mags " & magMin & " and " & magMax
    '
    ' Pick the brightest star in the area but skip 
    ' those with another star within 30 arcsec.
    '
    magStar = 1000
    nCross = 0
    Set S = Nothing
    For Each SX In CS                                           ' Cannot sort cat stars by flux!
        Set CT = Util.NewCTHereAndNow()
        CT.RightAscension = SX.RightAscension
        CT.Declination = SX.Declination
'       =========================
        magThis = SX.RedMagnitude                               ' PP6 use Red mags
'       =========================
        If Not IsBadBrightStar(SX.RightAscension, SX.Declination) Then  ' Weed out known bad ones
            '
            ' For speed we skip precessing to Local Topo. Just give a 1 deg. buffer
            ' to avoid hitting the limit when we actually slew.
            '
            limOK = True
            Select Case Util.ScriptTelescope.AlignmentMode
                Case 0:                                         ' AltAz
                    If CT.Elevation > Util.Prefs.TiltUpLimit - 1.0 Then limOK = False
                Case 1:                                         ' Polar
                    If Abs(SX.Declination) > Util.Prefs.TiltUpLimit - 1.0 Then limOK = False
                Case 2:                                         ' German
                    If CT.Elevation > Util.Prefs.TiltUpLimit - 1.0 Then limOK = False
            End Select
            If CT.Elevation > Util.Prefs.GetHorizon(CT.Azimuth) + 1.0 And _
                    CT.Elevation > Util.Prefs.MinimumElevation And _
                    limOK And _
                    magThis >= magMin And _
                    magThis <= magMax And _
                    magThis < magStar Then                      ' Find brightest eligible cat star
                ' Throw out stars that would cause a flip
                ' This is OK for non-German mounts and simplifies logic
                If (Util.GEMWestOfPier And Util.IsGEMDestinationWest(SX.RightAscension, SX.Declination)) Or _
                        (Not Util.GEMWestOfPier And Not Util.IsGEMDestinationWest(SX.RightAscension, SX.Declination)) Then
                    Set SX2 = PL.CatalogStars                       ' Need another CatStars collection
                    SX2.Sort 3, 0, SX.RightAscension, SX.Declination ' Sort by distance from this one
                    '
                    ' This gets the distance to the nearest star from 
                    ' this one. The first member of the sorted collection 
                    ' IS this star, the next one (SX2(2) is the nearest.
                    '
                    D = EquDist(SX.RightAscension, SX.Declination, _
                                    SX2(2).RightAscension, SX2(2).Declination) * 3600.0
                    If D > 30.0 Then
                        magStar = magThis
                        Set S = SX
                        DS = D
                    End If
                Else
                    nCross = nCross + 1
                End If
            End If
        End If
    Next
    If S Is Nothing Then
        FindBrightStar = False
        Exit Function                                           ' DONE! NO CANDIDATES!
    End If
    On Error GoTo 0
    If Util.ScriptTelescope.AlignmentMode = 2 And nCross > 0 Then _
        Util.Console.PrintLine "  (skipped " & nCross & " stars that would have flipped mount)"
    Util.Console.PrintLine "  Found mag " & Util.FormatVar(magStar, "0.0") & _
                    " star, " & S.Identification & "; nothing within " & _
                    Util.FormatVar(DS, "0") & " arcsec."
    raStar = S.RightAscension
    decStar = S.Declination
    Util.Console.PrintLine "  Star J2000 coordinates RA=" & Util.Hours_HMS(raStar) & _
                    " Dec=" & Util.Degrees_DMS(decStar)
    FindBrightStar = True                                       ' Got it!
    
End Function

'----------------------------------------------------------------------------------------
' -------------------------
' CalcSimImageCoordinates() - Calculate sim image with pointing and random errors
' -------------------------
'
' Compute new offset locations for the image simulator. If the pointing
' corrector is turned on, use the error generator to generate pointing 
' errors. Then, in any case, generate random errors that increase with the 
' slew distance up to 40 deg.
'
' Resulting J2000 image coordinates in c_simImageRA and c_simImageDec
'----------------------------------------------------------------------------------------
Sub CalcSimImageCoordinates(RightAscension, Declination)
    Dim rRA, rDec, iRA, iDec, msg, sd, erms, dr, dd, ptgerr
    
    If Util.PointingCorrectionEnabled Then
        Call Util.MapIdealToRawEqu(RightAscension, Declination, rRA, rDec)    ' Map out with our model
        ptgerr = GEN.MapRawToIdealEqu(rRA, rDec, iRA, iDec)                   ' Map in with GEN
        msg = "mechanical and random"
    Else
        rRA = RightAscension                                ' Pointing corr off
        rDec = Declination
        If MECH_ERRORS_ALWAYS Then                          ' If still want mechanical errors
            ptgerr = GEN.MapRawToIdealEqu(rRA, rDec, iRA, iDec) ' Map in with GEN
            msg = "mechanical and random"
        Else
            iRA = RightAscension                            ' Random only
            iDec = Declination
            msg = "random"
        End If
    End If
''- Trace "      ([imagesim] Raw " & Util.Hours_HMS(rRA) & " " & Util.Degrees_DMS(rDec) & ")"
''- Trace "      ([imagesim] Img " & Util.Hours_HMS(iRA) & " " & Util.Degrees_DMS(iDec) & ")"
''- Trace "      ([imagesim] err=" & Util.FormatVar(ptgerr * 60, "0.000") & " arcmin)"
    '
    ' This mixes local topo and J2000, but is used only for random error scaling
    ' Can't use c_lastSyncRA/Dec because sync may be disabled
    sd = EquDist2(Util.ScriptTelescope.RightAscension, Util.ScriptTelescope.Declination, _
                    RightAscension, Declination)            ' Slew distance, deg
    '
    ' Assume this mount has increasing errors up to 
    ' Util.Prefs.PointingUpdates.MaximumSlew, after
    ' that apply the full RMS error.
    '
    If sd < Util.Prefs.PointingUpdates.MaximumSlew Then
        erms = c_simPosErrRMS * sd / Util.Prefs.PointingUpdates.MaximumSlew ' Scaled RMS Error, arcmin
    Else
        erms = c_simPosErrRMS                               ' Max RMS Error, arcmin
    End If
''- Trace "      ([imagesim] slew dist " & Util.FormatVar(sd, "0.00") & " deg, RMS error = " & _
''-                     Util.FormatVar(erms, "0.0000") & " arcmin)"
    dr = GaussRand(erms)                                    ' Gaussian deviate of RA, arcmin
    dd = GaussRand(erms)                                    ' Gaussian deviate of Dec, arcmin
    Call EquOffset(iRA, iDec, dr, dd)                       ' Offset coordinates by deviates, arcmin
    c_simImageRA = c_equOffsetRA
    c_simImageDec = c_equOffsetDec
''- Trace "      ([imagesim] randerr = " & Util.FormatVar(EquDist2(iRA, iDec, _
''-                     c_simImageRA, c_simImageDec) * 60, "0.000")
''- Trace "      ([imagesim] simulating " &  Util.FormatVar(EquDist2(rRA, rDec, _
''-                     c_simImageRA, c_simImageDec) * 60.0, "0.000") & _
''-                     " arcmin " & msg & " pointing error)"
End Sub


'----------------------------------------------------------------------------------------
' ----------------
' StartRotateToPA
' ----------------
'
' Start rotating to the given IMAGER PA. Raises error if no rotator or rotator vaporizes
' If the scope is a GEM, and it's looking west, roll the imager over to Preserve
' the sky PA. The RA is the TARGET RA  for west-rollover. Cannot use current RA (via 
' Util.GemWestOfPier()) because the scope may be slewing and not yet on the destination side.
'
' NOTE: NOT USING DEC HERE --
'----------------------------------------------------------------------------------------
Sub StartRotateToPA(ByVal PA, RA)                           ' Protect caller against PA flipping
    Dim PARaw

    If Util.Prefs.PointingUpdates.Simulate Then
        c_simImagePA = RangeAngle(PA + c_simImagePAOffset + ROT.PABias, 0.0, 360.0) ' For image simulator, offset PA
    End If
    PARaw = PA + ROT.PABias                        ' Convert from desired/cam to rotator PA
    If Util.IsGEMDestinationWest(RA, 0.0) Then  PARaw = PARaw + 180.0 ' If GEM (will be) west, roll the imager over
    PARaw = RangeAngle(PARaw, 0.0, 360.0)                   ' Range the raw PA 0-360
    Util.Console.PrintLine "  Start rotate to PA " & Util.FormatVar(PA, "0.0") & _
                " deg (raw rotator angle " & Util.FormatVar(PARaw, "0.0") & ")"
    Call ROT.MoveAbsolute(PARaw)                            ' Move the rotator
    
End Sub

'----------------------------------------------------------------------------------------
' ----------------
' WaitForRotator
' ----------------
'
' Wait for rotator to stop moving. Raises error if rotator vaporizes.
' Don't report if entered with rotator not moving.
'----------------------------------------------------------------------------------------
Sub WaitForRotator()
    Dim wasMoving
    
    If Not c_haveRotator Then Exit Sub
    If ROT.IsMoving Then
        wasMoving = True
        Util.Console.PrintLine "  (wait for rotator)"
    Else
        wasMoving = False
    End If
    Do While ROT.IsMoving
        Util.WaitForMilliseconds 1000
    Loop
    If wasMoving Then Util.Console.PrintLine "  (rotation complete)"
    
End Sub

' =================
' SUPPORT FUNCTIONS
' =================

'----------------------------------------------------------------------------------------
' ----------------
' CvtLocalTopo
' ----------------
'
' Internal routine to convert J2000 coordinates to local topocentric. Avoids use of
' globals by returning through reference parameters, which aren't usable in JScript.
' For public method, use J2000ToLocalTopocentric()
'----------------------------------------------------------------------------------------
Sub CvtLocalTopo(RAJ2K, DecJ2K, RALoc, DecLoc)
    Dim ujd, tjd, site, objv, tvec
    
    '
    ' Convert J2000 to Local topocentric (w/optional refraction)
    '
    Set site = CreateObject("NOVAS.Site")
    site.Latitude = Util.ScriptTelescope.SiteLatitude
    site.Longitude = Util.ScriptTelescope.SiteLongitude
    site.Height = Util.ScriptTelescope.SiteElevation
    site.Temperature = Util.Prefs.SiteTemperature

    Set objv = CreateObject("NOVAS.Star")
    objv.RightAscension = RAJ2K
    objv.Declination = DecJ2K
    ujd = Util.SysJulianDate
    tjd = ujd + (Util.DeltaT(ujd) / 86400)
    Set tvec = objv.GetTopocentricPosition(tjd, site, Util.Prefs.DoRefraction)
    RAloc = tvec.RightAscension
    DecLoc = tvec.Declination
    Set objv = Nothing
    Set tvec = Nothing
''  Trace "      ([cvtltpo] local topo coords: RA = " & Util.Hours_HMS(RAloc) & _
''                          "  Dec = " & Util.Degrees_DMS(DecLoc) & ")"
End Sub

'----------------------------------------------------------------------------------------
' --------
' CvtJ2000 - Convert local topo to J2000
' --------
'
' Internal routine to convert local topocentric coordinates to J2000. Avoids use of
' globals by returning through reference parameters, which aren't usable in JScript.
' For public method, use LosalTopocentricToJ2000(). This is slow, uses iteration.
'----------------------------------------------------------------------------------------
Sub CvtJ2000(RALoc, DecLoc, RAJ2K, DecJ2K)
    Dim I, SL, PL, SJ, PJ, Px, dx, dy, dz
    Dim ujd, tjd, site
    
    Set site = CreateObject("NOVAS.Site")                       ' Site info
    site.Latitude = Util.ScriptTelescope.SiteLatitude
    site.Longitude = Util.ScriptTelescope.SiteLongitude
    site.Height = Util.ScriptTelescope.SiteElevation
    site.Temperature = Util.Prefs.SiteTemperature
    
    ujd = Util.SysJulianDate
    tjd = ujd + (Util.DeltaT(ujd) / 86400)                      ' Terrestrial JD

    Set SL = CreateObject("NOVAS.Star")
    SL.RightAscension = RALoc
    SL.Declination = DecLoc
    Set PL = SL.GetAstrometricPosition(tjd)                     ' Local topo position vector
    
    Set SJ = CreateObject("NOVAS.Star")                         ' Will be J2K, start at local topo
    SJ.RightAscension = RALoc
    SJ.Declination = DecLoc
    
    For I = 0 To 3                                              ' 4 Iterations should be PLENTY (2 is typical)
        Set Px = SJ.GetTopocentricPosition(tjd, site, Util.Prefs.DoRefraction)  ' J2K-guess to local topo
        
        If EquDist2(RALoc, DecLoc, Px.RightAscension, Px.Declination) < 0.00002778 Then  ' If less than 0.1 arcsec
            Exit For                                            ' *DONE* Converged
        End If
        
        dx = PL.x - Px.x                                        ' Difference from real local topo
        dy = PL.y - Px.y
        dz = PL.z - Px.z
        
        Set PJ = SJ.GetAstrometricPosition(tjd)                 ' Get J2K position vector
        PJ.x = PJ.x + dx                                        ' Adjust back by difference
        PJ.y = PJ.y + dy
        PJ.z = PJ.z + dz
        SJ.RightAscension = PJ.RightAscension                   ' Plug back into J2K guess
        SJ.Declination = PJ.Declination
    Next

    If I > 4 Then                                               ' Failed to converge?
        Err.Raise vbObjectError, "Acp.AcquireSupport", _
                "LocalTopo to J2000 failed to converge"
    End If
    
    RAJ2K = PJ.RightAscension
    DecJ2K = PJ.Declination
    
End Sub

'----------------------------------------------------------------------------------------
' -----------
' GetPosVel() - Compute position and velocity (coordinate rates) of solar system body
' -----------
'
' This uses a cheapo linear extrapolation. Eventually, NOVAS needs to be updated
' to provide a VelocityVector for a Planet. The delta t is increased to provide at
' least 20 arcseconds movement. This hopefully avoids roundoff errors on slow moving 
' objects. It projects forward in time rather than bracketing the given time, since 
' the data will be taken in the future.
'
' pl      = [in]  NOVAS.Planet object
' TJD     = [in]  Terrestrial Julian Date for position
' RA      = [out] Right Ascension, hours
' Dec     = [out] Declination, degrees
' RADot   = [out] RightAscension Rate, seconds per Second
' DecDot  = [out] Declination Rate, arcseconds per second
'----------------------------------------------------------------------------------------
Function GetPositionAndVelocity(pl, TJD, RA, Dec, RADot, DecDot)
    Dim dt, tvec1, tvec2, x, y, i
    
    dt = (5.0 / 1440.0)                                         ' Start with 5 minute interval
    Set tvec1 =  pl.GetAstrometricPosition(TJD)                 ' Get current position
    RA = tvec1.RightAscension
    Dec = tvec1.Declination
    '
    ' Keep doubling the interval until we get 30 arcsec total movement.
    ' If we don't get there in 13 or fewer steps (28 days), something is 
    ' wrong. We should get that on TNOs.
    '
    For i = 1 To 13                                             ' Goes out to 28 day interval
        Set tvec2 = pl.GetAstrometricPosition(TJD + dt)
        If EquDist(tvec1.RightAscension, tvec1.Declination, _
                        tvec2.RightAscension, tvec2.Declination) > 0.0083334 Then
            '
            ' Moves "enough", calculate coordinate rates
            '
            x = tvec2.RightAscension - tvec1.RightAscension
            If x < -12.0 Then x = x + 12.0
            If x > 12.0 Then x = x - 12.0
            RADot = (3600.0 * x) / (dt * 86400.0)               ' RA coordinate rate sec/sec
            If Abs(x) > 6.0 Then                                ' Moved across pole
                y = tvec2.Declination + tvec1.Declination       ' Total dec movement is sum
                If Dec >= 0.0 Then                              ' Moved across north pole
                    y = 180.0 - y
                Else                                            ' Moved across south pole
                    y = -180.0 - y
                End If
            Else                                                ' Same side of pole
                y = tvec2.Declination - tvec1.Declination
            End If
            DecDot = (3600 * y) / (dt * 86400.0)                ' Dec rate arcsec/sec
            Set tvec1 = Nothing
            Set tvec2 = Nothing
            Exit Function                                       ' == SUCCESS, EXIT FUNCTION ==
        End If
        dt = 2.0 * dt
    Next
    Set tvec1 = Nothing
    Set tvec2 = Nothing
    Err.Raise vbObjectError, "ACP.AcquireSupport", _
        "Ephemeris velocity calculation failed."
    
End Function

'----------------------------------------------------------------------------------------
' ----------------------
' GetGuiderMeasurement() - Wait until guider makes a successful measurement then return it
' -----------------------
'
' Waits while the guider is running, until a new measurement is available, Then
' immediately gets and returns the X and Y errors via ref parameters. Returns True 
' or False to indicate successful retrieval of errors.
'
' Uses c_GuideExpCur, the currently selected guider exposure interval. Wait for 5 exposure 
' intervals, that should be plenty to include the cycle time.
'----------------------------------------------------------------------------------------
Function GetGuiderMeasurement(errX, errY)
    Dim i, maxWait, Camera
    
    Set Camera = Util.ScriptCamera
    
    errX = 0
    errY = 0
    i = 0
    maxWait = 5 * c_guideExpCur                                 ' Max waiting time
    If maxWait < 10 Then maxWait = 10                           ' Always wait at least 10 sec!
    Do While Camera.GuiderRunning And _
                Not Camera.GuiderNewMeasurement
        Util.WaitForMilliseconds 1000                           ' Wait 1 sec and check again
        i = i + 1                                               ' Seconds waited so far
        If i > maxWait Then                                     ' If waited 3 total cycles
            Util.Console.PrintLine "**Guider waited for " & maxWait & _
                                    " sec and never got a measurement"
            Camera.GuiderStop                        ' Stop the guider now
            c_guiding = False                                   ' Reset control var
            GetGuiderMeasurement = False                       ' Guide star faded!
            Exit Function
        End If
    Loop
    If Not Camera.GuiderRunning Then                            ' Guider stopped?
        Util.Console.PrintLine _
                "**Guider unexpectedly stopped while waiting for measurement"
        GetGuiderMeasurement = False                           ' Failed!
    Else
        errX = Camera.GuiderXError
        errY = Camera.GuiderYError
        GetGuiderMeasurement = True                            ' Success!
    End If
   
End Function


'----------------------------------------------------------------------------------------
' -------------
' SetupGuider() - Set up the guider for tracking
' -------------
'
' Selects an appropriate guide star and scales the given exposure interval so that
' it is as short as possible while ensuring that the selected guide star is at
' least 6 sigma above the mean background. Set the guide star position in MaxIm
' and return the adjusted exposure interval. CALLER IS RESPONSIBLE FOR EXPOSURE
' INTERVAL LIMITS!
'
' Thanks to ACP customer Samuel Lising for the MaxIm Multi-Star guiding magic
'
' Parameters:
'   SelectStar                  Select star in field. Avoid bright neighbors and
'                               saturated stars in wide field guiders.
'   ExposureInterval            The initial or last guess at the exposure interval
'   SavePreview                 Save full size and track box size preview PNG
'
' Return
'   Adjusted exposure interval
'
' Side-Effects:
'   If SelectStar is true, and a choice succeeds, sets c_guideStarX and c_guideStarY to 
'   chosen star and selects the chosen star in the guider (GuiderSelectStar()), 
'   If SavePreview is true, Creates trackbox thumbnail and full image preview images.
'----------------------------------------------------------------------------------------
Function SetupGuider(SelectStar, ExposureInterval, SavePreview)
    Const ChipBorder = 24                                       ' Width of "don't use" border, pixels
    
    Dim Camera, Console, GA, P, SizeX, SizeY, StarList, Star, S2, LowestSatStar
    Dim StarOK, bgFlux, SNR, xyd, z, i, snrStr
    Dim doc, fitsTmpPath, tboxPath, fullPath, fullTxPath, fullTxFile
        
    Set Camera = Util.ScriptCamera                              ' Convenience shortcut
    Set Console = Util.Console
    '
    ' If doing Multi_Star guiding, must let MaxIm make the choice of "star"
    ' if SelectStar is true. Otherwise we just do the successive adjustments 
    ' using whatever star was chosen, either by us for single star or by
    ' MaxIm for Multi-Star. 
    '
    If SelectStar Then
        If c_multiStarGuiding Then
            Camera.GuiderAutoSelectStar = True
''-         Trace "[stpgdr] Multi-star, SelectStar is True, MaxIm chooses star."
        Else
            Camera.GuiderAutoSelectStar = False
''-         Trace "[stpgdr] Single-star, SelectStar is True, ACP does star selection."
        End If
    Else                
        Camera.GuiderAutoSelectStar = False 
''-     Trace "[stpgdr] SelectStar is False, refinement pass, use previously selected star."
    End If          
    '
    ' Take a star selection exposure
    '
''- Trace "[stpgdr] Starting exposure is " & ExposureInterval & " sec."
    Util.UserInterfaceLive = False                              ' Put ACP UI to sleep for faster image download
    Camera.GuiderExpose(ExposureInterval)                       ' Take a full frame
    Util.WaitforMilliseconds 1000
    Do While Camera.GuiderRunning = True                        ' Must use camera's GuiderRunning for AO!
        Util.WaitForMilliseconds 1000
    Loop
    Util.WaitforMilliseconds 1000
    Util.UserInterfaceLive = True                               ' Wake up ACP user interface
    '
    ' This is tricky. Here, for multi-star guiding we capture the 
    ' MaxIm-selected star, then act like we've been through our star
    ' selection (SelectStar = true) once, putting MaxIm's star into
    ' the c_guideStarX/c_guideStarY variables, then set SelectStar
    ' to False, forcing us into the "refinement" code below. 
    '
    If c_multiStarGuiding And SelectStar Then
        c_guideStarX = Camera.GuiderXStarPosition
        c_guideStarY = Camera.GuiderYStarPosition
        Console.PrintLine "  Multi-star guiding, MaxIm chose star at X=" & c_guideStarX & " Y=" & c_GuideStarY
''-     Trace "[stpgdr] Now set SelectStar to False because we only need exposure refinement"
        SelectStar = False
    End If
    '
    ' Attach the guider array to PinPoint, detect stars, sort by flux
    '
    GA = Camera.GuiderArray                                     ' This allows conversion of array type
    SizeX = UBound(GA, 1)
    SizeY = UBound(GA, 2)
    Trace "[guider] Guider detector is " & SizeX & " by " & SizeY & " pixels in size"
    '
    ' NOTE WELL: PinPoint stores its arrays in row-major order
    ' which is the reverse of the MaxIm array. Thus, PinPoint's 
    ' Y is X etc. It's confusing but harmless. Just keep this in mind.
    ' It is actually documented in the PinPoint help file.
    '
    Set P = CreateObject("PinPoint.Plate")                      ' Plate for selection etc.
    P.ImageArray = GA                                           ' PinPoint now has guider Array
    P.ArcsecPerPixelHoriz = 1.0                                 ' Needed for auto aperture
    P.ArcsecPerPixelVert = 1.0                                  ' (1.0 makes arcsec = pixels)
    P.CentroidAlgorithm = 0                                     ' Really need aperture for scaling of this!
    P.InnerAperture = 8                                         ' Need fixed apertures too
    P.OuterAperture = 24
    If c_HaveAOx Then                                           ' AO can use faint stars
        P.SigmaAboveMean = 2.0
    Else
        P.SigmaAboveMean = 4.0
    End If
    P.RemoveHotPixels 0.1                                       ' Don't trip on hot pixels
    Call P.FindImageStars()                                     ' Scan the guider image for stars
    While Not P.ImageStarsReady 
        Util.WaitForMilliseconds 500
    Wend
    Set StarList = P.ImageStars                                 ' Get the detected star collection
    
       
    If StarList.Count = 0 Then
        Console.PrintLine "**No stars at all found in guider image"
        P.DetachFITS
        Set P = Nothing
        SetupGuider = -1                                        ' Failure Sentinel
        Exit Function                                           ' === EXIT with failure ===
    End If
    
    Call StarList.Sort(0, 1)                                    ' Sort detected stars by decreasing raw flux
    
    '
    ' StarList now contains PlateStar objects for all detected stars
    ' in the guider image, sorted in order of decreasing flux 
    ' (brightest first). 
    '
    ' Single Star guiding with SelectStar = True
    ' ------------------------------------------
    '
    ' Then find the SNR of the selected star. We use a
    ' counting loop to allow us to detect duplicate detections. The 
    ' screwy logic below is needed because VBS doesn't have "short
    ' circuit booleans" and would evaluate all terms in a single If
    ' statement, leading to collection index out of range on i-1.
    '
    ' Note: people who are concerned with photometry will take 
    ' a different view of SNR, in that they want to account for the 
    ' contribution of photon shot noise from the starlight itself.  
    ' So their SNR measurements will be the same for faint stars, 
    ' but will diverge for bright ones (will be lower).
    '
    ' Skip double star detection on internal guiders. Misshapen stars 
    ' can create apparent nearby neighbors. User is responsible for 
    ' picking guide star, and he should not pick one with a neighbor!
    '
    If SelectStar Then
        Set LowestSatStar = Nothing                             ' [sentinel] Will contain the saturated star with the least flux
        For i = 1 To StarList.Count                             ' Run through from brightest on down
            Set Star = StarList.Item(i)
''-         Trace "[stpgdr] Star at [" & Util.FormatVar(Star.Y, "0.0") & "," & Util.FormatVar(Star.X, "0.0") & "] flux=" & Star.RawFlux
            StarOK = True                                       ' Assume this star is OK
            '
            ' Probably don't need this with new PSF detector, but...
            '
            If i > 1 Then                                       ' No short circuit booleans, avoid out of range
                If XYDist(Star.X, Star.Y, StarList.Item(i-1).X, StarList.Item(i-1).Y) < 1.0 Then   ' Skip Duplicates
''-                 Trace "[stpgdr] Duplicate detection, skipped."
                    StarOK = False
                End If
            End If
            
            '
            ' Avoid edge of chip
            '
            If StarOK And (Star.X <= ChipBorder Or Star.X >= (SizeY - ChipBorder) Or _
                        Star.Y <= ChipBorder Or Star.Y >= (SizeX - ChipBorder)) Then
''-             Trace "[stpgdr] Too close to edge, skipping"
                StarOK = False
            End If
            '
            ' Additional check for "wider field" guiders
            '
            If StarOK And c_guideExtern Then                    ' Skip this stuff for internal guiders!
                '
                ' Double Star detection. Assume the guider will have problems
                ' if the companion star is witin 10 pixels of the real one.
                ' Once again, we have to ignore the duplicate detections, whose
                ' centroids will always be well within one pixel of each other.
                ' Don't consider them to be companions, they are really the
                ' same star, which will work just fine for guiding.
                '
                For Each S2 In StarList                         ' Check all other stars for distance from this one
                    xyd = XYDist(Star.X, Star.Y, S2.X, S2.Y)    ' Distance to this Star
''-                 Trace "[stpgdr] xyd=" & Util.FormatVar(xyd, "0.0")
                    If xyd > 1.0 Then                           ' Ignore =those= duplicate detections too
                        If S2.RawFlux > Star.RawFlux And xyd < 20 Then
''-                         Trace "[stpgdr] xyd=" & Util.FormatVar(xyd, "0.0")
''-                         Trace "[stpgdr] Nearby brighter star could appear in trackbox, skipping this star"
                            StarOK  = False
                            Exit For                            ' Go back and try another star
                        ElseIf S2.RawFlux > (Star.RawFlux / 10) And xyd < 10 Then
''-                         Trace "[stpgdr] xyd=" & Util.FormatVar(xyd, "0.0")
''-                         Trace "[stpgdr] Nearby star > 10% flux, skipping this star"
                            StarOK = False                      ' This star has one too close
                            Exit For                            ' Stop looking for doubles Now
                        End If                            
                    End If
                Next
                '
                ' Skip saturated stars, BUT(!!) keep track of the last (and therefore
                ' lowest flux) saturated star. Remember the collection is sorted by
                ' descending flux. If, at the end of all of this, we have no stars left
                ' we'll go ahead and use that lowest-flux saturated star. The succeeding
                ' exposure scaling might just unsaturate it. This will also solve the 
                ' problem where, even on a wide field guider, there is only one bright
                ' saturated star, and the guiding logic would give up after rejecting it.
                '
                If Star.Saturated Then
''-                 Trace "[stpgdr] Saturated star, skipping"
                    StarOK = False
                    Set LowestSatStar = Star                    ' Remember this saturated star (lowest flux so far)
                End If
            End If
            '
            ' Reject stars that are "too small"
            '
            If Star.Area < MIN_GUIDE_STAR_AREA Then
                Console.PrintLine "Star at [" & Star.X & "," & Star.Y & "] is too small (" & CLng(Star.Area) & ") - Rejected" 
                StarOK = False
            End If
            If StarOK Then Exit For                             ' Hooray, it passed the tests, press on.
        Next
        If Not StarOK Then                                      ' No luck, do we have a saturated one to use?
            If Not LowestSatStar Is Nothing Then
                Console.PrintLine "**No usable unsaturated stars, using least-flux saturated star"
                Set Star = LowestSatStar                            ' Use the saturated star anyway
            Else
                SetupGuider = -1                                ' Failure sentinel
                P.DetachFITS
                Set P = Nothing
                Exit Function                                   ' == GIVE UP, FAILED ==
            End If
        End If
    Else 
        ' Multi-Star always uses this logic, and Single-Star uses it
        ' after the initial pass with SelectStar = True. At this point
        ' we must have selected the star to use one way or the other,
        ' and this is in c_guideStarX and c_guideStarY
        '
        ' Use same star as when first called with SelectStar = true
        ' or the one initially selected by MaxIm if Multi-Star guiding
        ' It may have moved a skosh so look for it in the list by
        ' nearest neighbor.
        ' 
        ' I need a function for this in the engine - closest by XY
        '
''-     Trace "[stpgdr] Use star at [" & Util.FormatVar(c_guideStarX, "0.0") & _
''-                     "," & Util.FormatVar(c_guideStarY, "0.0") & "]"
        xyd = 1E10
        For Each S2 In StarList
            z = XYDist(S2.X, S2.Y, c_guideStarY, c_guideStarX)  ' WATCH COORDINATE REVERSAL
            If z < xyd Then
                xyd = z                                         ' New "closest star"
                Set Star = S2
            End If
        Next
        If xyd = 1E10 Or xyd > 20.0 Then                        ' If no star found (faded) or some other one
            Console.PrintLine "** This guide star disappeared or moved > 20 pixels. Can't continue."
            SetupGuider = -1                                    ' Failed, our star became unusable
            P.DetachFITS                                        ' We're done with this Plate now
            Set P = Nothing
            Exit Function                                       ' === FAILURE EXIT ===
        End If
''-     Trace "[stpgdr] Found at [" & Util.FormatVar(Star.Y, "0.0") & _
''-                     "," & Util.FormatVar(Star.X, "0.0") & "]"
    End If
    
    '
    ' Calculate new exposure interval for desired SNR,
    ' Set MaxIm's guide star position, and bail out!
    '
    bgFlux = P.LocalBackgroundSigma(Star.X, Star.Y) * Star.Area ' Background flux in star area
    If bgFlux = 0 Then bgFlux = 1E-6                            ' Impossibly clean image?
    SNR = Star.RawFlux / bgFlux                                 ' Signal to noise ratio of star **at ExposureInterval**
''- Trace "BGRMS=" & CLng(bgFlux) & " StFlux=" & CLng(Star.RawFlux) & " SNR=" & Util.FormatVar(SNR, "0.0")
    SetupGuider = ExposureInterval * (c_guideSNRMin / SNR)      ' New exposure interval
    If SetupGuider > c_guideExpMax Then
        SetupGuider = -1                                        ' Failed, rest of stars too faint
        P.DetachFITS                                            ' We're done with this Plate now
        Set P = Nothing
        Exit Function                                           ' === FAILURE EXIT ===
    End If
    If SetupGuider < c_guideExpMin Then SetupGuider = c_guideExpMin ' Clamp to minimum interval
    SetupGuider = CDbl(CLng(SetupGuider * 100)) / 100.0         ' Chop off all but 2 decimal places
''- Trace "New exp=" & SetupGuider
    If SNR > 100 Then
        snrStr = "very high"
    Else
        snrStr = Util.FormatVar(SNR, "0.0")
    End If
    Console.PrintLine "  (guide star SNR=" & snrStr & _
                            " X=" & CInt(Star.Y) & _
                            " Y=" & CInt(Star.X) & ")"
    Call Camera.GuiderSetStarPosition(Star.Y, Star.X)           ' Yeah it's backwards (see above)
    c_guideStarX = Star.Y                                       ' Remember original star position for dithering
    c_guideStarY = Star.X                                       ' (yes positions are reversed)
    '
    ' If requested, save a preview image
    '
    If SavePreview Then
        fitsTmpPath = Util.Prefs.WebRoot & "\images\guideImage.tmp.fts"
        tboxPath = c_previewPath & "\" & GUIDEPRVTBOXNAME       ' Also in asystemstatus.asp
        fullPath = c_previewPath & "\" & GUIDEPRVNAME
        fullTxPath = c_previewPath & "\" & GUIDERPRVDIMSNAME
        P.WriteFits fitsTmpPath
        P.DetachFITS
        Set doc = CreateObject("MaxIm.Document")
        doc.OpenFile fitsTmpPath
        doc.RotateRight                                         ' Effectively exchanges X/Y coordinates
        doc.Mirror
        doc.SaveFile fullPath, 7, True, 0                       ' Scaled, 8-bits/pix, PNG (typ.)
        Set fullTxFile = FSO.CreateTextFile(fullTxPath, True)   ' Dims file for LightBox
        fullTxFile.WriteLine(doc.XSize)
        fullTxFile.WriteLine(doc.YSize)
        fullTxFile.Close()
        If Not c_multiStarGuiding Then                          ' Meaningless and may extend past edge and cause error
            ' ChipBorder test already passed
            doc.Crop (Star.Y - 16), (Star.X - 16), 32, 32       ' Assuming trackbox is 32 (NOTE X/Y Reversal)
            doc.DoubleSize
            doc.SaveFile tboxPath, 7, True, 0
        End If
        doc.Close
        Set doc = Nothing
    End If

    Set P = Nothing
End Function

'----------------------------------------------------------------------------------------
' ------------------
' SafeAboveHorizon()
' ------------------
'
' Tests to see if the given coordinates are "safely" above the
' ACP hard horizon limits. This is used by AutoFocus() as well as
' UpdatePointing() to refuse their operations if target is too
' close to the hard limits.
'
'----------------------------------------------------------------------------------------
Function SafeAboveHorizon(RightAscension, Declination, Margin)
    Dim CT, z
    
    Set CT = Util.NewCTHereAndNow()
    CT.RightAscension = RightAscension
    CT.Declination = Declination
    z = Util.Prefs.GetHorizon(CT.Azimuth)
    If Util.Prefs.MinimumElevation > z Then z = Util.Prefs.MinimumElevation ' Highest of two limits
    If CT.Elevation >= (z + Margin) Then                        ' If at or above safety margin
        SafeAboveHorizon = True
    Else
        SafeAboveHorizon = False
    End If
End Function

'----------------------------------------------------------------------------------------
' -----------
' StartSlew() - Start (or complete, if no async) a slew to new instrumental coordinates
' -----------
'
' Tries to detect GEM meridian flip and returns indication of same
'
' Parameters:
'   TargetName                  Name of target, for logging only
'   RightAscension              Instrumental Right Ascension
'   Declination                 Instrumental Declination
'
' Return
'   True if GEM flipped
'
' INTERNAL ROUTINE ONLY! DO NOT USE FROM SCRIPT AS C_simImageRA/c_SimImageDec not updated!
'----------------------------------------------------------------------------------------
Function StartSlew(TargetName, RightAscension, Declination)
    Dim lastHA, nxtHA, Telescope, flipped

    Set Telescope = Util.ScriptTelescope
    flipped = Util.GEMWestOfPier Xor Util.IsGEMDestinationWest(RightAscension, Declination)
    '
    ' Catch dome slave slewing (and scripting mistakes)
    '
    Do While Telescope.Slewing
        Util.WaitForMilliseconds 1000
    Loop
    '
    ' Now start the slew (and possible flip)
    '
    If Telescope.CanSlewAsync Then
''-     If flipped Then
''-         Trace "  (starting mount-flip and slew to " & TargetName & ")"
''-     Else
''-         Trace "  (starting slew to " & TargetName & ")"
''-     End If
        Telescope.SlewToCoordinatesAsync RightAscension, Declination
        Util.WaitForMilliseconds 1000
    Else
''-     If flipped Then
''-         Trace "  (mount-flipping and slewing to " & TargetName & ")"
''-     Else
''-         Trace "  (slewing to " & TargetName & ")"
''-     End If
        Telescope.SlewToCoordinates RightAscension, Declination
        Console.PrintLine "  (slew complete)"
    End If
    
    StartSlew = flipped                                         ' Return flip indication
    
End Function

'----------------------------------------------------------------------------------------
' ------
' Sync() - Sync the scope to the given corrected instrumental coordinates
' ------
'
' Parameters:
'   RightAscension          New RA, instrumental
'   Declination             New Dec, instrumental
'
' Returns: 
'   True if Syncs, else False
'
' Avoid sync across flip point for German polar (Bisque Paramount crashes)
' and avoid sync with corrector turned off and "high" in declination.
' INTERNAL ROUTINE ONLY! DO NOT USE FROM SCRIPTS!!!!!
'----------------------------------------------------------------------------------------
Function Sync(RightAscension, Declination)
    
    '
    ' If German polar, avoid syncing across flip points
    '
    If Util.ScriptTelescope.AlignmentMode = 2 And _
                Util.GEMWestOfPier <> Util.IsGEMDestinationWest(RightAscension, Declination) Then ' Sync across flip point?
        Util.Console.PrintLine "**SYNC ACROSS FLIP POINT FOR GERMAN MOUNT. SYNC SKIPPED!"
        Sync = False
        Exit Function
    End If
    '
    ' If too high declination, and not running the pointing corrector, skip the Sync
    '
    If Not Util.PointingCorrectionEnabled And Abs(Declination) > 70.0 Then
        Util.Console.PrintLine "**HIGH DECLINATION (>70), SYNC SKIPPED!"
        Sync = False
        Exit Function
    End If
    
''- Trace "      ([sync] scope coords: RA = " & Util.Hours_HMS(RightAscension) & _
''-                         "  Dec = " & Util.Degrees_DMS(Declination) & ")"
    Util.ScriptTelescope.SyncToCoordinates RightAscension, Declination
    
    If Util.PointingCorrectionEnabled Then
        Util.Console.PrintLine "  [sync] pointing model updated"
    Else
        Util.Console.PrintLine "  [sync] telescope synced"
    End If
    Sync = True
    
End Function


'----------------------------------------------------------------------------------------
' -----------------
' IsBadBrightStar()
' -----------------
'
' Brute force function to test to see if the given J2000 coordinates are within 5
' arc minutes of a known bad bright star. The bad stars are listed in a file. The
' file consists of one star per line with the RA and Dec separated by tab(s). A
' semicolon starts a comment, And blank lines are allowed.
'
' Returns true/false
'----------------------------------------------------------------------------------------
Function IsBadBrightStar(RightAscension, Declination)
    Dim f, i, j, buf, bits, RX, RA, DE
    
    buf = Util.GetConfigFilePath(BADSTARSNAME)
    If buf = "" Then 
        IsBadBrightStar = False
        Exit Function                                           ' No bad stars info
    End If
    '
    ' We have bad star info. Read and decode
    '
    Set f = FSO.OpenTextFile(buf, 1)                            ' Open bad star info file
    Do While Not f.AtEndOfStream                                ' Loop till End of stream
        '
        ' Read filter file. Trim out trash, and allow ';' delimited comments
        ' anywhere in the line, remove them (including entire lines starting
        ' with ';') and remove blank lines
        '
        buf = f.ReadLine()                                      ' Compress all whitespace to " " 
        j = InStr(buf, ";")                                     ' Comment delimiter in line?
        Select Case j
            Case 0:                                             ' No comment, live line, just trim for 
            	buf = Trim(buf)									'   possible all-blank line
            Case 1:                                             ' Entire line is comment, skip it
                buf = ""                                        ' Act like this never existed
            Case Else:                                          ' Comment embedded in line
                buf = Trim(Left(buf, (j - 1)))                  ' Remove comment and blanks
        End Select
        
        If buf <> "" Then                                       ' Skip blank or supressed lines
            bits = Split(buf, vbTab)                           ' Split at tab
            If UBound(bits) = 1 Then
                On Error Resume Next                            ' I hate VBS
                RA = Util.HMS_Hours(Trim(bits(0)))
                If Err.Number = 0 Then
                    DE = Util.DMS_Degrees(Trim(bits(1)))
                    If Err.Number <> 0 Then
                        Util.Console.PrintLine "  **Bad Dec " & bits(1) & " in " & BADSTARSNAME & " - skipped"
                    End If
                Else
                    Util.Console.PrintLine "  **Bad RA " & bits(0) & " in " & BADSTARSNAME & " - skipped"
                End If
                If Err.Number = 0 Then
                    On Error GoTo 0
                    If EquDist2(RightAscension, Declination, RA, DE) < 0.083334 Then   ' 5 arcminutes
                        Util.Console.PrintLine "  Found known bad bright star, skipped"
                        f.Close
                        IsBadBrightStar = True                  ' Found a bad one
                        Exit Function                           ' DONE
                    End If
                End If
            Else
                On Error GoTo 0
                Util.Console.PrintLine "  **Bad line in " & BADSTARSNAME & " - skipped"
            End If
        End If
    Loop
    f.Close()
    IsBadBrightStar = False                                     ' None found
End Function

'----------------------------------------------------------------------------------------
' -------------------
' SetupReadoutModes()
' -------------------
'
' Gets readout modes from the camera if any, then tries to determine which modes
' are to be used as "normal" and "fast". It looks in the readout mode name for those
' words, then it tries to use a file RoModeInfo.txt to explicitly specify them.
'
' c_haveReadoutModes will be False if camera does not support readout modes
'----------------------------------------------------------------------------------------
Sub SetupReadoutModes()
    Dim i, j, k, f, RX, buf, bits
    
    c_haveReadoutModes = False
    '
    ' Trickiness: There will be a readout mode 0. It is assumed to be the default
    ' for the Camera. It might not contain "normal". If there's one with "fast" in
    ' it, that one will be used for pointing exposures. If not, it too will have
    ' the value 0. In any case, later when the modes are logged, the real name
    ' will be used.
    '
    c_normalReadoutMode = 0                                     ' Default readout modes for none supported
    c_fastReadoutMode = 0
    c_flatReadoutMode = 0
    c_readoutModes = Util.ScriptCamera.ReadoutModes
    If Util.ScriptCamera.NumReadoutModes > 0 Then
        c_haveReadoutModes = True
        Util.Console.PrintLine "Imager readout modes:"          ' Log available modes
        For i = 0 To UBound(c_readoutModes)
            If InStr(LCase(c_readoutModes(i)), "normal") Then c_normalReadoutMode = i
            If InStr(LCase(c_readoutModes(i)), "fast") Then c_fastReadoutMode = i
            If InStr(LCase(c_readoutModes(i)), "flat") Then c_flatReadoutMode = i
            Util.Console.PrintLine "  " & i & " is " & c_readoutModes(i)
        Next
    End If

    If Not c_haveReadoutModes Then Exit Sub
    buf = Util.GetConfigFilePath(ROMODEINFNAME)                 ' Try to find the RO Mode config file
    If buf = "" Then Exit Sub                                   ' No mode info, use default norm/fast
    '
    ' We have readout mode file. Read and decode. NOTE: Modes may have spaces in them!
    '
    Util.Console.PrintLine "Using Normal and Fast readout modes from " & ROMODEINFNAME
''- Trace "[romode] RO Mode info:"
    Set RX = New RegExp                                         ' Trim() does not remove tabs (grr...)
    RX.Pattern = "\t"                                           ' Match tab
    RX.Global = True                                            ' Everywhere in buf
    Set f = FSO.OpenTextFile(buf, 1)                            ' Open mode info file
    Do While Not f.AtEndOfStream                                ' Loop till End of stream
        buf = RX.Replace(f.ReadLine, " ")                       ' Compress all tabs to " "
        j = InStr(buf, ";")                                     ' Comment delimiter in line?
        Select Case j
            Case 0:                                             ' No comment, live line, just trim for 
            	buf = Trim(buf)									'   possible all-blank line
            Case 1:                                             ' Entire line is comment, skip it
                buf = ""                                        ' Act like this never existed
            Case Else:                                          ' Comment embedded in line
                buf = Trim(Left(buf, (j - 1)))                  ' Remove comment and blanks
        End Select
        If buf <> "" Then                                       ' Skip blank or supressed lines
            bits = Split(buf, "=")                              ' Look for name = value
            If UBound(bits) = 1 Then                            ' Got one
                buf = Trim(bits(1))
                If ReadoutModeExists(buf) Then                  ' If the camera has this mode by name
                    k = DecodeReadoutMode(buf)                  ' Convert to mode index
                    Select Case LCase(Trim(bits(0)))            ' Set the appropruate mode type (normal/fast)
                        Case "normal":
                            c_normalReadoutMode = k
                        Case "fast":
                            c_fastReadoutMode = k
                        Case "flat":
                            c_flatReadoutMode = k
                        Case Else:
                            Util.Console.PrintLine "**Unknown mode type " & Trim(bits(0)) & ", ignored"
                    End Select
                Else
                    Util.Console.PrintLine "**Camera does not support mode " & buf
                End If
            Else
                Util.Console.PrintLine "**Unknown line in RoModeInfo:"
                Util.Console.PrintLine "  " & buf
            End If
        End If
    Loop
    f.Close
    Set RX = Nothing
    
    Util.Console.PrintLine "  Normal mode is " & ReadoutModeName(c_normalReadoutMode)
    Util.Console.PrintLine "  Fast mode is " & ReadoutModeName(c_fastReadoutMode)
    Util.Console.PrintLine "  Autoflat mode is " & ReadoutModeName(c_flatReadoutMode)
     
End Sub

'----------------------------------------------------------------------------------------
' --------------
' SetupFilters()
' --------------
'
' The c_filterNames array has jsut been loaded. if filter offset data file found, 
' allocate Space in the filter offest info arrays and populate them. See 
' FilterOffset() function comments for info.
'
' Sets globals c_haveFilterInfo, and if enabled, arrays c_filterOffset(), 
' c_focusFilter(), c_pointingFilter(), c_filterBrightMag() and c_filterFaintMag().
' The latter 2 are pre-filled with the defaults of mag 6 and 9 respectively, And
' may be overridden by the optional appearance of bright and faint data for a filter.
'
' c_haveFilterInfo will be False if no filterinfo file or no focuser selected
'----------------------------------------------------------------------------------------
Sub SetupFilters()
    Dim f, i, j, maxFiltIndex, buf, bits, RX, RX2
    
    c_haveFilterInfo = False                                    ' Assume failure
    If Not c_haveFilters Then Exit Sub                          ' Filter offsets n/a if no filters!
    buf = Util.GetConfigFilePath(FILTINFNAME)
    If buf = "" Then Exit Sub                                   ' No offset info, offsets n/a
    '
    ' We have filter offset file. Read and decode
    '
    Util.Console.PrintLine "Using focus offsets and star mags from " & FILTINFNAME
''- Trace "[foffs] Filter info:"
    maxFiltIndex = UBound(c_filterNames)                        ' Number of filters - 1 (index)
    ReDim c_filterOffset(maxFiltIndex), _
            c_focusFilter(maxFiltIndex), _
            c_pointingFilter(maxFiltIndex), _
            c_filterBrightMag(maxFiltIndex), _
            c_filterFaintMag(maxFiltIndex)                      ' Allocate info arrays
    Set f = FSO.OpenTextFile(buf, 1)                            ' Open offset info file
    Set RX = New RegExp                                         ' Trim() does not remove tabs (grr...)
    RX.Pattern = "\s"                                           ' Match any whitespace
    RX.Global = True                                            ' Everywhere in buf
    Set RX2 = New RegExp
    RX2.Pattern = "\,*$"                                        ' Remove trailing commas
    i = 0                                                       ' Filter number/index
    Do While Not f.AtEndOfStream                                ' Loop till End of stream
        '
        ' Read filter file. Trim out trash, and allow ';' delimited comments
        ' anywhere in the line, remove them (including entire lines starting
        ' with ';') and remove blank lines
        '
        buf = RX.Replace(f.ReadLine, " ")                       ' Compress all whitespace to " " 
        j = InStr(buf, ";")                                     ' Comment delimiter in line?
        Select Case j
            Case 0:                                             ' No comment, live line, just trim for 
            	buf = Trim(buf)									'   possible all-blank line
            Case 1:                                             ' Entire line is comment, skip it
                buf = ""                                        ' Act like this never existed
            Case Else:                                          ' Comment embedded in line
                buf = Trim(Left(buf, (j - 1)))                  ' Remove comment and blanks
        End Select
        If buf <> "" Then                                       ' Skip blank or supressed lines
            '
            ' Live filter info line - split specs and load arrays with error checks
            '
            If i > maxFiltIndex Then                            ' Too many line in FilterInfo.txt?
                Err.Raise vbObjectError, "ACP.AcquireSupport", _
                    FILTINFNAME & " has more offset entries than filters in the camera"
            End If
            buf = RX2.Replace(buf, "")                          ' Remove trailing commas (Paul Luckas)
            bits = Split(buf, "," ,-1 ,1)
            If UBound(bits) < 2 Then _
                Err.Raise vbObjectError, "ACP.AcquireSupport", _
                    "Bad line in " & FILTINFNAME & ":" & vbCrLf & buf
            c_filterOffset(i) = CLng(Trim(bits(0)))
            If Not Util.Prefs.AutoFocus.Enabled And c_filterOffset(i) <> 0 Then
                Err.Raise vbObjectError, "ACP.AcquireSupport", _
                    "Non-zero focus offset in " & FILTINFNAME & " yet AutoFocus is disabled. Cannot continue"
            End If
            c_focusFilter(i) = CInt(Trim(bits(1)))
            If c_focusFilter(i) < 0 Or c_focusFilter(i) > maxFiltIndex Then
                Err.Raise vbObjectError, "ACP.AcquireSupport", _
                    "Bad focus filter number " & c_focusFilter(i) & " in " & FILTINFNAME
            End If
            c_pointingFilter(i) = CInt(Trim(bits(2)))
            If c_pointingFilter(i) < 0 Or c_pointingFilter(i) > maxFiltIndex Then
                Err.Raise vbObjectError, "ACP.AcquireSupport", _
                    "Bad pointing filter number " & c_pointingFilter(i) & " in " & FILTINFNAME
            End If
            If UBound(bits) > 2 Then
                If UBound(bits) <> 4 Then
                    Err.Raise vbObjectError, "ACP.AcquireSupport", _
                        "Both bright and faint star mags not given in " & FILTINFNAME
                End If
                c_filterBrightMag(i) = CDbl(Trim(bits(3)))
                c_filterFaintMag(i) = CDbl(Trim(bits(4)))
            Else                                                ' Not given, use defaults
                c_filterBrightMag(i) = 6.0
                c_filterFaintMag(i) = 9.0
            End If
''-        Trace "[foffs]   " & FilterName(i) & " (" & i & _
 ''-              "), offset=" & c_filterOffset(i) & _
 ''-              ", focusUsing=" & c_focusFilter(i) & _
 ''-              ", forPointing=" & c_pointingFilter(i)
            i = i + 1                                           ' Next filter
        End If
    Loop
    If i < maxFiltIndex + 1 Then                                ' Not enough entries for filters
        Err.Raise vbObjectError, "ACP.AcquireSupport", _
            FILTINFNAME & " has fewer offset entries than filters in the camera"
    End If
    c_haveFilterInfo = True                                     ' We got it!
    f.Close()                                                   ' Close offset file
    Set RX = Nothing                                            ' Release RegExp engine now
    
End Sub


'----------------------------------------------------------------------------------------
' -----------------
' SetFilterOffset()
' -----------------
'
' Inputs
'   FiltNum     Filter number (0-based)
' Returns       Focuser position after focus change
'
' Performs filter focus offset from current filter to specified filter. If the 
' change is 0, then no move is made and no focuser is required in MoveFocuser().
'----------------------------------------------------------------------------------------
Function SetFilterOffset(FiltNum)
    Dim curOffs, reqOffs, z
    
    curOffs = c_filterOffset(Util.ScriptCamera.Filter)          ' Offset of currently selected filter
    reqOffs = c_FilterOffset(FiltNum)                           ' Offset of filter to be selected
''- Trace "  [foffs] changing focus from " & FilterName(Util.ScriptCamera.Filter) _
''-     &  " to " & FilterName(FiltNum)

    z = reqOffs - curOffs                                       ' Focus difference between the two
    If z <> 0 Then
        Util.Console.PrintLine "  Focus change of " & z & " steps required"
        SetFilterOffset = MoveFocuser(z, False)
    Else 
        Util.Console.PrintLine "  No focus change required"
    End If

End Function


'----------------------------------------------------------------------------------------
' -------------
' MoveFocuser()
' -------------
'
' Inputs
'   Value     Number of steps to move (+/-) or absolute position (Absolute = True)
'   Absolute  If true the value is the absolute focuser position. Raises error if 
'             focuser is relative.
' Returns     Final (or given) focus position
'
' Performs filter focus offset from current filter to specified filter or a move To
' an absolute focus position (used at startup). Note that if an absolute position Is
' given, itis checked against the current position and if already there no call Is
' made to move the focuser. 
'----------------------------------------------------------------------------------------
Function MoveFocuser(Value, Absolute)
    Dim z, F, wasLink, wasTempComp

    If Not c_haveAF Then                                    ' Cannot do with AF disabled, no focuser
        Err.Raise vbObjectError, "ACP.AcquireSupport", _
            "Internal error: Tried to move focus position with AutoFocus disabled."
    End If
    If c_usePWI Then
        Set F = CreateObject("ASCOM.PWI3.Focuser")
    Else
        Set F = CreateObject("FocusMax.Focuser")
    End If
    wasLink = F.Link
    F.Link = True
    If F.TempCompAvailable Then
        wasTempComp = F.TempComp 
        F.TempComp = False
    End If
    '
    ' Love that ASCOM, focuser commands are identical!
    ' Who the hell would run a relative focuser on an ACP system?
    '
    If Value <> 0 Then
        If F.Absolute Then                                      ' If we have an absolute focuser
            If Absolute Then
''- Trace "  [foffs] Moving to absolute position " & CStr(Value)
                Call F.Move(Value)
            Else
''- Trace "  [foffs] Moving absolute from current position by " & CStr(Value) & " steps"
                Call F.Move(F.Position + Value)                 ' Move using absolute counter
            End If
        Else                                                    ' Relative focuser...
            If Absolute Then                                    ' This is an assert, should never be called with rel focuser
                Err.Raise vbObjectError, "ACP.AcquireSupport", _
                    "Internal error: Tried to move relative focuser to absolute position"
            Else
''- Trace "  [foffs] Moving relative from current position by " & CStr(Value) & " steps"
                Call F.Move(Value)                              ' ... relative move
            End If
        End If
        Do While F.IsMoving                                     ' Wait for focuser
            Util.WaitForMilliseconds 1000
        Loop
    End If
    If F.Absolute Then
        MoveFocuser = F.Position
''- Trace "  [foffs] New focus position = " + CStr(F.Position)
    Else
        MoveFocuser = 0 
''- Trace "  [foffs] Relative focuser, unknown position
    End If
    If F.TempCompAvailable Then F.TempComp = wasTempComp
    F.Link = wasLink
    Set F = Nothing

End Function


'----------------------------------------------------------------------------------------
' --------------
' CreateFolder() - Create a folder with recursion
' --------------
'
' If web is True, propagate ASP files from parent to new directory
'----------------------------------------------------------------------------------------
Sub CreateFolder(Path, Web)
    Dim p, fo, fl
    
    If FSO.FolderExists(Path) Then Exit Sub
    p = FSO.GetParentFolderName(Path)
    If p = "" Then                                                  ' Root, bad drive spec!
        Err.Raise vbObjectError, "ACP.AcquireSupport", _
            "Bad path or drive """ & Path & """ while creating folder(s)"
    End If
    If Not FSO.FolderExists(p) Then
        CreateFolder p, Web
    End If
    Set fo = FSO.CreateFolder(Path)
    If Web Then
        For Each fl In fo.ParentFolder.Files
            If LCase(FSO.GetExtensionName(fl)) = "asp" Then
                FSO.CopyFile p & "\" & fl.Name, Path & "\" & fl.Name
            End If
        Next
    End If
End Sub

'----------------------------------------------------------------------------------------
' -----------------
' GetNextLiveLine() - Get live line from ACP plan, optionally echo comments
' -----------------
'
' Return trimmed plan line or "" if reached EOF. 
' If EchoComments is True, echo any encountered comment LINES to console.
'----------------------------------------------------------------------------------------
Function GetNextLiveLine(Strm, EchoComments)
    Dim M
    
    RX.Pattern = "^\s*(.*?)\s*(;.*?)*\s*$"                      ' Magic RegExp
    Do While Not Strm.AtEndOfStream                             ' Read till find live line or EOF
        Set M = RX.Execute(Strm.ReadLine)(0)                    ' Chop into bits
        GetNextLiveLine = M.SubMatches(0)                       ' Live plan stuff, if any
        '
        ' Only echo comments on a line by itself. Other comments
        ' can be too confusing...
        '
        If EchoComments And M.Submatches(0) = "" And M.SubMatches(1) <> "" Then
            Util.Console.PrintLine M.SubMatches(1)
        End If
        If GetNextLiveLine <> "" Then Exit Function             ' RET - Got a live line
    Loop                                                        ' (read till EOF loop)
    GetNextLiveLine = ""                                        ' End of stream, ret "" 

End Function

'----------------------------------------------------------------------------------------
' ---------------
' GetRefCatName() - Return the human-readable name of the PinPoint catalog
' ---------------
'
' Return the name of the reference catalog given the PinPoint.Plate.Catalog numeric code.
' Handles only those catalogs that can possibly be chosen in ACP.
'----------------------------------------------------------------------------------------
Function GetRefCatName(num)

    Select Case Num
        Case 3: GetRefCatName = "GSC 1.1 (ok for wider fields)"
        Case 5: GetRefCatName = "A2.0 (best for pointing)"
        Case 6: GetRefCatName = "UCAC2 (obsolete and not recommended)"
        Case 7: GetRefCatName = "B1.0 (local, not recommended)"
        Case 8: GetRefCatName = "B1.0 (internet, not recommended)"
        Case 9: GetRefCatName = "NOMAD (internet, not recommended)"
        Case 10: GetRefCatName = "UCAC3 (obsolete and not recommended)"
        Case 11: GetRefCatName = "UCAC4 (questionable for pointing)"
        Case Else: GetRefCatName = "??Can't be chosen in ACP??"
    End Select
End Function

'----------------------------------------------------------------------------------------
' -------
' Trace()
' -------
'
' Output console message only if trace flag is turned on.
'----------------------------------------------------------------------------------------
Sub Trace(msg)
    If TRACE_ENABLE Then Util.Console.PrintLine "[T] " & msg
End Sub

]]>
	</script>
	<script id="ImageSimulator" language="JScript">
<![CDATA[
//  ==============
//  ImageSimulator
//  ==============
//
// This script generates artifical star fields from any PinPoint
// compatible catalog, and is intended to be used with ACP's
// image acquisition machinery. It supplies a simulated starfield
// that can be plate-solved by PinPoint.
//
// Given the FWHM, the sigma of the gaussian curve can be calculated
// using the fact that for sigma of 1 the fwhm is 2.3548 * sigma.
// f(x) - 1 / (sigma * sqrt(2 * PI)) * e ^ -(o.5 * ((x / sigma) ^ 2))
// Solving for x with f(x) = 0.5 (half max) and sigma = 1 then
// x = sqrt(2 * ln(-0.5)) = 1.177 HWHM, = 2.355 FWHM, thus
// sigma = FWHM / 2.355. Intensity at the center of the bell curve
// for unity flux is I0 = 1 / (sigma * sqrt(2 * PI)). 
//
// Portions Copyright 2002: A. Oksanen, used with permission.

// ------ USER CONFIGURATION SECTION -----
var _bgmean = 350;                                  // b/g noise mean
var _bgsigma = 20;                                  // b/g noise sigma
var _limmag = 22.0;                                 // limiting mag
var _lmexp = 60;                                    // exposure interval to reach limiting mag
var _loflux = 10000.0;                              // flux at limiting mag (arbitrary!)
var _basefwhm = 4.0;                                // Base FWHM arcsec
// ------ END CONFIGURATION SECTION -----

var _fwhmGrowth = (Util.Prefs.AutoFocus.MaxHFDGrowth - 1) / 3.0e5;  // Grows to Adaptive limit in 5 min
var _d = new Date();
var _fwhmTime = _d.getTime();                       // Start growth at reset values
var _fwhm = _basefwhm;                              // Current FWHM (may auto-grow)
var _dspdoc;                                        // Holder for displayed simulation
//
// Called after successful AutoFocus to reset time-growth
// of FWHM (and thus HFD)
//
function ResetSimFWHM()
{
    _fwhm = _basefwhm;                              // Back to base FWHM
    _d = new Date();
    _fwhmTime = _d.getTime();                       // Ticks at reset
}

//
// For use only by TakePicture in the AcquireSupport script.
// Replace MaxIm.CCDCamera's current mage with a simulated starfied.
// The coordinates given here are J2000, but with position errors 
// generated in the AcquireSupport routines.
//
// DEPENDS ON CAMERA'S CURRENT BINNING AND GEOMETRY!
// WARNING! FAILS FOR CAMERAS WITH NON-SQUARE PIXELS!
//
// expint used only for sensing Dark/Bias!
//
// Use a work file because we close then reopen the file for display
// in MaxIm, and DropBox will almost certainly have it locked. 
//
function SimulateImage(RA, Dec, PA, expint, light, imagePath, pixType)
{
    var scaleH, scaleV;

    //
    // Convert just-acquired image into a background image for starfield generation
    //
    var doc = Util.ScriptCamera.Document;                       // Get just-acquired image
    doc.Subtract(doc);                                          // Clear the image to black
    if(expint === 0)                                            // Bias frame, sim has no bias.
    {
        doc.SaveFile(imagePath, 3, false, pixType);             // Save to disk as darkframe
        return;                                                 // And that's it
    }
    doc.AddConstant(_bgmean);                                   // Add mean background
    if(light === 0)                                             // If darkframe
    {
        doc.SaveFile(imagePath, 3, false, pixType);             // Save to disk as darkframe
        return;                                                 // And that's it
    }
    
    tempPath = FSO.GetSpecialFolder(2).Path + "\\" + FSO.GetBaseName(FSO.GetTempName()) + ".fts" // 2 = temporary folder path

    doc.AddNoise(1, _bgsigma);                                  // Add Gaussian noise
    doc.SaveFile(tempPath, 3, false, 1);                        // Must be in 16-bit int for PinPoint imagearray mods (PP 4.1.2)

    //
    // ONLY if Adaptive AutoFocus is enabled, calculate noisy growing FWHM based 
    // on time since last time the FWHM growth was reset (or initialized), plus 
    // Gaussian noise with 0.05 * _basefwhm variation.
    //
    if(Util.Prefs.AutoFocus.Enabled && Util.Prefs.AutoFocus.AdaptiveAutoFocus) {
        _d = new Date();
        _fwhm = _basefwhm * (1.0 + ((_d.getTime() - _fwhmTime) * _fwhmGrowth) + GaussRand(0.05));
    }

    //
    // Add the simulated stars to the image using PinPoint, etc.
    //
    var plate = new ActiveXObject("PinPoint.Plate");
    plate.AttachFITS(tempPath);
    plate.Catalog = Util.Prefs.ReferenceCatalogType;            // Use configured catalog 
    plate.CatalogPath = Util.Prefs.ReferenceCatalogPath;
    plate.CatalogMaximumMagnitude = 22;                         // Use all cat stars
    plate.CatalogExpansion = 0;
    // Calculate platescale magnitudes, but...
    scaleH = (Util.ScriptCamera.PixelSizeX * Util.ScriptCamera.BinX /
                                        Util.ScriptTelescope.FocalLength) * 0.206; 
    scaleV = (Util.ScriptCamera.PixelSizeY * Util.ScriptCamera.BinY /
                                        Util.ScriptTelescope.FocalLength) * 0.206;
    //
    // Convert positive plate scales and standard position angle (PA) 
    // to the set of values for PinPoint (which obey WCS conventions).
    //
    PA = RangeAngle(PA, 0.0, 360.0);                            // Catch small deltas that may cause negative PA
    if(PA == 90.0)                                              // Catch PinPoint gimbal lock
        PA = 89.9999;
    if(PA == 270.0)
        PA = 270.0001;
    if(PA >= 0.0 && PA < 90.0) {
        plate.ArcsecPerPixelHoriz = -scaleH;
        plate.ArcsecPerPixelVert = -scaleV;
        plate.RollAngle = -PA;
    } else if(PA > 270.0 && PA < 360.0) {
        plate.ArcsecPerPixelHoriz = -scaleH;
        plate.ArcsecPerPixelVert = -scaleV;
        plate.RollAngle = 360.0 - PA;
    } else {                                                    // >= 90 && < 270
        plate.ArcsecPerPixelHoriz = +scaleH;
        plate.ArcsecPerPixelVert = +scaleV;
        plate.RollAngle = 180.0 - PA;
    }
    plate.RightAscension = RA;
    plate.Declination = Dec;
    plate.FindCatalogStars();
    if(plate.CatalogStars.Count == 0)
    {
        Util.Console.PrintLine("**No catalog stars in area, simulating empty image.");
        plate.writeFITS(imagePath);    
        plate.DetachFITS();                                     // Done with image file
        return;
    }
    if(Util.Prefs.PointingUpdates.Simulate && c_simImageTimeCompress)
        plate.ExposureInterval *= 10.0;						    // Adjust for sim (FIXES IN FITS TOO)
    plate.SynthesizeStarfield(_fwhm, _limmag, _loflux, _lmexp);
    plate.writeFITS(tempPath);    
    plate.DetachFITS();                                         // Done with image file
    //
    // Display this simulated image. Must keep object reference global.
    // For some reason, MaxIm lets 3 images pile up before closing them.
    // For MaxIm 4, display for 2 seconds, then close.
    //
    _dspdoc = null;                                             // Release previous
    _dspdoc = new ActiveXObject("MaxIm.Document");
    _dspdoc.OpenFile(tempPath);
    if(pixType != 1)                                            // If final pix type not uint-16
        _dspdoc.SaveFile(tempPath,3, false, pixType);           // Re-save it in the requested format
    Util.WaitForMilliseconds(2000);                             // At least 2 sec.
    try {
        _dspdoc.Close();
    } catch(e) { ; }
    
    if(FSO.FileExists(imagePath)) 
        FSO.DeleteFile(imagePath);
    FSO.MoveFile(tempPath, imagePath);
}
]]>
	</script>
	<script id="MathLibrary" language="JScript">
<![CDATA[
var DEGRAD = Math.PI / 180.0;
var RADDEG = 180.0 / Math.PI;

var c_equOffsetRA, c_equOffsetDec;
var c_slewTargetRA, c_slewTargetDec;

// ==========
// PROPERTIES
// ==========
//var EquOffsetRA (PrimalScript target)
function get_EquOffsetRA()
{
    return(c_equOffsetRA);
}

//var EquOffsetDec (PrimalScript target)
function get_EquOffsetDec()
{
    return(c_equOffsetDec);
}

// ==============
// PUBLIC METHODS
// ==============

//----------------------------------------------------------------------------------------
//
// --------
// XYDist() - Pythagorean distance between two XY positions
// --------
//
//----------------------------------------------------------------------------------------
function XYDist(x1, y1, x2, y2)
{
    var dx = x2 - x1;
    var dy = y2 - y1;
    return Math.sqrt((dx * dx) + (dy * dy));
}

//----------------------------------------------------------------------------------------
//
// ----------
// Arctan4Q() - VBScript access to 4-quadrant arctan(y / x)
// ----------
//
//----------------------------------------------------------------------------------------
function Atan4Q(y, x)
{
    return(Math.atan2(y, x));
}

//----------------------------------------------------------------------------------------
//
// ---------
// EquDist() - Return equatorial distance between objects, degrees
// ---------
//
//----------------------------------------------------------------------------------------
function EquDist(a1, d1, a2, d2)
{
    return(SphDist((a1 * 15.0), d1, (a2 * 15.0), d2));
}

//----------------------------------------------------------------------------------------
//
// ---------
// SphDist() - Return distance between objects, degrees
// ---------
//
//----------------------------------------------------------------------------------------
function SphDist(a1, d1, a2, d2)
{
    var a1r = DEGRAD * a1;
    var a2r = DEGRAD * a2;
    var d1r = DEGRAD * d1;
    var d2r = DEGRAD * d2;
      
    var ca1 = Math.cos(a1r);
    var ca2 = Math.cos(a2r);
    var sa1 = Math.sin(a1r);
    var sa2 = Math.sin(a2r);

    var cd1 = Math.cos(d1r);
    var cd2 = Math.cos(d2r);
    var sd1 = Math.sin(d1r);
    var sd2 = Math.sin(d2r);

    var x1 = cd1*ca1;
    var x2 = cd2*ca2;
    var y1 = cd1*sa1;
    var y2 = cd2*sa2;
    var z1 = sd1;
    var z2 = sd2;

    var R = (x1 * x2) + (y1 * y2) + (z1 * z2);

    if(R > 1.0) R = 1.0;
    if(R < -1.0) R = -1.0;

    return(RADDEG * Math.acos(R));      
}

//----------------------------------------------------------------------------------------
//
// ----------
// EquDist2() - Return equatorial distance between objects, degrees
// ----------
//
// Equivalent to EquDist(), just implemented with Universal Space Rectangular (USR)
// coordinates, and vector operations. You still need the 4-quadrant arctan though!!
//----------------------------------------------------------------------------------------
function EquDist2(a1, d1, a2, d2)
{
    var i, d, y;
    
    var a1r = 15.0 * DEGRAD * a1;               // Convert to radians
    var a2r = 15.0 * DEGRAD * a2;
    var d1r = DEGRAD * d1;
    var d2r = DEGRAD * d2;

    var v1 = _equ2usr(a1r, d1r);                // Convert to USR
    var v2 = _equ2usr(a2r, d2r);

    var z = 0.0;                                // Modulus of half the difference vector
    for (i = 0; i < 3; i++)
    {
        d = v1[i] - v2[i];
        z += d * d;
    }
    z /= 4.0;
    //
    // Return the angle between the vectors (degrees)
    //
    y = 1.0 - z;
    return(2.0 * RADDEG * Math.atan2(Math.sqrt(z), Math.sqrt(Math.max(0.0, y))));
}

//----------------------------------------------------------------------------------------
//
// -----------
// EquOffset() - Return offset coordinates, given equatorial offsets
// -----------
//
// Puts the offset coordinates into c_equOffsetRA/Dec, and returns a vector
// [RA|Dec] with the offset coordinates (for JScript callers)
//
// a  = right ascension, hours
// d  = declination, degrees
// dr = offset in right ascension, minutes
// dd = offset in declination, arcminutes
//----------------------------------------------------------------------------------------
function EquOffset(a, d, da, dd)
{
    var ar = 15.0 * DEGRAD * a;                 // Convert orig coordinates to radians
    var dr = DEGRAD * d;
    var v = _equ2usr(ar, dr);                   // Convert to USR
    
    var dar = da * DEGRAD / 60.0;               // Convert offsets to radians
    var ddr = dd * DEGRAD / 60.0;
    
    v = _rotusr(v, ar, dar, ddr);               // Rotate through offset angles
    
    var ev = _usr2equ(v);                       // Convert offset coords to equ radians
    ev[0] *= (RADDEG / 15.0);                   // Convert RA to hours
    ev[0] = RangeTime(ev[0]);                   // Range back to 0-24
    ev[1] *= RADDEG;                            // Convert Dec to degrees
    c_equOffsetRA = ev[0];                      // Set properties for VB callers
    c_equOffsetDec = ev[1];
    return(ev);                                 // Return RA/Dec in array
}

//----------------------------------------------------------------------------------------
//
// ---------------
// PositionAngle() - Return bearing (PA) from one object to another, degrees
// ---------------
//
//----------------------------------------------------------------------------------------
function PositionAngle(ra1, dec1, ra2, dec2)
{
    var a1r = 15.0 * DEGRAD * ra1;
    var a2r = 15.0 * DEGRAD * ra2;
    var d1r = DEGRAD * dec1;
    var d2r = DEGRAD * dec2;

    var da = a2r - a1r;
    var y = Math.sin(da) * Math.cos(d2r);
    var x = Math.sin(d2r) * Math.cos(d1r) - Math.cos(d2r) * Math.sin(d1r) * Math.cos(da);
    var par = (x !== 0.0 || y !== 0.0 ) ? Math.atan2(y, x) : 0.0;
    return(RangeAngle((RADDEG * par), 0.0, 360.0));
}

//----------------------------------------------------------------------------------------
//
// --------------
// HourAngle0to24() - Return current hour angle (ST - RA, 0 <=HA , 24)
// --------------
//
// a = right ascension, hours
// The corresponding Util.HourAngle24() method in ACP is bassackwards :-(
//----------------------------------------------------------------------------------------
function HourAngle0to24(a)
{
    return(RangeTime(Util.ScriptTelescope.SiderealTime - a));
}

//----------------------------------------------------------------------------------------
//
// -----------
// ZenithDist() - Return current zenith distance, degrees
// -----------
//
// a  = right ascension, hours
// d  = declination, degrees
//----------------------------------------------------------------------------------------
function ZenithDist(a, d)
{
    var ct = Util.NewCTHereAndNow();
    ct.RightAscension = a;
    ct.Declination = d;
    return(Math.abs(90.0 - ct.Elevation));
}    

//----------------------------------------------------------------------------------------
//
// -------------
// ZenithDist2() - Return current zenith distance, degrees
// -------------
//
// a  = right ascension, hours
// d  = declination, degrees
//
// Equivalent to ZenithDist(), both have 6-place accuracy
//----------------------------------------------------------------------------------------
function ZenithDist2(a, d)
{
    var hr = DEGRAD * 15.0 * Util.HourAngle12(a);
    var dr = DEGRAD * d;
    var pr = DEGRAD * Util.ScriptTelescope.SiteLatitude;
    var sh = Math.sin(hr);
    var ch = Math.cos(hr);
    var sd = Math.sin(dr);
    var cd = Math.cos(dr);
    var sp = Math.sin(pr);
    var cp = Math.cos(pr);

    var x = ch * cd * sp - sd * cp;
    var y = sh * cd;
    var z = ch * cd * cp + sd * sp;

    return(RADDEG * Math.atan2(Math.sqrt((x * x) + (y * y )), z));
}

//----------------------------------------------------------------------------------------
//
// ---------
// AirMass() - Return current airmass
// ---------
//
// This returns the observed airmass - as affected by refraction.
// See comments for function _airmass() below for details.
//----------------------------------------------------------------------------------------
function AirMass(a, d)
{
    return(_airmass(ZenithDist2(a, d) * DEGRAD));
}

//----------------------------------------------------------------------------------------
//
// ---------------
// ZDFromAirMass() - Return zenith distance (deg.) for given airmass
// ---------------
//
// Uses the Newton-Raphson method to find the root of the polnomial that gives
// airmass for zenith distance. See comments for function _airmass() below for 
// details on tis polynomial. Uses _airmassdot() for first derivative of same.
// Adapted from Press, et al., Numerical Recipes in C (Second Edition), Cambridge
// University Press, reprinted 1999. Does up to 100 iterations, convergence is
// within 0.01 degree = 0.00017453 radians. The function is very well behaved, so
// this simple implementation does the trick without jumping out of bounds.
// Bounds are 0 to 87 degrees (1.52 radians).
//----------------------------------------------------------------------------------------
function ZDFromAirMass(m)
{
    var dx, f, df, i;
    var z = 1.52;                                               // WILL NOT CONVERGE FROM BELOW! (???)
    if(m > 13.0)                                                // Blows up for higher airmasses
        return(87.0);
    for(i = 1; i < 30; i++) {                                   // Iteration
        f = _airmass(z) - m;                                    // Airmass fuction value
        df = _airmassdot(z);                                    // First derivative of AirMass
        dx = (f / df);                                          // Step to take
        z -= dx;                                                // Take the step
        if((-z) * (z - 1.52) < 0.0)                             // Out of rbounds????
            throw("ZDFromAirmass() jumped out of bounds.");
        if(Math.abs(dx) < 0.00017453)
            return(z * RADDEG);                                 // Converged == EXIT FUNCTION ==
    }
    throw("Maximum number of iterations exceeded in ZDFromAirmass()");
}
    

//----------------------------------------------------------------------------------------
//
// ---------
// LSTRise() - Calculate the LST at which a target rises above given zenith distance
// ---------
//
// Arguments:
//              RA          RightAscension, hours
//              Dec         Declination, degrees
//              ZD          Zenith distance, degrees
//
// Return:      LST of object rise
//              -2.0 if always visible
//              -1.0 if never rises 
//
//----------------------------------------------------------------------------------------
function LSTRise(a, d, zd)
{
    var ra, dec, z;                                             // Parameters in radians
    var h;                                                      // Hour angle (radians)
    var cos_h;                                                  // Cos(Hour Angle)
    var EPS = (1e-9);                                           // Safety tolerance
    var lat = Util.ScriptTelescope.SiteLatitude * DEGRAD;       // Latitude (radians)
    
    ra = a * 15.0 * DEGRAD;                                    // Convert to radians
    dec = d * DEGRAD;
    z = zd * DEGRAD;

    //
    // Reflect lat and dec if in southern hemisphere
    //
    if(lat < 0.0) {
        lat = -lat;
        dec = -dec;
    }

    //
    // Consider special cases first. This also avoids
    // boundary problems in the main calculation.
    //
    if((Math.PI - Math.abs(dec + lat)) <= (z + EPS)) return(-2);    // Never below
    if((Math.abs(dec - lat)) >= (z - EPS)) return(-1);         // Never above
    
    //
    // Compute rising hour angle
    //
    cos_h = (Math.cos(z) - Math.sin(lat) * Math.sin(dec)) / (Math.cos(lat) * Math.cos(dec));
    if (cos_h >= 1.0)
        h =  0.0;
    else if (cos_h <= -1.0)
        h = Math.PI;
    else
        h = Math.acos(cos_h);
    
    //
    // Convert to rising LST
    //
    var lstr = RangeTime((ra - h) * RADDEG / 15.0);
    return(lstr);

}

//----------------------------------------------------------------------------------------
//
// -----------
// GaussRand() - Return normally distributed deviate with zero mean and given sigma
// -----------
//
// Uses Box-Muller trasformation to get pairs of deviates, and returns them
// one at a time. Static variables are used to preserve state between calls.
// 
// References:
//  Press, W.H. [et.al], 1988, 1992, in "Numerical Recipes in C" (2nd ed. rep 1999)
//      Cambridge University Press, p289 (converted from given C)
//
// s = standard deviation of resulting random numbers.
//----------------------------------------------------------------------------------------
var _g1 = true;
var _gx, _gy;
function GaussRand(s)
{
    var rsq;
    
    if(_g1)                                         // Need to generate (again)?
    {
        //
        // Yes, pick two uniform numbers within a unit circle
        //
        do 
        {
            _gx = (2.0 * Math.random()) - 1.0;
            _gy = (2.0 * Math.random()) - 1.0;
            rsq = ((_gx * _gx) + (_gy * _gy));
        } while(rsq >= 1.0);

        //
        // Make Box-Muller transformation, generating two deviates
        // Be safe for small (1.0e-20) radius in unit circle.
        //
        var fac = (rsq > 1.0e-20) ? Math.sqrt (-2.0 * Math.log(rsq) / rsq) : 0.0;
        _gx *= fac;
        _gy *= fac;
        _g1 = false;                                // Have 2 deviates
        return(_gx * s);                            // Return first, scaled to sigma
    } 
    else 
    {
        //
        // Return second deviate and reset generate flag
        //
        _g1 = true;                                 // Need to generate
        return(_gy * s);                            // Return second, scaled to sigma
    }
}

//----------------------------------------------------------------------------------------
//
// UnifRand() - Uniformly disctibured random number 0 <= n < hi
//
// Really just an interface to the JScript rand-gen for VBS code.
//----------------------------------------------------------------------------------------

function UnifRand(hi)
{
    return(Math.random() * hi);
}

//----------------------------------------------------------------------------------------
//
// DateToJulian() - Convert Gregorian calendar date to Julian
//
// Good for Gregorian dates after 28-Feb-1900. The Util.Date_Julian() method in ACP is
// a pain to use because the date is Local time. 
//----------------------------------------------------------------------------------------
function DateToJulian(yr, mo, dy)
{
    return((367 * yr) - _trunc((7 * (yr + _trunc((mo + 9) / 12))) / 4) + 
                                _trunc((275 * mo) / 9) + dy + 1721013.5);
}

//----------------------------------------------------------------------------------------
// 
// HJD() - Convert Julian date to Heliocentric Julian Date
//
// This will give a very slightly different answer than the (typical) Meeus algorithms
// but you can consider this the more accurate as it uses the rigorous math in the USNO
// NOVAS library. If Bary is True, calculate Barycentric not Heliocentric.
//----------------------------------------------------------------------------------------
function HJD(JD, RA, DE, Bary)
{
    if(Bary) JD += Util.DeltaT(JD) / 86400.0;               // If asked for barycentric, adjust
    var KT = new ActiveXObject("Kepler.Ephemeris");         // Re-usable Earth ephem (reverse = Sun!)
    KT.BodyType = 0;                                        // Planet
    KT.Number = 3;                                          // EARTH
    var KA = new VBArray(KT.GetPositionAndVelocity(JD)).toArray(); // Get cartesian vector to earth from sun
    var SV = new ActiveXObject("NOVAS.PositionVector");
    SV.x = -KA[0];                                          // Reverse cartesian vector for sun from earth
    SV.y = -KA[1];
    SV.z = -KA[2];
    var z = (Math.sin(DE * DEGRAD) * Math.sin(SV.Declination * DEGRAD)) + 
            (Math.cos(DE * DEGRAD) * Math.cos(SV.Declination * DEGRAD) * Math.cos((RA - SV.RightAscension) * 15  * DEGRAD));
    return JD - (SV.Lighttime * z);                         // computed Helio/Bary-centric Julian Date
}

//----------------------------------------------------------------------------------------
//
// NevilleVB() - Lagrange interpolation, Neville's algorithm (VBScript flavor)
//
// Array inputs must be VB/SAFE type arrays (See NevilleJS()), this is a wrapper.
//----------------------------------------------------------------------------------------
function NevilleVB(xav, yav, n, x)                        // Returns y
{
    var xa = new VBArray(xav).toArray();
    var ya = new VBArray(yav).toArray();
    return(NevilleJS(xa, ya, n, x));
}

//----------------------------------------------------------------------------------------
//
// NevilleJS() - Lagrange interpolation, Neville's algorithm (JScript flavor)
//
// Array inputs must be JScript type arrays (See NevilleVB())
//
// This code was adapted from that given in Press et al., 
// "Numerical Recipes in C", 1997-1999, Cambridge University
// press ISBN 0-521-43108-5 and used with permission.
//
//----------------------------------------------------------------------------------------
function NevilleJS(xa, ya, n, x)                          // Returns y
{
    var i, m, ns, den, dif, dift, ho, hp, w, y, dy;
    
    ns = 0;
    dif = Math.abs(x - xa[0]);

    var c = new Array(n - 1);
    var d = new Array(n - 1);

    for(i = 0; i < n; i++)                              // Find index 'ns' of the closest table entry
    {
        dift = Math.abs(x - xa[i]);
        if(dift < dif)
        {
            ns = i;
            dif = dift;
        }
        c[i] = ya[i];                                   // Initialize the tableau of c[] and d[]
        d[i] = ya[i];
    }
    
    y = ya[ns--];                                       // Initial approximation of y
    
    for(m = 1; m < n; m++)                              // For each column of the tableau
    {
        for(i = 0; i < (n - m); i++)                    // Loop over and update c[] and d[]
        {
            ho = xa[i] - x;
            hp = xa[i + m] - x;
            w = c[i + 1] - d[i];
            den = ho - hp;
            //
            // This error can happen only if two input values are
            // (to within roundoff) identical.
            //
            if(den === 0.0) throw "Error in Neville()";
            den = w / den;
            d[i] = hp * den;                            // Update c[] and d[]
            c[i] = ho * den;
        }
        //
        // After each column of the tableau is completed, we decide which correction
        // (c or d) we want to add to our accumulating value of y, i.e. which path to
        // take through the tableau -- forking up or down. We do this in such a way as
        // to take the most "straight line" route through the tableau to its apex,
        // updating 'ns' accordingly to keep track of where we are. This route keeps
        // the partial approximations centered (insofar as possible) on the target x.
        // The last dy added is therefore the error condition.
        //
        dy = ((2 * ns) < (n - m)) ? c[ns + 1] : d[ns--];
        y += dy;
    }
    return(y);
}

//----------------------------------------------------------------------------------------
//
// PlateToPA() - Return Position Angle from a solved Plate
//
// Position angle 0-360 defined as 0 degrees north-up, increasing with counter-clockwise
// image rotation. Handles mirrored images. ASSUMES PLATE IS SOLVED!
//----------------------------------------------------------------------------------------
function PlateToPA(p)
{
    var PA;

    if(p.ArcsecPerPixelVert < 0) {
        PA = -p.RollAngle;
        if(PA < 0.0) PA = 360.0 + PA;
    } else {
        PA = 180.0 - p.RollAngle;
    }
    return(PA);
}

// ==================
// INTERNAL FUNCTIONS
// ==================

//----------------------------------------------------------------------------------------
//
// ----------------
// CalcSlewTarget() - Calculate re-slew target coordinates (J2000)
// ----------------
//
// Puts the target J2000 coordinates into c_slewTargetRA/Dec, and returns a vector
// [RA|Dec] with the target coordinates (for JScript callers)
//
// ad = Desired true right ascension (hours, J2000)
// dd = Desired true declination (degrees, J2000)
// at = Current true right ascension (hours, J2000)
// dt = Current true declination (degrees, J2000)
// ai = Current indicated right ascension (J2000 or local topo, hours)
// di = Current indicated declination (J2000 or local topo, degrees)
//
// When running in Local Topo mode, this uses the difference between J2000 and local topo 
// of the current true coordinates to convert current indicated local topo to J2000.
//----------------------------------------------------------------------------------------
function CalcSlewTarget(ad, dd, at, dt, ai, di)
{
    var atc, dtc;
    if (c_needLocalTopo)
    {
        J2000ToLocalTopocentric(at, dt);        // Convert current true to local topo
        atc = c_localTopoRA;
        dtc = c_localTopoDec;
    }
    else
    {
        atc = at;                               // Running in J2000
        dtc = dt;
    }
    var adr = 15.0 * DEGRAD * ad;               // Desired true (J2000)
    var atr = 15.0 * DEGRAD * atc;              // Current true (J2000 or local topo)
    var air = 15.0 * DEGRAD * ai;               // Current indicated (J2000 or local topo)
    var ddr = DEGRAD * dd;                      // Desired true (J2000)
    var dtr = DEGRAD * dtc;                     // Current true (J2000 or local topo)
    var dir = DEGRAD * di;                      // Current indicated (J2000 or local topo)

    var vdj = _equ2usr(adr, ddr);               // Desired true (J2000)
    var vt = _equ2usr(atr, dtr);                // Current true (J2000 or local topo)
    var vi = _equ2usr(air, dir);                // Current indicated (J2000 or local topo)
    
    var vs = new Array(3);                      // Will get USR desired (J2000)
    for(var i = 0; i < 3; i++)                  // Do the vector addition
    {
        vs[i] = vi[i] + vdj[i] - vt[i];         // Desired indicated (J2000)
    }
    
    var ev = _usr2equ(vs);                      // Convert target coords to equ radians
    ev[0] *= (RADDEG / 15.0);                   // Convert RA to hours
    ev[0] = RangeTime(ev[0]);                   // Range back to 0-24
    ev[1] *= RADDEG;                            // Convert Dec to degrees
    c_slewTargetRA = ev[0];                     // Set properties for VB callers
    c_slewTargetDec = ev[1];
    return(ev);                                 // Return RA/Dec in array
    
}

//----------------------------------------------------------------------------------------
//
// RangeAngle() - Force angular value to fall into the given range
//
// Modular arithmetic support. Used to re-range angles, etc. after arithmetic.
// Works for 0 to 360 or -180 to 180. Called from VBS, so no leading _
//----------------------------------------------------------------------------------------
function RangeAngle(val, lo, hi)
{
    var ret = val;
    while(ret < lo) ret += 360.0;
    while(ret >= hi) ret -= 360.0;
    return(ret);
}

//----------------------------------------------------------------------------------------
//
// RangeTime() - Force time value (hours) to fall within 0-24
//
// Modular arithmetic support. Used to re-range times. after arithmetic.
// Called from VBS, so no leading _
//----------------------------------------------------------------------------------------
function RangeTime(val)
{
    var ret = val;
    while(ret < 0.0) ret += 24.0;
    while(ret >= 24.0) ret -= 24.0;
    return(ret);
}

//----------------------------------------------------------------------------------------
//
// --------
// _trunc() - Truncates a number. JScript doesn't have this.
// --------
//----------------------------------------------------------------------------------------
function _trunc(n)
{
    var sgn, tr;
    if(n < 0.0)
        sgn = -1;
    else
        sgn = 1;
    return(sgn * Math.floor(Math.abs(n)));
}

//----------------------------------------------------------------------------------------
//
// ----------
// _equ2usr() - Return USR coordinate vector for given RA/Dec (RADIANS!!)
// ----------
//
//----------------------------------------------------------------------------------------
function _equ2usr(a, d)
{
    var v = new Array(3);
    var cd = Math.cos(d);
    v[0] = Math.cos (a) * cd;
    v[1] = Math.sin (a) * cd;
    v[2] = Math.sin (d);
    return(v);
}


//----------------------------------------------------------------------------------------
//
// ----------
// _usr2equ() - Return RA/Dec (RADIANS!) for given USR coordinate vector
// ----------
//
// v = USR coordinate vector
// return a 2 element array with RA, Dec
//----------------------------------------------------------------------------------------
function _usr2equ(v)
{
    var r = Math.sqrt((v[0] *v[0]) + (v[1] * v[1]));
    var ev = new Array(2);
    ev[0] = (r !== 0.0) ? Math.atan2(v[1], v[0]) : 0.0;     // RA (rad)
    ev[1] = (v[2] !== 0.0) ? Math.atan2(v[2], r) : 0.0;     // Dec (rad)
    return(ev);
}


//----------------------------------------------------------------------------------------
//
// --------
// _mkmat() - Make 3 x 3 matrix
// --------
//
// JScript doesn't directly support arrays...
//----------------------------------------------------------------------------------------
function _mkmat()
{
    var i;
    var m = new Array(3);
    for (i = 0; i < 3; i++) {
        m[i] = new Array(3);
    }
    return m;
}

//----------------------------------------------------------------------------------------
//
// -----------
// _identmat() - Set identity matrix  (3 x 3)
// -----------
//
//----------------------------------------------------------------------------------------
function _identmat(a)
{
    var i, j;
    for (i = 0; i < 3; i++) {
        for (j = 0; j < 3; j++ ) {
            a[i][j] = (i == j) ? 1.0 : 0.0;
        }
    }
    return(a);
}

//----------------------------------------------------------------------------------------
//
// ----------
// _matmult() - Matrix multiply [C] = [A] * [B]  (3 x 3 matrices)
// ----------
//
//----------------------------------------------------------------------------------------
function _matmult(a, b)
{
    var i, j, k;
    var p = _mkmat();                                   // Product matrix

    for(i = 0; i < 3; i++) {
        for (j = 0; j < 3; j++) {
            p[i][j] = 0.0;
            for (k = 0; k < 3; k++) {
                p[i][j] += a[i][k] * b[k][j];
            }
        }
    }
    return(p);
}

//----------------------------------------------------------------------------------------
//
// ---------
// _vecmult() - Multiply a vector by a matrix [W] = [R] * [v]  (3 x 3 matrix, 3 x 1 vector)
// ---------
//
//----------------------------------------------------------------------------------------
function _vecmult(rm, v)
{
    var i, k, z;
    var p = new Array(3);                               // Product vector

    for(i = 0; i < 3; i++) {
        p[i] = 0.0;
        for (k = 0; k < 3; k++) {
            p[i] += rm[i][k] * v[k];
        }
    }
    return(p);
}

//----------------------------------------------------------------------------------------
//
// ---------
// _rotusr() - Rotate USR coordinates through given RA and Dec (RADIANS!)
// ---------
//
// v = USR coordinates
// a = RA for USR coordinates, radians
// da = delta-RA, radians
// dd = delta-Dec, radians
//
// This is done with three rotations.
//----------------------------------------------------------------------------------------
function _rotusr(v, a, da, dd)
{
    //var a, d, s, c;
    var d, s, c;                                        // HOLY SHIT!
    var vr = new Array(v[0], v[1], v[2]);               // Returned vector
    var ri = _mkmat();                                  // Incremental rotation matrix
    
    //
    // (1) Rotate about Z axis by amount of RA
    //
    s = Math.sin(a);
    c = Math.cos(a);
    ri = _identmat(ri);
    ri[0][0] = c;
    ri[0][1] = s;
    ri[1][0] = -s;
    ri[1][1] = c;
    vr = _vecmult(ri, vr);
    //
    // (2) Rotate about new Y axis by Dec offset
    //
    s = Math.sin(dd);
    c = Math.cos(dd);
    ri = _identmat(ri);
    ri[0][0] = c;
    ri[0][2] = -s;
    ri[2][0] = s;
    ri[2][2] = c;

    vr = _vecmult(ri, vr);
    //
    // (1) Rotate back about new Z axis by amount of RA plus RA offset
    //
    s = Math.sin(-a - da);
    c = Math.cos(-a - da);
    ri = _identmat(ri);
    ri[0][0] = c;
    ri[0][1] = s;
    ri[1][0] = -s;
    ri[1][1] = c;
    vr = _vecmult(ri, vr);

    return(vr);
}


//----------------------------------------------------------------------------------------
//
// ----------
// _airmass() - Get airmass for given zenith distance
// ----------
//
// z = zenith distance (radians)
//
// Uses Hardie's (1962) polynomial fit to Bemporad's data for
// the relative air mass, X, in units of thickness at the zenith
// as tabulated by Schoenberg (1929). This is adequate for all
// normal needs as it is accurate to better than 0.1% up to X =
// 6.8 and better than 1% up to X = 10. Bemporad's tabulated
// values are unlikely to be trustworthy to such accuracy
// because of variations in density, pressure and other
// conditions in the atmosphere from those assumed in his work.
//
// Zenith Distance is limited to 87 deg to avoid overflow.
//
// References:
//   Hardie, R.H., 1962, in "Astronomical Techniques"
//       ed. W.A. Hiltner, University of Chicago Press, p180.
//   Schoenberg, E., 1929, Hdb. d. Ap.,
//       Berlin, Julius Springer, 2, 268.
// 
// a  = right ascension, hours
// d  = declination, degrees
//
// Adapted from original Fortran code by P.W.Hill, St Andrews, C by P.T.Wallace.
// Used by public AirMass()  method and also for Newton-Raphson solving to
// back into zenith distance from given airmass (ZDFromAirMass())
//----------------------------------------------------------------------------------------
function _airmass(z)
{
    if(z > 1.52) z = 1.52;                          // Limit z to 87 degrees
    var szm1 = (1.0 / Math.cos(z)) - 1.0;
    return(1.0 + (szm1 * (0.9981833 - (szm1 * (0.002875 + (szm1 * 0.0008083))))));
}

//----------------------------------------------------------------------------------------
//
// -------------
// _airmassdot() - Get first derivative of AirMass
// -------------
//
// Used by Newton-Raphson solving to back into zenith distance from airmass.
// See comments for _airmass() for details.
//----------------------------------------------------------------------------------------
function _airmassdot(z)
{
    if(z > 1.51) z = 1.51;                          // Limit z to 87 degrees - dx
    var a1 = _airmass(z);
    var a2 = _airmass(z + 0.01);
    return((a2 - a1) / 0.01);
}

]]>
	</script>
	<script id="AcquireSupportJS" language="JScript">
<![CDATA[
//
// PointingBinning() - Calculate pointing exposure binning
//
//var PointingBinning   // PrimalScript target
function get_PointingBinning()
{
    var Camera = Util.ScriptCamera;
    var pixScale = (Math.min(c_ScaleH, c_ScaleV));
    var maxBinXY = Math.min(Camera.MaxBinX, Camera.MaxBinY);
    if(pixScale < PIXBIN_4 && maxBinXY >= 4) return 4;
    if(!Camera.PowerOfTwoBinning && pixScale < PIXBIN_3 && maxBinXY >= 3) return 3;
    if(pixScale < PIXBIN_2 && maxBinXY >= 2) return 2;
    return 1;
}

//
// -------------
// AllSkySolve() - All-Sky plate solve for lost scope
// -------------
//
// Returns true if succeeded, and if so, the found J2000 coordinates 
// in c_lastSolve[ra|dec]. 7.1 use PinPoint 6. 8.1 use VPP all-sky
// domain/port.
//
function AllSkySolve(imageFile)
{
    var Console = Util.Console;
    var ptgPrefs = Util.Prefs.PointingUpdates;
    var apiKey = Util.Prefs.AstrometryNetAPIKey;
    var PL = new ActiveXObject("PinPoint.Plate");
    
    try {
        Console.PrintLine("  Attempting all-sky plate solution (time-consuming)...");
        PL.AttachFITS(imageFile);
        PL.Catalog = Util.Prefs.ReferenceCatalogType
        PL.CatalogPath = Util.Prefs.ReferenceCatalogPath
        PL.CatalogExpansion = 0.0;
        PL.CatalogMaximumMagnitude = ptgPrefs.CatalogMaximumMagnitude;
        PL.SigmaAboveMean = ptgPrefs.Sigma;
        PL.MaxSolveStars = 300;
        PL.ArcsecPerPixelHoriz = c_ScaleH * PL.BinningHoriz;
        PL.ArcsecPerPixelVert = c_ScaleV * PL.BinningVert;
        if (apiKey !== "")
            PL.AllSkyApiKey = apiKey;
        PL.AllSkyDomain = Util.Prefs.AllSkyDomainPort;
        PL.FindImageStars();                                                // Check if too few stars
        if (PL.ImageStars.Count < 3)                                        // Avoid really ugly A.N error
            throw new Error(0x80040004, "Too few stars for all-sky solution");
        PL.SolveAllSky();
        c_lastSolveRA = PL.RightAscension;
        c_lastSolveDec = PL.Declination;
        PL.UpdateFITS();
        try { PL.DetachFITS(); } catch(ex) {}
        PL = null;
        return true;
    } catch(ex) {
        Console.PrintLine("  Failed: " + ex.message);
        Console.PrintLine("  Astrometry.net may be offline or image quality is too poor.");
        try { PL.DetachFITS(); } catch(ex) {}
        c_lastSolveRA = NaN;
        c_lastSolveDec = NaN;
        PL = null;
        return false;
    }
}

// ---------------
// JournalForRSS() - Write a journal entry for the RSS feed
// ---------------
//
// This will grow forever... Rather than read through the whole thing
// and toss entries that are "too old" here, we expect the RSS reader
// to manage all of this however it wants. This means that if no one
// reads RSS, then the file will indeed grow forever! Manages locking
// and retries twice a second for up to 10 sec.
//
function JournalForRSS(title, msg)
{
	var iRetry = 0;															// Lock/retry counter
	do {
		try {
			var js = FSO.OpenTextFile(Util.Prefs.WebRoot + "\\RSSJournal.txt", 8, true);	// Append, create if not exist
			js.WriteLine(new Date().toUTCString() + "|" + title + "|" + msg);
			js.Close();
			js = null;
			return;															// Success, bail out
		} catch(ex) {
			Util.WaitForMilliseconds(500);
			iRetry += 1;
			if(iRetry >= 20) {												// 10 SECONDS??????
				Util.Console.PrintLine("**RSS journal failed: " + ex.message);
				return;
			}
		}
	} while(true);
	// Never get here
}

// =====================
// AO Guiding Polarities
// =====================

//
// Develop rotated bump polarities from PA for internal guider
// on simple/fork or GEM east of pier (looking west).
//
// Returns switch setting vector [RevX, RevY, SwapAxes]
//
function Rotate(PA)
{
    var r0 = [false,false,false];
    var r90 = [false,true,true];
    var r180 = [true,true,false];
    var r270 = [true,false,true];
    var rot = [r0, r90, r180, r270];

    if(PA >= 360.0) PA = PA - 360;                              // Range 0 <= angle < 360
    if(PA < 0) PA = PA + 360;
    var paq = Math.round(PA / 90.0);                            // PA in quadrants
    if(paq == 4) paq = 0;                                       // Handle wrap to 0
    return(rot[paq]);
    
}

//
// Flip the bump polarities about the "horizontal" axis (after rotation)
//
// Returns adjusted switch setting vector
//
function Flip(sv)
{
    if(!sv[2])
        sv[1] = !sv[1];
    else
        sv[0] = !sv[0];
    return sv;
}

//
// Reverse sense of Y for GEM west of pier looking east
//
// Returns adjusted switch setting vector
//
function RevY(sv)
{
    sv[1] = !sv[1];
    return sv;
}

//
// Set up bumping polarities for the given PA and whether or not
// it is an OAG (flipped guider image). See Rotated Guiding paper.
//
function SetupAOBumping(PA, OAG)
{
    Util.Console.PrintLine("  (Setting up rotated AO bumping polarities)");
    var GEMLooksWest = (Util.ScriptTelescope.AlignmentMode == 2) && Util.GEMWestOfPier;     // True only if GEM looking west
    var sv;

    if(OAG)
        sv = Flip(Rotate(PA));
    else
        sv = Rotate(PA);
    
    // See ACP-626 - The Astro-Physics (Reilly, Miller/Walker)
    // behaves like guide cables, when looking west the bump needs
    // Reverse-Y. On the Paramount (e.g.) the mount does this so we
    // do not need to do it. Thus with the ReverseYonFlip true, 
    // we do NOT want to reverse Y here. The name of the variable is
    // confusing, it is reversing OUT the Reverse that normally is
    // needed. EGAD!!
    //
    if(GEMLooksWest && !Util.Prefs.AutoGuiding.ReverseYonFlip)
        sv = RevY(sv);
    
    Util.Console.PrintLine("  (switches are " + sv + ")");
    Util.ScriptCamera.GuiderReverseX = sv[0];
    Util.ScriptCamera.GuiderReverseY = sv[1];
    Util.ScriptCamera.AOSwapMotorAxes = sv[2];
}

// ========================
// Web UI tracking graph(s)
// ========================
//
// These arrays and functions are used to manage the tracking error history,
// and to provide data to asystemstatus.asp. The arrays function as silos,
// containing the last 'n' guider errors while guiding is active. When not
// guiding, the arrays are empty. The data given to asystemstatus are
// comma-delimited lists of values.
//
var guideErrHistX = [];
var guideErrHistY = [];

//
// Clear the Auto Guiding history arrays
//
function ClearAGHistory()
{
    guideErrHistX = [];
    guideErrHistY = [];
}

//
// Capture current guider tracking errors into the silo arrays. Called by
// asystemstatus.ASP (via Util.Script.SUP.CaptureAGErrors()) periodically.
// Argument MaxTrkPoints is the number of points to keep in the silo arrays.
//
function CaptureAGErrors(MaxTrkPoints)
{
       while(guideErrHistX.length >= MaxTrkPoints)                          // Make a silo
       {
           guideErrHistX.shift();
           guideErrHistY.shift();
       }
       var ex = Util.ScriptCamera.GuiderXError;
       var ey = Util.ScriptCamera.GuiderYError;
       if(Util.Prefs.PointingUpdates.Simulate)
       {
           ex *= 3;
           ey *= 3;
       }
       var exs = Util.FormatVar(ex, "0.00");
       exs = exs.replace(/\,/, ".");                                        // Fix decimal in Europe
       guideErrHistX.push(exs);
       var eys = Util.FormatVar(ey, "0.00");
       eys = eys.replace(/\,/, ".");                                        // Fix decimal in Europe
       guideErrHistY.push(eys);
}

//
// Return comma-separated lists of AG errors in decimal strings (typ.)
//

//var AGErrorListX (PrimalSCRIPT target)
function get_AGErrorListX()
{
    return guideErrHistX.join(",");
}

//var AGErrorListY (PrimalSCRIPT target)
function get_AGErrorListY()
{
    return guideErrHistY.join(",");
}

//
// Special format for XY plot (JQuery Sparkline) x:y,x:y,...
// Furthermore, we offset the X values by +2 so they are not 
// -2 to +2 but 0 to 4 as required for the sparkline plugin.
// Yeah, this is hardcoding the scale. SORRY!
//
//var AGErrorListXY (PrimalSCRIPT target)
function get_AGErrorListXY()
{
    var histXY = [];
    for(var i = 0; i < guideErrHistX.length; i++)
    {
        var x = parseFloat(guideErrHistX[i]) + 2.0;
        x = Math.min(x, 4.0);                                               // Clamp 0-4
        x = Math.max(x, 0.0);
        var xs = Util.FormatVar(x, "0.00");                                 // Convert to string
        xs = xs.replace(/\,/, ".");                                         // Fix decimal in Europe
        histXY.push(xs + ":" + guideErrHistY[i].toString());
    }
    return histXY.join(",");
}


]]>
	</script>
	<!-- ================================================================================================= -->
	<script id="PlaneWaveAutoFocus" language="JScript">
<![CDATA[
    //
    // Perform an AutoFocus run through PlaneWave software.
    // If an AutoFocus object has already been created, pass it
    // through the optional "af" parameter. Otherwise a new
    // AutoFocus object will be created.
    //
    // By: Kevin Ivarsen (Planewave) June 2014
    //     Separate script package due to JScript language (I'm jealous)
    //
    function PlaneWaveAutoFocus(af)
    {
        if (af == null) {
            Util.Console.PrintLine("Initializing PlaneWave AutoFocus library...");
            af = new ActiveXObject("PlaneWave.AutoFocus");
        }
        
        Util.Console.PrintLine("Starting PWI if needed...");
        af.StartPwiIfNeeded();
        ConsumePlaneWaveAutoFocusMessages(af);

        Util.Console.PrintLine("Connecting to focuser if needed...");
        af.ConnectFocuser();
        ConsumePlaneWaveAutoFocusMessages(af);

        //
        // At this point I am not going to honor the AF scheduling in PWI.
        // I see this as a support issue ("I wanted an AF, but it was skipped, why?")
        // ACP and Scheduler should be 100% in charge of the timing of AF ops.
        //
//         Util.Console.PrintLine("Checking if Auto Focus is required...");
//         if (! af.IsAutoFocusDesired) {
//             Util.Console.PrintLine("AutoFocus is not desired at this point.");
//             return;
//         }

        Util.Console.PrintLine("Beginning AutoFocus...");

        // Override PWI if it is configured to change filters before a focus run
        af.PreventFilterChange = true; 

        af.StartAutoFocus();

        while (af.IsAutoFocusRunning) {
            ConsumePlaneWaveAutoFocusMessages(af);
            Util.WaitForMilliseconds(200);
        }

        return af.Success;
    }

    //
    // Grabs all available log lines from PWI and puts them into
    // the ACP console log.
    //
    function ConsumePlaneWaveAutoFocusMessages(pwAutoFocus)
    {
        while (true) {
            var logLine = pwAutoFocus.NextLogMessage;
            if (logLine == null) {
                return;
            }
            Util.Console.PrintLine(logLine);
        }
    }

]]>
	</script>
</component>
</package>
